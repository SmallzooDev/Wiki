[{"content":"Rust-Redis-D1 0. PreRequisite 해당 문서의 참고입니다! https://app.codecrafters.io/concepts/rust-tcp-server\nstd::net 모듈은 TCP 서버를 만들기 위한 모듈이다. 그리고 아래의 다섯가지 메셔드를 주요하게 이용한다. TcpListener::bind : pub fn bind\u0026lt;A: ToSocketAddrs\u0026gt;(addr: A) -\u0026gt; Result\u0026lt;TcpListener\u0026gt; - 주어진 주소에 바인딩된 새로운 TcpListener 인스턴스를 반환한다 TcpListener::incoming : pub fn incoming(\u0026amp;self) -\u0026gt; Incoming - 이 리스너로 들어오는 coneection에 대한 iterator를 반환한다. TcpStream::connect : pub fn connect\u0026lt;A: ToSocketAddrs\u0026gt;(addr: A) -\u0026gt; Result\u0026lt;TcpStream\u0026gt; - 주어진 주소로 연결된 새로운 TcpStream 인스턴스를 반환한다. TcpStream::read : pub fn read(\u0026amp;mut self, buf: \u0026amp;mut [u8]) -\u0026gt; Result\u0026lt;usize\u0026gt; - 스트림에서 데이터를 읽어서 주어진 버퍼에 저장한다. TcpStream::write_all : pub fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt; - 스트림에 주어진 버퍼의 모든 데이터를 쓴다. TcpLister Struct는 아래와 같이 구성되어 있다.\nimpl TcpListener { // accept는 대기 중인 연결을 수락하고, connection을 반환한다. pub fn accept(\u0026amp;self) -\u0026gt; Result\u0026lt;(TcpStream, SocketAddr)\u0026gt;; // incoming은 이 listener로 들어오는 connection에 대한 iterator를 반환한다. pub fn incoming(\u0026amp;self) -\u0026gt; Incoming\u0026lt;TcpStream\u0026gt;; // local_addr는 이 listener가 바인딩된 주소를 반환한다. pub fn local_addr(\u0026amp;self) -\u0026gt; Result\u0026lt;SocketAddr\u0026gt;; } TcpStream Struct는 아래와 같이 구성되어 있다.\nimpl TcpStream { pub fn read(\u0026amp;mut self, buf: \u0026amp;mut [u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; pub fn write(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; pub fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt;; } 참고하자면, write_all은 아래처럼 버퍼의 모든 데이터를 쓰는걸 보장해주기 때문에, 간단하게 사용할 수 있다.\nfn write_all(\u0026amp;mut self, mut buf: \u0026amp;[u8]) -\u0026gt; io::Result\u0026lt;()\u0026gt; { while !buf.is_empty() { match self.write(buf) { Ok(0) =\u0026gt; { return Err(io::Error::new( io::ErrorKind::WriteZero, \u0026#34;failed to write whole buffer\u0026#34;, )); } Ok(n) =\u0026gt; buf = \u0026amp;buf[n..], Err(ref e) if e.kind() == io::ErrorKind::Interrupted =\u0026gt; {} Err(e) =\u0026gt; return Err(e), } } Ok(()) } fn handle_client(mut stream: TcpStream) { let mut buffer = [0; 512]; loop { let byte_read = stream.read(\u0026amp;mut buffer).expect(\u0026#34;Failed to read\u0026#34;); if byte_read == 0 { return; } stream.write_all(\u0026amp;buffer[0..byte_read]).expect(\u0026#34;Feil to write\u0026#34;); } } fn main() { let listener = TcpListener::bind(\u0026#34;localhost:8080\u0026#34;).expect(\u0026#34;Could not bind\u0026#34;); for stream in listener.incoming() { match stream { Ok(stream) =\u0026gt; { handle_client(stream); } Err(e) =\u0026gt; { eprintln!(\u0026#34;Failed: {}\u0026#34;, e); } } } } 참고 : 한번에 하나의 커넥션만 처리가 가능하고, 다른 커넥션은 blocked된다.\n","permalink":"http://localhost:1313/_wiki/rust-redis-d1/","summary":"Rust-Redis-D1 0. PreRequisite 해당 문서의 참고입니다! https://app.codecrafters.io/concepts/rust-tcp-server\nstd::net 모듈은 TCP 서버를 만들기 위한 모듈이다. 그리고 아래의 다섯가지 메셔드를 주요하게 이용한다. TcpListener::bind : pub fn bind\u0026lt;A: ToSocketAddrs\u0026gt;(addr: A) -\u0026gt; Result\u0026lt;TcpListener\u0026gt; - 주어진 주소에 바인딩된 새로운 TcpListener 인스턴스를 반환한다 TcpListener::incoming : pub fn incoming(\u0026amp;self) -\u0026gt; Incoming - 이 리스너로 들어오는 coneection에 대한 iterator를 반환한다. TcpStream::connect : pub fn connect\u0026lt;A: ToSocketAddrs\u0026gt;(addr: A) -\u0026gt; Result\u0026lt;TcpStream\u0026gt; - 주어진 주소로 연결된 새로운 TcpStream 인스턴스를 반환한다. TcpStream::read : pub fn read(\u0026amp;mut self, buf: \u0026amp;mut [u8]) -\u0026gt; Result\u0026lt;usize\u0026gt; - 스트림에서 데이터를 읽어서 주어진 버퍼에 저장한다.","title":"Rust-Redis-D1"},{"content":"4장 부호화와 발전 어플리케이션의 변경과 변화에 대응하는 방법을 소개하는 장. 일단 먼저 대규모 어플리케이션 변화에 있어 장애물이 되는 부분은 크게 아래와같다.\n데이터타입이나 스키마가 변경되는 경우 서버측에서는 순회식 업그레이드를 진행한다. 클라이언트측 어플리케이션은 사용자에 전적으로 좌우된다. 어떤 사용자는 한동안 업그레이드를 하지 않을 수도 있다. 즉 예전버전의 코드와 새로운 버전의 코드, 이전의 데이터타입과 새로운 데이터타입 이 시스템에 공존 할 수 있다는 것이다. 그래서 시스템에는 양방향의 호환성이 필요하다.\n하위 호환성 : 새로운 코드는 이전 코드가 기록한 데이터를 읽을 수 있어야 한다. 상위 호환성 : 이전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다. 데이터 부호화 형식 데이터는 크게 두가지 형식으로 다뤄진다.\n메모리에서 : 데이터는 메모리 위에서 표현되며, CPU가 효율적으로 읽고 처리할 수 있도록 구조화되고 최적화된다. 디스크나 네트워크에서 : 데이터는 바이트 스트림으로 저장되며, 이는 다양한 시스템에서 호환되도록 한다. 그래서 이 두가지 형식에서 일련의 전환이 필요한데 그것을 부호화라고 한다. (일반적으로 직렬화라고 더 많이 하지만 트랜잭션에서 동일한 용어가 사용되어 부호화로 표현)\n언어별 부호화 형식 기본적으로 언어별로 부호화 하는 기능들이 존재한다. 다만 이러한 부호화 형식은 언어별로 다르기 때문에 서로 호환되지 않고, 보안 이슈가 발생 할 수 있으며, 특정 언어는 성능이슈도 있다 (Java의 직렬화) JSON, XML, 그리고 이진 변형 JSON, XML은 가장 많이 사용되는 부호화 형식이다. 싫어하는 사람만큼 좋아하는 사람도 많다. 텍스트 형식이기 때문에 사람이 어느 정도 읽을 수 있고, JSON같은경우는 사용처가 압도적으로 많으며 쉽다는 장점이 있다. 다만 아쉬운점도 여러가지가 있는데, 대표적으로 수와 숫자로 구성된 문자열을 구분 할 수 없으며, 부동소수점의 정확도가 떨어진다. 유니코드 문자열은 지원하지만, 이진 문자열은 지원하지 않는다. 이진 부호화 형식 이러한 단점을 보완하기 위해 이진 부호화 형식이 등장했다. { \u0026#34;userName\u0026#34;: \u0026#34;Martin\u0026#34;, \u0026#34;favoriteNumber\u0026#34;: 1337, \u0026#34;interests\u0026#34;: [\u0026#34;daydreaming\u0026#34;, \u0026#34;hacking\u0026#34;] } 위와 같은 JSON(81바이트)을 이진 부호화 형식으로 변환하면 아래와 같다. 03 A8 75 73 65 72 4E 61 6D 65 06 4D 61 72 74 69 6E 0D 66 61 76 6F 72 69 74 65 4E 75 6D 62 65 72 04 0D 간단하게 타입 정의로 데이터를 표현해서 15 바이트를 줄였다.\n스리프트와 프로토콜 버퍼 스리프트와 프로토컬 버퍼는 기본적으로 스키마를 정의한다.\nmessage Person { 1: required string userName; 2: optional i32 favoriteNumber; 3: repeated string interests; } 이 상태로 데이터를 직렬화 하는데, 방식이 두가지가 있다. (바이너리 프로토콜, 컴팩트 프로토콜)\n단순히 스키마를 기반으로 필드 이름을 태그로 표현해서 절약하는 방식.\n여기서 컴팩트 프로토콜은 필드태그나 숫자 데이터 형식까지 단일 바이트 가변길이 정수로 인코딩한다.\n필드 태그와 스키마 발전 그렇다면 스키마가 변경되는 경우에 어떻게 상위호환성과 하위호환성을 유지할 수 있을까? 결론은 문제가 없다. 부호화된 레코드는 부호화된 필드의 연결일 뿐이다. 새로운 필드가 추가되면 이전 버전의 코드는 새로운 필드를 무시하고, 버퍼를 건너뛰면 된다. 반대로 새로운 코드가 이전 버전의 레코드를 읽을 때는 태그 번호가 같은 의미를 유지하기 때문에 문제가 없다. 다만 추가되는 필드가 required인 경우에는 문제가 발생하기에 이런 경우에는 optional 또는 default 값을 사용해야 한다. 필드를 삭제하는 경우도 마찬가지인데, 이 경우에는 optional필드만 삭제가 가능하고, 기존 태그번호는 변경하지 않는다. 데이터 타입과 스키마 발전 이건 그냥 32비트 정수를 64비트 정수로 바꾸는 경우를 생각해보면 간단한데, 이 경우에는 하위호환성이 보장되지 않는다. (새로운 코드는 이전 버전의 데이터를 읽지만, 이전 버전의 코드는 새로운 데이터를 읽을 수 없다.) 아브로 아브로는 스리프트와 다른 하둡의 부호화 형식이다.\n아브로의 예제 스키마는 아래와 같다.\n{ \u0026#34;type\u0026#34;: \u0026#34;record\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;fields\u0026#34;: [ {\u0026#34;name\u0026#34;: \u0026#34;userName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;favoriteNumber\u0026#34;, \u0026#34;type\u0026#34;: [\u0026#34;int\u0026#34;, \u0026#34;null\u0026#34;]}, {\u0026#34;name\u0026#34;: \u0026#34;interests\u0026#34;, \u0026#34;type\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: \u0026#34;string\u0026#34;}} ] } 아브로는 태그 번호를 사용하지 않고, 스키마의 순서에 의존한다. 이러한 방식의 문제점은 읽는코드와 쓰는 코드가 정확히 같은 스키마를 사용해야만 복호화 할 수 있다는 것이다. 이러한 문제점을 아브로는 Avro Reader라는 계층을 두고 쓰기와 읽기 스키마를 분리해서 Avro Reader가 읽기스키마에 맞게 데이터를 변환해준다. 더 정확히는 Avro Reader는 쓰기 스키마와 읽기 스키마를 비교해서 변환을 해준다. 먼저 쓰기 스키마에 있는데 읽기 스키마에는 없는 필드는 무시한다. 반대로 쓰기 스키마에 없는데 읽기 스키마에 있는 필드는 기본값을 사용한다. 스키마 발전 규칙 아브로에서 상위 호환성은 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음을 의미하고, 하위 호환성은 예전 버전의 쓰기 스키마와 새로운 버전의 읽기 스키마를 가질 수 있음을 의미한다.\n기본값이 있는 필드만 추가하거나 삭제 할 수 있다. (새로운 필드를 가진 읽기스키마는 예전 데이터를 만나면 기본값으로 채워넣으면 그만) 기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기록한 데이터를 읽을 수 없다. 기본값이 없는 필드를 삭제하면 예전 읽기 스키마는 새로운 쓰기 스키마가 기록한 데이터를 읽을 수 없다. null 대신 union을 이용한다 () 필드의 타입을 변경할 수 있다. (int -\u0026gt; long) (스키마의 타입 변경을 지원) 필드의 이름을 변경할 수 있다. (근데 별칭을 통해서 하위 호환성을 유지할 수 있는 방식으로 지원하기에, 상위 호환성은 없다) 그러면 쓰기 스키마는 무엇인가? 근데 대충 얼버무렸지만, 쓰기 스키마를 언제 제공할건데?\n먼저 모든 레코드에 쓰기 스키마를 포함하는건 말이 안된다. 그래서 사실 방법에 따라서 다르게 제공한다. 많은 레코드가 있는 대용량 파일 -\u0026gt; 파일의 시작에 쓰기 스키마를 저장한다. 개별적으로 기록된 레코드를 가진 데이터베이스 -\u0026gt; 데이터베이스에 스키마 버전 목록을 저장한다, 그리고 레코드마다 스키마 버전을 저장한다. 네트워크 연결 -\u0026gt; 클라이언트와 서버가 합의해서 스키마를 공유한다. (진짜 프로토콜이네!) 동적 생성 스키마 프로토콜 버퍼와 스리프트에 비해 아브로 방식은 한 가지 장점이 있따. 스키마에 태그번호가 포함돼 있지 않다는 것이다. 이 차이는 아브로가 동적 생성 스키마에 더 친숙하다는 것을 의미한다.\n아브로에서는 스키마가 변경되면, 갱신된 새로운 아브로 스키마를 생성하고 새로운 아브로 스키마로 데이터를 내보낸다. 데이터 내보내는 과정은 스키마 변경에 신경 쓸 필요가 없다. 그리고 이렇게 나온 데이터는 필드가 이름으로 식별되기 때문에, 여전히 이전 읽기 스키마로 읽을 수 있다. 스리프트나 프로토콜 버퍼는 관리자가 스키마 변경될 때마다 태그의 매핑을 수동으로 갱신해야 한다. 코드 생성과 동적 타입 언어 스리프트와 프로토콜 버퍼는 코드 생성에 의존한다. (코드 생성을 통해 스키마를 사용하는 코드를 생성한다.) 정적 타입 언어에서는 코드 생성이 매우 효과적이다. 문제는 동적 타입언어는 타입체크가 안되기도 하고 명시적 컴파일 단계가 없기 때문에 코드 생성이 어렵다. 아브로에서는 코드생성을 선택적으로 사용한다. 아브로에서는 쓰기 스키마를 포함한 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 간단히 열어 JSON파일을 보는 것 과 같이 데이터를 볼 수 있지만, 메타 데이터를 요구하기 때문에 자기 기술적이다.\n스키마의 장점 요약하자면 장점은 부호화를 통한 데이터 절약과 호환성이다. 많은 데이터 베이스 시스템은 이진 부호화를 독자적으로 구현하기도 한다. 예를 들어 대부분의 관계형 데이터베이스에는 질의를 데이터베이스로 보내고 응답을 받을 수 있는 네트워크 프로토콜이 이따. 이 프로토콜은 일반적으로 특정 데이터베이스에 특화되고 데이터베이스 벤더는 데이터베이스 네트워크 프로토콜로부터 응답을 받아 인메모리 데이터 구조로 복호화 하는 드라이버를 제공한다.(JDBC, ODBC)\n데이터 플로 모드 데이터 플로우는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많다. 누가 데이터를 부호화하고 누가 그것을 복호화 할까? 이번장의 나머지 부분에서는 프로세스간 데이터를 전달하는 가장 보편적인 방법을 살펴본다.\n데이터베이스를 통해 RPC를 통해(서비스 호출을 통해) 비동기 메세지 전달을 통해 ","permalink":"http://localhost:1313/_wiki/4%EC%9E%A5/","summary":"4장 부호화와 발전 어플리케이션의 변경과 변화에 대응하는 방법을 소개하는 장. 일단 먼저 대규모 어플리케이션 변화에 있어 장애물이 되는 부분은 크게 아래와같다.\n데이터타입이나 스키마가 변경되는 경우 서버측에서는 순회식 업그레이드를 진행한다. 클라이언트측 어플리케이션은 사용자에 전적으로 좌우된다. 어떤 사용자는 한동안 업그레이드를 하지 않을 수도 있다. 즉 예전버전의 코드와 새로운 버전의 코드, 이전의 데이터타입과 새로운 데이터타입 이 시스템에 공존 할 수 있다는 것이다. 그래서 시스템에는 양방향의 호환성이 필요하다.\n하위 호환성 : 새로운 코드는 이전 코드가 기록한 데이터를 읽을 수 있어야 한다.","title":"데이저 중심 애플리케이션 4장 스터디"},{"content":"Rust 관련 정보 모음 Docker 이미지 만들기 Compile ","permalink":"http://localhost:1313/_wiki/rust-main/","summary":"Rust 관련 정보 모음 Docker 이미지 만들기 Compile ","title":"Rust 🦀"},{"content":"저장소와 검색 데이터베이스의 가장 중요한 두가지 추상화는 쓰기/읽기이다. 그리고 이 두가지 성능은 항상 Trade-off 관계에 있다. 그 Trade-off 관계를 이해하는 것과, 가장 대표적인 저장소 엔진인 로그구조(Log-Structured) 저장소 엔진과 B-트리 같은 페이지지향(page-oriented) 저장소 엔진을 비교하는 것이 이 장의 목표이다.\n데이터베이스를 강력하게 만드는 데이터 구조 #!/bin/bash db_set () { echo \u0026#34;$1,$2\u0026#34; \u0026gt;\u0026gt; database } db_get () { grep \u0026#34;^$1,\u0026#34; database | sed -e \u0026#34;s/^$1,//\u0026#34; | tail -n 1 // 특정 키에 대한 마지막 값을 가져온다. } 가장 간단한 데이터 베이스의 구조 \u0026gt; db_set \u0026#34;small\u0026#34; \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;helloWorld@helloWorld.com\u0026#34;}\u0026#39; \u0026gt; db set \u0026#34;big\u0026#34; \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;BigzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;helloWorld2@helloWorld.com\u0026#34;}\u0026#39; \u0026gt; db set \u0026#34;small\u0026#34; \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34;}\u0026#39; \u0026gt; cat database \u0026#34;small\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;helloWorld@helloWorld.com\u0026#39;}\u0026#34; \u0026#34;big\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;BigzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;hellowWorld@helloWorld.com\u0026#34;}\u0026#34; \u0026#34;small\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34;}\u0026#34; 언뜻 장난같지만 이 데이터베이스는 실제로 매우 강력하다.\n쓰기 작업은 성능이 특히 뛰어나다. (그냥 파일에 append만 하면 되기 때문)\n읽기 작업은 키를 찾아서 파일을 끝까지 읽어야 하기 때문에 성능이 좋지 않다.(O(n))\n좋은 쓰기 성능 대비 나쁜 읽기성능을 보완하기 위해 다른 데이터 구조를 추가하는데, 바로 Index이다.\n색인은 기본ㄷ 데이터에서 파생된 추가적인 구조다. 많은 데이터베이스는 색인의 추가오 삭제를 허용한다. 이 작업은 데이터베이스의 내용에는 영향을 미치지 않는다. 단지 질의 성능에만 영향을 준다. 특히 쓰기 과정에서의 오버헤드가 발생한다. 쓰는 시점에 인덱스를 갱신하기 때문이다.\n해시 색인\n먼저 키-값 데이터를 색인하는 가장 간단한 방법은 해시 테이블을 사용하는 것이다. 실제로 인메모리에 해시테이블을 사용하는건 굉장히 흔한 방식이고, 비트캐스크(Riak의 엔진)도 이 방식을 사용한다고 한다. (newline은 없고 디스크 상에 일렬로 저장된다고 가정한다.) \u0026#34;small\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;helloWorld@helloWorld.com\u0026#39;}\u0026#34; \u0026#34;big\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;BigzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;hellowWorld@helloWorld.com\u0026#34;}\u0026#34; \u0026#34;small\u0026#34;,\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;SmallzooDev\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34;}\u0026#34; // key : value small : (가장 최근에 추가된 small이 시작되는 위치) big : (가장 최근에 추가된 big이 시작되는 위치) 이렇게 빠르게 조회를 달성하고 나면 위의 구조(모든 추가 데이터를 파일에 append, 해시테이블에 키-값을 저장)는 여러가지 장점을 가진다. 첫 번째로 아직 쓰기 성능이 뛰어나다. (파일에 append만 하면 되기 때문) 두 번째로 해시테이블을 사용하면 키를 찾는데 O(1)의 시간이 걸린다.\n하지만 한가지 문제가 있는데, 바로 디스크의 용량이 결국 부족해진다는 것이다. 위의 예시에서, 계속 append된 데이터를 실제로 데이터베이스에서도 매우 유용하게 사용하며, 이를 database 로그라고 일컫는다. 지금 상황은 로그 자체를 데이터베이스로 사용하고 있는 것이다.\n이 문제를 해결하기 위해 컴팩션이라는 개념이 등장한다. 먼제 세그먼트를 도입해서 로그가 특정 크기에 도달하면 이를 나눠담는다. 그리고 이 세그먼트를 더 작게 만들기 위해서 하는 작업이 컴팩션 이다. 사실 컴팩션 자체는 매우 간단한데, 세그먼트를 읽어서 중복된 키를 제거하고, 가장 최근의 값을 유지하는 것이다. 컴팩션은 다른 쓰레드에서 진행해도 무방하고, 아직도 안전한 append 로그 작업을 계속할 수 있다. (append 로그 방식이 얼마나 안전한지 모르겠다면, 값을 갱신하는 방식으로 db를 구현했을때 갱신중 꺼지는 상황을 떠울리면 된다) 하지만 해시 테이블 역시 제약 사항이 있다.\n메모리에 키를 저장해야 하기 때문에, 키가 매우 많아지면 메모리가 부족해진다. 범의 질의를 지원하지 않는다. ##SS테이블과 LSM트리 먼지 키를 특정 기준으로 정렬한다. 정렬을 위해서 merge-sort를 사용하는데, (세그먼트로 나누어서 정렬하고, 이를 합치는 방식) 메모리보다 파일이 커도 정렬이 가능하다. 이렇게 키로 정렬된 테이블을 SS테이블(sorted string table)이라고 한다. 이렇게 SS테이블을 만들면 해당 테이블을 이용해 범위 질의도 할 수 있고, 모든 키를 메모리에 저장하지 않아도 된다(정렬의 특성상, 없으면 범위를 찾을 수 있기 때문) 여기까지는 괜찮은데 그렇다면 데이터를 정렬하려면 어떻게 해야할까? 일단 이것도 디스크에 정렬을 유지하는것은 쉽지않다. 유입되는 쓰기는 임의 순서로 발생하기 때문이다. (B트리를 이용하면 가능하지만, 이는 다음에 설명) 그래서 메모리에 AVL트리나 레드블랙트리를 사용해서 정렬을 유지한다. 이런 구조들로 임의 순서로 키를 삽입하고, 정렬된 순서로 키를 읽는다. 쓰기가 들어오면 인메모리 균형 트리 데이터구조(레드블랙트리나 AVL트리)에 추가한다. 이걸 멤테이블(memtable)이라고 부른다. 멤테이블이 일정 크기에 도달하면 SS테이블로 변환하고, 디스크에 기록한다. 새로운 SS테이블파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 쓰는동한 새로운 쓰기는 멤테이블 인스턴스에 기록한다. 읽기 요청을 제공하려면 먼저 멤테이블에서 키를 찾아야한다. 그리고 그 다음에는 가장 최신의 SS테이블부터 가장 오래된 SS테이블까지 차례로 검색한다. 가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 작업을 수행한다.(이 작업은 백그라운드에서 수행된다.) (데이터베이스가 고장난경우 쓰기중인 데이터가 날아갈 수 있지만, 로그를 유지하고 있기 때문에 복구가 가능하다.) SS테이블에서 LSM트리 만들기\nLSM트리는 Log-Structured Merge-Tree의 약자로, SS테이블을 이용해서 만들어진다. 이러한 방식은 구글의 빅테이블 논문에서 처음 소개되었다. 루신과 같은 검색엔진에서도 사용되는 방식인데, 용어 사전(term dictionary)을 만들때 사용한다. (검색 질의가 들어오면, 단어가 언급된 모든 문서를 찾는데, 이 접근법을 키를 단어로 값은 단어를 포함한 모든 문서의 포스팅 목록으로하는 키-값구조로 저장하게된다.)\nLSM트리는 블룸필터등을 사용해서 키 존재 여부를 빠르게 확인하며 최적화하고 SS테이블 병합도 크기 계층, 레벨 컴팩션을 통해 최적화한다. ##B트리 지금까지 설명한 로그 구조화 색인이 점점 보편화되고 있지만 가장 일반적인 색인 유형은 아니다. 가장 널리 사용되는 색인 구조는 B트리이다. 알에서 살펴본 로그 구조화 색인은 데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록한다. 반면 B트리는 데이터베이스를 고정 크기의 페이지로 나누고(전통적으로 4KB) 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 수행한다. 디스크가 고정 크기 블록으로 배열되기 때문에 이런 설계는 근분족으로 하드웨어와 조금 더 밀접한 관련이 있다.\n기본적인 b트리로직과 똑같다. 루트 페이지에 여러 키와 하위페이지의 참조를 저장하고, 이어서 두 번째 페이지에도 키와 참조를 저장한다.\n그러다 리프페이지에 도달하면, 값의 참조를 저장한다.\nB트리의 한 페이지에서 하위 페이지를 참조하는 수를 분기계수라고 부른다.\n갱신과 추가는 쉽지만 삭제는 조금 복잡하다.\n삭제시에는 키를 삭제하고, 빈 공간을 채우기 위해 인접한 키를 이동시키거나, 인접한 페이지와 병합하는 작업을 수행한다.\n신뢰 할 수 있는 B트리 구현하기\n로그 구조화 색인과 달리 B트리는 쓰기작업시 데이터를 디스크상의 페이지에 덮어쓴다. 이 동작이 덮어쓰기가 페이지 위치를 변경하지 않는다고 가정한다. 즉 페이지를 덮어써도 참조는 온전히 남는다. 이런 이유로 동시성 제어가 필요하고, 트랜잭션 로그를 사용해서 데이터베이스를 복구할 수 있어야 한다. B트리는 여러가지 최적화 기법이 있다.\n페이지 덮어쓰기와 WAL유지 대신 변경된 페이지는 다른위치에 기록하고, 변경된 페이지를 가리키는 로그를 유지한다. 전체키를 쓰는게 아니라, 키의 일부만 쓰는 방식을 사용한다. 디스크에 순서대로 저장할 제약을 두지 않는다. 여기저기 포인터로 최적화(리프노드에 양쪽 페이지의 포인터를 저장하는 방식)를 사용한다. 기타 색인 구조 키-값 색인에 대해서 살펴봤고, 번역이 이상한지 해당 인덱스를 사용하는 사용예시를 보여준다.\n다중 칼럼 색인\nSELECT * FROM restaurans WHERE latitute BETWEEN 37.0 AND 37.1 AND longitude BETWEEN -122.0 AND -121.9; 위와 같은 쿼리가 있을 때 지금까지 언급된 인덱스는 효율적으로 응답 할 수 없다. 이런 경우 2차원 채움 곡선과 같이 단일 숫자로 변환하는 방법이 있다고 한다. 그외에 R트리 색인 같은게 있고 postgresql에서는 구현되어있다고 하는데 설명은 없다. ","permalink":"http://localhost:1313/_wiki/3%EC%9E%A5/","summary":"저장소와 검색 데이터베이스의 가장 중요한 두가지 추상화는 쓰기/읽기이다. 그리고 이 두가지 성능은 항상 Trade-off 관계에 있다. 그 Trade-off 관계를 이해하는 것과, 가장 대표적인 저장소 엔진인 로그구조(Log-Structured) 저장소 엔진과 B-트리 같은 페이지지향(page-oriented) 저장소 엔진을 비교하는 것이 이 장의 목표이다.\n데이터베이스를 강력하게 만드는 데이터 구조 #!/bin/bash db_set () { echo \u0026#34;$1,$2\u0026#34; \u0026gt;\u0026gt; database } db_get () { grep \u0026#34;^$1,\u0026#34; database | sed -e \u0026#34;s/^$1,//\u0026#34; | tail -n 1 // 특정 키에 대한 마지막 값을 가져온다.","title":"데이터 중심 애플리케이션 설계 스터디3장"},{"content":"13.0.0 Functional Languages Features: Iterators and Closures Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth. In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.\n요약하자면 러스트의 디자인과 기능은 함수형 프로그래밍에서도 영감을 받았다. 하지만 뭐가 함수형인지 논의하는것보다는 많은 언어들에서 함수형 언어로 일컫어지는 기능들이 러스트에서 어떻게 사용할 수 있는지 알아본다고 한다.\n구체적으로는\nClosures : 안에 변수를 캡쳐할 수 있는 function-like construct Iterators : series of elements를 처리하는 방법들 위 두가지의 성능 에 대해서 알아본다. 13.1 Closures: Anonymous Functions that Can Capture Their Environment 러스트의 클로져는 변수를 저장하거나, 다른 함수에 아규먼트로 넘길 수 있는 익명 함수이다. 특점 시점에 클로저를 생성하고, 다른 어딘가 다른 컨택스트에서 실행할 수 있다. 다만 일반 함수들과는 다르게 그들이 정의된 시점과 스코프의 값을 캡쳐할 수 있다.\n13.1.1 Captureing the Environment with Closures Scenario : 티셔츠 회사에서는 프로모션으로 메일링 리스트에 등록된 사람에게 한정판 티셔츠를 무료로 증정한다. 메일링 리스트에 등록된 사람들은 선택적으로 프로필에 자신의 좋아하는 색상을 추가할 수 있다. 만약 무료 티셔츠를 받게 된 사람이 좋아하는 색상을 설정해 놓았다면, 그 색상으로 티셔츠를 받는다. 만약 좋아하는 색상을 지정하지 않았다면, 회사에서 현재 가장 많이 보유하고 있는 색상의 티셔츠를 받게 된다.\n#[derive(Debug, PartialEq, Copy, Clone)] enum ShirtColor { Red, Blue, } struct Inventory { shirts: Vec\u0026lt;ShirtColor\u0026gt;, } impl Inventory { fn giveaway(\u0026amp;self, user_preference: Option\u0026lt;ShirtColor\u0026gt;) -\u0026gt; ShirtColor { user_preference.unwrap_or_else(|| self.most_stocked()) } fn most_stocked(\u0026amp;self) -\u0026gt; ShirtColor { let mut num_red = 0; let mut num_blue = 0; for color in \u0026amp;self.shirts { match color { ShirtColor::Red =\u0026gt; num_red += 1, ShirtColor::Blue =\u0026gt; num_blue += 1, } } if num_red \u0026gt; num_blue { ShirtColor::Red } else { ShirtColor::Blue } } } fn main() { let store = Inventory { shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue], }; let user_pref1 = Some(ShirtColor::Red); let giveaway1 = store.giveaway(user_pref1); println!( \u0026#34;The user with preference {:?} gets {:?}\u0026#34;, user_pref1, giveaway1 ); let user_pref2 = None; let giveaway2 = store.giveaway(user_pref2); println!( \u0026#34;The user with preference {:?} gets {:?}\u0026#34;, user_pref2, giveaway2 ); } user_preference.unwrap_or_else(|| self.most_stocked()) : 여기서 클로저가 사용되었다. 먼저 Option\u0026lt;T\u0026gt;의 unwrap_or_else 메소드는 Option\u0026lt;T\u0026gt;가 Some이면 T를 반환하고, None이면 클로저를 실행한다. impl\u0026lt;T\u0026gt; Option\u0026lt;T\u0026gt; { pub fn unwrap_or_else\u0026lt;F\u0026gt;(self, f: F) -\u0026gt; T where F: FnOnce() -\u0026gt; T, // 이때 F는 T를 반환하는 클로저 타입, 이외에도 FnMut, Fn 트레이트도 있다. { match self { Some(value) =\u0026gt; value, None =\u0026gt; f(), // None이면 클로저 f를 실행해 그 결과를 반환 } } } || self.most_stocked() : 즉 여기서는 ||로 시작하고, self.most_stocked()를 본문으로 가지는 클로저를 넘긴 것이다. 결과값이 필요해진 경우 (unwrap_or_else가 호출되는 경우) 클로저가 실행되어 most_stocked 메소드를 호출한다. 이 부분이 헷갈리는 이유는 함수로도 구현할 수 있어보이기 때문인데 (함수를 파라미터로 넘기면), 사실 가장중요한건 외부 환경(여기서는 self)을 캡처할 수 있다는 것이다. 즉, 클로저는 self를 따로 매개변수로 넘기지 않아도 내부에서 접근할 수 있다. 반례 (함수 포인터를 넘기는 경우)를 생각하려 한다면, Option\u0026lt;T\u0026gt;의 unwrap_or_else 메소드가 Inventory, ShirtColor 타입을 알아야 한다.. 함수 포인터를 넘기는 경우 필요한 데이터를 명시적으로 매개변수로 전달해야 하거나 별도로 래핑을 해서 전달해야 한다.\n13.1.2 Closure Type Inference and Annotation 클로저는 대부분의 상황에서 타입을 명시적으로 지정할 필요가 없다. 반면 함수는 하나의 인터페이스 노출되기 때문에 명시적으로 (모두가 동의하는) 타입을 지정해야 한다. 클로저는 노출된 인터페이스처럼 사용되지 않기 때문에 그렇다. 당연히 컴파일러의 타입추론에 의존하고, 꼭 필요한 경우에 타입을 명시적으로 지정하기도 한다.\nfn add_one_v1 (x: u32) -\u0026gt; u32 { x + 1 } let add_one_v2 = |x: u32| -\u0026gt; u32 { x + 1 }; let add_one_v3 = |x| { x + 1 }; let add_one_v4 = |x| x + 1 ; 넷 다 가능하고, 타입을 지정하지 않으면 평가시점에 타입을 추론한다. let example_closure = |x| x; let s = example_closure(String::from(\u0026#34;hello\u0026#34;)); let n = example_closure(5); $ cargo run Compiling closure-example v0.1.0 (file:///projects/closure-example) error[E0308]: mismatched types --\u0026gt; src/main.rs:5:29 | 5 | let n = example_closure(5); | --------------- ^- help: try using a conversion method: `.to_string()` | | | | | expected struct `String`, found integer | arguments to this function are incorrect | note: closure parameter defined here --\u0026gt; src/main.rs:2:28 | 2 | let example_closure = |x| x; | ^ For more information about this error, try `rustc --explain E0308`. error: could not compile `closure-example` due to previous error example_closure는 처음 평가시 String을 받았기 때문에 String으로 타입이 결정되었다. 클로저의 소유권은 함수와 대응된다(동일하다) fn main() { let list = vec![1, 2, 3]; println!(\u0026#34;Before defining closure: {:?}\u0026#34;, list); let only_borrows = || println!(\u0026#34;From closure: {:?}\u0026#34;, list); println!(\u0026#34;Before calling closure: {:?}\u0026#34;, list); only_borrows(); println!(\u0026#34;After calling closure: {:?}\u0026#34;, list); } 위의 경우 불변 참조를 사용했기 때문에 컴파일이 된다. fn main() { let mut list = vec![1, 2, 3]; println!(\u0026#34;Before defining closure: {:?}\u0026#34;, list); let mut borrows_mutably = || list.push(7); // println!(\u0026#34;Before calling closure: {:?}\u0026#34;, list); borrows_mutably(); println!(\u0026#34;After calling closure: {:?}\u0026#34;, list); } 위의 경우 가변 참조를 이용해서 벡터를 수장 할 수 있다. 만약 주석을 해제하면 컴파일 에러가 발생한다. 만약 소유권 이전을 하고 싶다면 move 키워드를 사용한다. use std::thread; fn main() { let list = vec![1, 2, 3]; println!(\u0026#34;Before defining closure: {:?}\u0026#34;, list); thread::spawn(move || println!(\u0026#34;From thread: {:?}\u0026#34;, list)) .join() .unwrap(); } move 키워드를 사용하면 클로저는 소유권을 이전받는다. 이 예제는 새로운 쓰레드에서 클로저를 실행하는데 클로저 본문이 immutable 참조만 필요하기에 기본적으로는 immutable 참조를 사용한다. 그런데 소유권은 아직 메인 쓰레드에 있기 때문에 불변참조가 유지되는동안 list가 drop될 가능성이 있다. 그래서 move 키워드를 사용해서 소유권을 이전하도록 강제되어있다. 13.1.3 Moving Captured Values Out of Closures and the Fn Traits 클로저가 외부 환경으로부터 변수를 캡처하는 방식은 Rust에서 Fn, FnMut, FnOnce 트레이트에 영향을 준다.\n클로저는 외부 환경에서 변수를 캡처할 수 있으며, 이를 처리하는 방식은 크게 세 가지로 나뉜다:\n값을 클로저 내부로 이동시키기: 외부 변수의 소유권을 가져오는 경우. 값을 변경하기: 외부 변수의 값을 변경할 수 있는 경우. 값을 읽기만 하기: 외부 변수의 값을 읽기만 하고, 변경하지 않는 경우. Rust에서는 클로저가 외부 변수를 어떻게 캡처하느냐에 따라 Fn, FnMut, FnOnce 트레이트 중 하나가 자동으로 구현된다.\nFnOnce: 클로저가 외부 변수의 소유권을 가져가면 한 번만 호출될 수 있다.\nFnMut: 클로저가 외부 변수의 값을 변경할 수 있는 경우, 여러 번 호출 가능하다.\nFn: 외부 변수를 읽기만 할 때는 여러 번 호출 가능하다.\nfn consume_with_fn_once\u0026lt;F\u0026gt;(f: F) where F: FnOnce(), { f(); // 한 번만 호출 가능 } fn main() { let name = String::from(\u0026#34;Rust\u0026#34;); let introduce = || { // name의 소유권을 가져가서 이동시킴 println!(\u0026#34;Hello, {}!\u0026#34;, name); }; consume_with_fn_once(introduce); // OK // introduce(); // 에러 발생! introduce는 이미 소유권을 이동시켜 한 번만 호출 가능 } 클로저가 외부 변수의 소유권을 가져가기 때문에, FnOnce 트레이트가 적용된다. 소유권이 이동되었으므로 클로저는 한 번만 호출 가능하다.\nfn consume_with_fn_mut\u0026lt;F\u0026gt;(mut f: F) where F: FnMut(), { f(); // 여러 번 호출 가능 f(); } fn main() { let mut count = 0; let mut increment = || { count += 1; // 외부 변수 count를 변경 println!(\u0026#34;Count: {}\u0026#34;, count); }; consume_with_fn_mut(increment); // OK } 클로저가 외부 변수를 가변 참조로 캡처하여 값을 변경하므로 FnMut 트레이트가 적용된다. 클로저는 여러 번 호출 가능하다.\nfn consume_with_fn\u0026lt;F\u0026gt;(f: F) where F: Fn(), { f(); // 여러 번 호출 가능 f(); } fn main() { let greeting = String::from(\u0026#34;Hello\u0026#34;); let say_hello = || { println!(\u0026#34;{}\u0026#34;, greeting); // greeting을 읽기만 함 }; consume_with_fn(say_hello); // OK } 클로저가 외부 변수를 읽기만 하므로 Fn 트레이트가 적용된다. 변수를 변경하지 않기 때문에 여러 번 호출이 가능하다.\n클로저가 외부 변수를 어떻게 캡처하느냐에 따라 Rust는 자동으로 Fn, FnMut, FnOnce 트레이트를 구현한다.\nFnOnce: 클로저가 외부 변수의 소유권을 가져갈 때. FnMut: 클로저가 외부 변수를 변경할 때. Fn: 클로저가 외부 변수를 읽기만 할 때. 이러한 방식으로 Rust는 클로저가 외부 변수와 어떻게 상호작용하는지에 따라 자동으로 적절한 트레이트를 적용해준다.\n","permalink":"http://localhost:1313/_wiki/funcional-langauges-features/","summary":"13.0.0 Functional Languages Features: Iterators and Closures Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth. In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.","title":"러스트의 함수영 언어 특징"},{"content":"공통 종작은 타입 시스템으로 표현하라 ","permalink":"http://localhost:1313/_wiki/item-2/","summary":"공통 종작은 타입 시스템으로 표현하라 ","title":"Effective Rust Item 2  공통 종작은 타입 시스템으로 표현하라"},{"content":"데이터 구조를 타입 시스템으로 표현하라 복잡한 데이터 구조를 구성하는 방법을 배운다. 이 과정에서 enum은 핵심적인 역할을 한다. 러스트의 enum은 기본적으로 다른 언어와 같지만, 배리언트에 직접 데이터 필드를 넣을 수 있다는 점에서 다른 언어보다 훨씬 유연하고 표현력이 높다.\n기본 타입\ni8 i16 i32 i64 i128 : 부호 있는 정수 u8 u16 u32 u64 u128 : 부호 없는 정수 isize usize : 시스템 아키텍처에 따라 크키가 변하는 정수, 포인터와 인덱스 연산에 사용 f32 f64 : 부동 소수점 bool : 참/거짓 char : 유니코드 문자 () : 유닛타입, c언어의 void와 비슷한 역할\n특징적일것은 없지만 컴파일러가 조금 더 빡빡하게 체크해준다. let x: i32 = 42; let y: i16 = x; // error[E0308]: mismatched types, let y: i16 = x.try_into().unwrap(); let x = 42i32; let y: i64 = x; // error[E0308]: mismatched types, let y: i64 = x.try_into(); ** 묶음 타입 (arggregates) **\n튜플 : 고정된 크기의 묶음, 각 요소의 타입은 다를 수 있다. 배열 : 고정된 크기의 묶음, 모든 요소의 타입은 같아야 한다. 구조체 : 이름이 붙은 필드를 가지는 묶음, 각 필드의 타입은 다를 수 있다. 튜플 구조체 : 이름이 붙지 않은 필드를 가지는 묶음, 각 필드의 타입은 다를 수 있다. // 튜플 구조체 struct TextMatch(usize, String); let m = TextMatch(42, \u0026#34;hello\u0026#34;.to_string()); assert_eq!(m.0, 42); ** 열거 타입 (enum) **\n기본적으로는 상호 배타적인 값들의 집합을 나타낸다. enum Direction { Up = \u0026#39;h\u0026#39;, Down = \u0026#39;j\u0026#39;, Left = \u0026#39;k\u0026#39;, Right = \u0026#39;l\u0026#39;, } assert_eq!(Direction::Up as char, \u0026#39;h\u0026#39;); 단순히 bool타입을 사용하는 것보다는 열거 타입을 사용하는 것이 더 가독성이 좋고, 유지보수하기 쉽다.\npub fn print_page(is_both_side: bool, is_color: bool) { /* ... */ } // this better pub fn print_page(side: Sides, color: Color) { /* ... */ } pub enum Sides { Both, One, } pub enum Color { Color, BlackAndWhite, } 사실 더 나은 방법은 뉴타입 패턴을 이용해 래핑하는 것이지만, 많약 옵션이 추가될 여지가 있다면 위처럼 열거 타입을 사용하는 것이 좋다.\nenum의 타입안정성은 mathch표현식을 통해 보장 할 수 있다. let direction = match input { \u0026#39;h\u0026#39; =\u0026gt; Direction::Up, \u0026#39;j\u0026#39; =\u0026gt; Direction::Down, \u0026#39;k\u0026#39; =\u0026gt; Direction::Left, }; // error[E0004]: non-exhaustive patterns 모든 variant를 다루지 않으면 컴파일러가 에러를 발생시킨다. 물론 \u0026lsquo;_\u0026lsquo;를 사용해 모든 variant를 다루지 않도록 할 수 있긴 하지만, 그렇게 하면 새로운 variant가 추가되었을 때 컴파일러가 알려주지 않기 때문에 조심해서 사용해야 한다.\n필드가 있는 enum\nC/C++에서 enum과 union을 조합한것에 타입 안정성이 보장되는 것을 그냥 enum으로 표현할 수 있다. 즉, 프로그램 데이터 구조의 불변성을 러스트의 타입 시스템으로 인코딩할 수 있으며, 이러한 불현성을 어기면 컴파일이 되지 않는다.\nc언어와 union을 사용한 예제 enum State { INT, FLOAT }; union Value { int i; float f; }; struct Data { enum State state; union Value value; }; void print_value(struct Data* data) { if (data-\u0026gt;state == FLOAT) { printf(\u0026#34;%f\\n\u0026#34;, data-\u0026gt;value.f); } } 러스트의 enum의 기능을 활용한 예제 enum Value { Int(i32), Float(f32), } fn print_value(value: Value) { match value { Value::Int(i) =\u0026gt; println!(\u0026#34;{}\u0026#34;, i), Value::Float(f) =\u0026gt; println!(\u0026#34;{}\u0026#34;, f), } } 그리고, 작성자의 의도가 컴파일러뿐만 아니라 사람에게도 명확하게 드러나는 enum이야 말로 제대로 설계된 enum이라 할 수 있다. 이런식의 (아래의 예시처럼) 구성이야 말로 바로 이번 아이템의 핵심 주제인 \u0026lsquo;러스트는 어떻게 타입 시스템을 통해 프로그램 컨셉을 디자인하는가\u0026rsquo;를 보여주는 좋은 예시라 할 수 있다.\nuse std::collections::{HashMap, HashSet}; pub enum SchedulerState { Insirt, Pending(HashSet\u0026lt;Job\u0026gt;), Running(HashMap\u0026lt;Job, Worker\u0026gt;), } 유효하지 못한 상태가 타입에 표현 될 수 없도록 설계를 제대로 해야한다. 필드나 매개변수의 유효성 조건에 대한 주석이 달린다면, 개념을 타입 시스팀에 제대로 표현하지 못했다는 뜻이다.\npub struct Car { pub is_parked: bool, // 주차 중이면 speed는 반드시 0이어야 한다. pub speed: u32, } pub enum CarState { Parked, Driving(u32), } pub struct Car { pub state: CarState, } 흔히 사용하는 enum 타입\nOption\u0026lt;T\u0026gt; : 값이 있을 수도 있고 없을 수도 있는 타입\nSome(T) : 값이 있는 경우 None : 값이 없는 경우 컬렉션과 관련해서는 조금 더 생각해볼 부분이 있다. (Vec\u0026lt;Thing\u0026gt; vs Option\u0026lt;Vec\u0026lt;Thing\u0026gt;\u0026gt;) 값이 없는 스트링에서는 \u0026ldquo;\u0026ldquo;와 None중에 어떠한것이 좋을지에 대해서는 Option이 좋다. Result\u0026lt;T, E\u0026gt; : 성공할 수도 있고 실패할 수도 있는 타입\nOk(T) : 성공한 경우 Err(E) : 실패한 경우 실패할 수 있는 모든 연산에 사용해야 한다. ? 연산자를 사용하면 에러를 반환하고, 함수의 반환 타입이 Result인 경우에는 자동으로 에러를 반환한다. fn read_file_basic() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut file = match File::open(\u0026#34;test.txt\u0026#34;) { Ok(file) =\u0026gt; file, Err(e) =\u0026gt; return Err(e), }; let mut contents = String::new(); match file.read_to_string(\u0026amp;mut contents) { Ok(_) =\u0026gt; Ok(contents), Err(e) =\u0026gt; Err(e), } } fn main() { match read_file_basic() { Ok(contents) =\u0026gt; println!(\u0026#34;File contents: {}\u0026#34;, contents), Err(e) =\u0026gt; eprintln!(\u0026#34;Error reading file: {}\u0026#34;, e), } } fn read_file_chain() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut contents = String::new(); File::open(\u0026#34;test.txt\u0026#34;)?.read_to_string(\u0026amp;mut contents)?; Ok(contents) } fn main() { match read_file_chain() { Ok(contents) =\u0026gt; println!(\u0026#34;File contents: {}\u0026#34;, contents), Err(e) =\u0026gt; eprintln!(\u0026#34;Error reading file: {}\u0026#34;, e), } } ","permalink":"http://localhost:1313/_wiki/item-1/","summary":"데이터 구조를 타입 시스템으로 표현하라 복잡한 데이터 구조를 구성하는 방법을 배운다. 이 과정에서 enum은 핵심적인 역할을 한다. 러스트의 enum은 기본적으로 다른 언어와 같지만, 배리언트에 직접 데이터 필드를 넣을 수 있다는 점에서 다른 언어보다 훨씬 유연하고 표현력이 높다.\n기본 타입\ni8 i16 i32 i64 i128 : 부호 있는 정수 u8 u16 u32 u64 u128 : 부호 없는 정수 isize usize : 시스템 아키텍처에 따라 크키가 변하는 정수, 포인터와 인덱스 연산에 사용 f32 f64 : 부동 소수점 bool : 참/거짓 char : 유니코드 문자 () : 유닛타입, c언어의 void와 비슷한 역할","title":"Effective Rust Item 1  데이터 구조를 타입 시스템으로 표현하라"},{"content":"Effective Rust 🦀 Effective Rust를 읽고 기억할만한 내용을 정리하는 문서입니다.\nChapter 1 : Type [[Item-1]] : 데이터 구조를 타입 시스템으로 표현하라 [[Item-2]] : 공통 동작은 타입 시스템으로 표현하라 ","permalink":"http://localhost:1313/_wiki/effective-rust/","summary":"Effective Rust 🦀 Effective Rust를 읽고 기억할만한 내용을 정리하는 문서입니다.\nChapter 1 : Type [[Item-1]] : 데이터 구조를 타입 시스템으로 표현하라 [[Item-2]] : 공통 동작은 타입 시스템으로 표현하라 ","title":"Effective Rust 🦀"},{"content":" 데이터 모델은 아마도 소프트웨어 개발에서 제일 중요한 부분일 것이다. 왜냐하면 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라, 문제를 어떻게 생각해야 하는지에 지대한 영향을 미치기 때문이다.\n대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 것이다. 참고로 레이어 패턴은 하나의 레이어가 직전 레이어의 성립을 전제로 존재하고, 그러한 레이어들로 이루어진 구조를 말한다.\n무튼 이번 장에서는 아래와 같은 것들을 살펴본다.\n다양한 범용 데이터 모델들에 대한 소개 다양한 질의 언어와 사용 사례 관계형 모델과 문서 모델 관계형 모델과 문서 모델, 그리고 아주 약간의 그래프 모델에 대해 그리고 이들의 역사에 대해 살펴본다.\n가장 중요하게 생각한건 어떠한 요구를 처리하다가 어떠한 db가 우위를 점했는지에 대한 내용이다.\n관계형 모델\n관계형 모델은 1970년대에 제안된 모델로, 상당 기간 우위를 점했다. 테이블과 관계를 튜플로 표현한 데이터의 모음으로 관리한다. 트랜잭션 처리와 일괄 처리에 대한 지원을 강점으로 내세워 우위를 점했다. NoSQL\nNoSQL은 관계형 모델의 우위를 뒤집기 위한 가장 최근의 시도이다. 처음에는 커뮤니티 밋업을 위한 해쉬태그였지만 점점 용어가 확산되어 Not Only SQL로 재해석됐다. 주로 아래와 같은 이유로 사용된다. 대규모 데이터 셋이나 매우 높은 쓰기 처리량을 필요로 하는 경우 오픈소스 소프트웨어를 사용하고자 하는 경우 동적이고 표현력이 풍부한 모델에 대한 바램 객체 관계 불일치\n객체 관계 불일치는 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 불일치를 의미한다. 요즘은 가장 대중적으로 객체지향 프로그래밍 언어를 사용하는데, 이로 인해 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 불일치가 발생한다. 이런 모델 사이의 불일치를 임피던스 불일치라고 한다. 아래의 예시 json 데이터는 객체 지향 프로그램의 데이터 모델과 아주 유사하다.\n{ \u0026#34;profile\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;headline\u0026#34;: \u0026#34;Software Engineer at TechCorp\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;California\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;United States\u0026#34; }, \u0026#34;summary\u0026#34;: \u0026#34;Experienced software engineer with a passion for developing scalable web applications and working across the full stack.\u0026#34;, \u0026#34;profilePictureUrl\u0026#34;: \u0026#34;https://example.com/profile/johndoe.jpg\u0026#34;, \u0026#34;contactInfo\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;john.doe@example.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;+1-123-456-7890\u0026#34;, \u0026#34;linkedinUrl\u0026#34;: \u0026#34;https://www.linkedin.com/in/johndoe\u0026#34; } }, \u0026#34;experience\u0026#34;: [ { \u0026#34;title\u0026#34;: \u0026#34;Senior Software Engineer\u0026#34;, \u0026#34;company\u0026#34;: \u0026#34;TechCorp\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;San Francisco, CA\u0026#34;, \u0026#34;startDate\u0026#34;: \u0026#34;2019-06\u0026#34;, \u0026#34;endDate\u0026#34;: \u0026#34;Present\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Leading the development of microservices architecture and improving CI/CD pipelines.\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Software Engineer\u0026#34;, \u0026#34;company\u0026#34;: \u0026#34;Web Solutions Inc.\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;New York, NY\u0026#34;, \u0026#34;startDate\u0026#34;: \u0026#34;2016-01\u0026#34;, \u0026#34;endDate\u0026#34;: \u0026#34;2019-05\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Developed web applications using modern JavaScript frameworks.\u0026#34; } ], \u0026#34;education\u0026#34;: [ { \u0026#34;school\u0026#34;: \u0026#34;University of California, Berkeley\u0026#34;, \u0026#34;degree\u0026#34;: \u0026#34;Bachelor of Science\u0026#34;, \u0026#34;fieldOfStudy\u0026#34;: \u0026#34;Computer Science\u0026#34;, \u0026#34;startDate\u0026#34;: \u0026#34;2012-09\u0026#34;, \u0026#34;endDate\u0026#34;: \u0026#34;2016-05\u0026#34; } ], \u0026#34;skills\u0026#34;: [ \u0026#34;JavaScript\u0026#34;, \u0026#34;React\u0026#34;, \u0026#34;Node.js\u0026#34;, \u0026#34;Microservices\u0026#34;, \u0026#34;Docker\u0026#34; ], \u0026#34;certifications\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;AWS Certified Solutions Architect\u0026#34;, \u0026#34;authority\u0026#34;: \u0026#34;Amazon Web Services\u0026#34;, \u0026#34;issueDate\u0026#34;: \u0026#34;2021-03\u0026#34;, \u0026#34;expirationDate\u0026#34;: \u0026#34;2024-03\u0026#34; } ], \u0026#34;recommendations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Jane Smith\u0026#34;, \u0026#34;relationship\u0026#34;: \u0026#34;Former Manager\u0026#34;, \u0026#34;recommendationText\u0026#34;: \u0026#34;John is an outstanding software engineer with exceptional leadership skills.\u0026#34; } ] } 그러나 이런 데이터를 관계형 데이터베이스에 저장하려면, 객체를 테이블로 변환해야 한다. 이러인해 많은 테이블, 스키마 들이 생기게 되고 이로 인해 지역성(locality)이 떨어지게 된다. 예를들어 profile, experience 등의 테이블이 생겨나게 되고 조회를 위해서 매번 조인해야 한다. 물론 이렇게 저장하고 관리하는게 모든 면에서 훌륭하지는 않다. 다대일이나 다대다 관계를 표현하는 부분에서는 관계형 데이터베이스가 더 효율적이다. id를 통해 참조하는 방식은 모호함을 회피하는데 좋다. (이름 같은 다른 도시가 있을 경우) 갱신을 위한 비용이 적다. 역조건으로 검색하는 경우 인덱스와 조인을 통해 빠르게 검색할 수 있다. 관계형 데이터베이스와 오늘날의 문서 데이터베이스 바로 위에 다뤘던 내용과 관련된 내용이다. 요약하면 문서 데이터 모델은 스키마 유연성, 지역성이 높고 그부분에 대한 성능으로 어필하고 관계형 데이터베이스는 다대일, 다대다 관계를 표현하는데 효율적이다.\n그래도 일반적으로는 관계형 데이터베이스가 \u0026lsquo;최근\u0026rsquo; 어플리케이션들의 코드를 복잡하게 만드는 경향이 있다 기본적으로 매번 데이터를 조인해야 어플리케이션 모델을 생성 할 수 있기 때문이다. 책도 이부분에 대한 내용에 어느 정도 동의를 하고 있다. 물론 ORM들이 아마도 최근에 더 활발하게 사용되고 있는 부분을 고려해야 할 수 있기는 한 것 같다.\n반대로 문서형 데이터베이스 모델들은 상대적으로 rdb보다 코드를 간단하게 만들어 주는 것은 사실인 것 같다. 그러나 이러한 모델들은 다대일, 다대다 관계를 표현하는데 비효율적이다. 비정규화된 데이터로 중북을 감수해야 하고 데이터 일관성을 위한 추가적인 코드 작업이 필요하다. 추가적으로 문서모델은 스키마유연성이 높다. 그렇다고 schemaless하다고 표현하기에는 오해의 소지가 있을 수 있다. \u0026lsquo;읽는\u0026rsquo; 작업에서는 그래도 어느정도의 스키마를 가정한다. (암묵적으로) 그러나 \u0026lsquo;쓰는\u0026rsquo; 작업에서는 스키마가 유연하다. (쓰기 스키마를 가진다고 표현했다.) 마지막으로 지역성에 대한 고려는 조회 한번에 거의 모든 데이터를 사용하는 경우는 지역성이 높은 모델이 훨씬 더 효율적이다. 데이터베이스 질의 선언형 질의와 명령형 질의, 그리고 맵리듀스 질의에 대한 내용이 나온다. 선언형 질의와 명령형 질의에 대한 내용이 이해가 잘 되지 않아서 좀 더 공부가 필요할 것 같다. (선언형 질의와 명령형 질의에 대한 내용 추후 작성 예정)\n맵리듀스 질의\n함수형 프로그래밍에서 나온 아이디어이며 함수형 프로그래밍의 맵, 리듀스를 알아야 한다.\n함수형 프로그래밍에서 map은 컬렉션의 각 요소에 동일한 함수를 적용하여 새로운 컬렉션을 생성하는 함수이다. 각 요소가 독립적으로 처리되기 때문에 병렬 처리에도 용의하다. reduce는 컬렉션의 모든 요소를 하나의 값으로 결합하는 함수이다. 여러개의 값을 결합해서 최종 결과를 도출한다. ","permalink":"http://localhost:1313/_wiki/2%EC%9E%A5/","summary":"데이터 모델은 아마도 소프트웨어 개발에서 제일 중요한 부분일 것이다. 왜냐하면 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라, 문제를 어떻게 생각해야 하는지에 지대한 영향을 미치기 때문이다.\n대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 것이다. 참고로 레이어 패턴은 하나의 레이어가 직전 레이어의 성립을 전제로 존재하고, 그러한 레이어들로 이루어진 구조를 말한다.\n무튼 이번 장에서는 아래와 같은 것들을 살펴본다.","title":"데이터 모델과 질의 언어 📚"},{"content":"블로그를 유지보수하며 블로그를 유지보수(?)하면서 참 css도 css인데 글을 너무 두서없이 쓰기도 하고, 레이아웃도 너무 두서없이 바꾸기도 하고, 무튼 참 난잡하다는 생각이 들었다. 그래서 약간 스스로와의 약속처럼 가이드라인을 작성해보려고 한다. 글 작성 관련 h1과 타이틀 둘 다 나오면 뭔가 헤딩이 너무 많아 보여서 별로라서 지나치게 아랫 번호의 헤딩을 쓰는 습관 고치기.(h2로 글을 잘 나눠 쓴다를 전제로 해야겠다.) 백틱과 코드블럭을 너무 많이 쓴다. 꼭 필요한 경우에만 써야겠다. hr 라인을 h2마다 붙이자 \u0026ldquo;내가 다시 볼 만 한 글을 쓰기\u0026rdquo; vs \u0026ldquo;읽거나 공부하는데 정리하느라 너무 많은 시간을 쏟지 않기\u0026rdquo; 중에서 중심잡기가 어렵다. 글 내용 관련 목적이 분명한 글쓰기를 해야겠다. 모르는 부분에 대해서 뭉게는 습관을 고치자. (모르면 모른다고 모르는대로 쓰기) 그냥 다시 볼 사람은 나밖에 없는데, 이해가 안된부분을 제대로 명시하지 않거나, 내가 이걸 모르고 있었다거나 하는 부분을 괜히 공개하는 것 같아서 뭉개는 습관을 고치자. 내가 다시 볼 때 보기 좋은 글을 쓰자. (이 블로그의 목적은 개인 아카이브용이다.) ","permalink":"http://localhost:1313/_wiki/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8/","summary":"사실 그냥 나 혼자 지켜야 할 가이드라인 🤔","title":"블로그 작성 가이드라인(지속적으로 보충할 문서!) 📝"},{"content":"데이터 중심 애플리케이션 설계 1장 00 머리말 환경에 대한 이야기를 한다. 머리말에서는 최근 사업적으로는 클라우드와 saas 환경, 하드웨어 적으로는 cpu클럭이 더이상 오르지 않고 멀티코어가 표준이 된 환경을 이야기하며 병렬 처리에 대한 환경을 강조한다. 위의 예시를 데이터 중심적 이라고 정의하며 반대로 cpu사이클이 병목인경우를 계산 중심적이라고 정의한다 이 책은 (\u0026hellip;) 데이터 시스템의 기초가 되는 다양한 원리와 트레이드오프에 대해 논의한다. 데이터 시스템 아키텍처와 데이터 중심 애플리케이션으로 데이터 시스템을 통합하는 방법을 주로 다룬다.\n이 책의 개요\n이책은 크게 3부로 구성되어 있다.\n1부에서는 데이터 중심 애플리케이션 설계를 뒷받침하는 금본 개념을 설명한다. 2부에서는 여러 장비에 데이터를 분산하여 저장하는 부분을 설명하다. 3부에서는 특정 데이터셋에서 다른 데이터셋을 파생하는 시스템을 설명한다. 01 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션 오늘날 많은 어플리케이션은 계선중심적이 아니라 데이터 중심적이라서, 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도 등이 주요 해결해야할 이슈이다.\n데이터 시스템이 어플리케이션의 요구에 따라 제공해야할 핵심 기능은 아래와 같이 추상화 되어 있다.\nDatabase Cache Seach Index Stream processing Batch processing 데이터 시스템에 대한 생각 일반적으로 db와 큐, 캐시와 같은 것들은 다른 범주에 속하는 단일 도구들로 생각한다. 하지만 표면적으로 비슷하더라도 각각은 매우 다른 접근 패턴을 가지고 있고, 최근에 만들어졌는데 심지어 특정한 유즈케이스에 특화된 컴포넌트들이기 때문에 전통적인 데이터 시스템 분류로 접근하면 안된다. 그리고 점점 더 많은 애플리케이션들이 단일도구로는 핸들링 할 수 없는 복잡한 요구사항을 가지고 있다. 요구사항을 태스크로 나누고 해당 태스크들에 위에 설명한 각각의 단일 도구들에 맡기고 전체적인 실행 흐름을 애플리케이션 코드로 제어한다. 그래서 위의 각각의 단일 도구들을 애플리케이션 코드로 제어하는 개발자는 데이터 시스템 설계자이기도 하며, 각각의 단일 도구들 역시 데이터 시스템으로 봐야 한다.\n그리고, 이러한 데이터시스템의 가장 주요한 관심사는 세가지로 분류된다.\n신뢰성 (Reliability) 하드웨어나 소프트웨어 결함, 심지어 인적오류같은 역경에 직면하더라도, 시스템은 지속적으로 올바르게 동작한다.\n소프트웨어의 경우 신뢰 할 수 있다라는 언사에 대한 일반적인 기대치는 아래와 같다.\n애플리케이션은 사용자가 기대한 기능을 수행한다. 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다. 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다. 시스템은 허가되지 않은 접근과 오남용을 방지한다. 결함(fault) 에 대해서.\n결함과 장애 그리고 내결함성에 대해서 이해해야 한다. 먼저 결함과 장애는 동일하지 않다. 결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만, 장에는 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 상황을 이야기한다.\n그리고 결함은 모든 시스템에 필연적으로 존재한다. 예를들어 지진과 홍수와 같은 자연재해로 인해 서버가 파괴되었을 때 웹 호스팅을 이어나갈 수 없다. 결론적으로는 결함이 장애로 이어지지 않도록 내결함성(fault-tolerent), 탄력성(resilient)를 갖춰야 한다.\n그 이유는 모든 결함을 예방할 수 없기 때문인데, 그래서 보통은 모든것을 예방한다기 보단 내결함성을 갖는것을 추구한다. (물론 한번의 결함으로 인해 복구가 불가능한 피해를 입을 수 있는 보안같은 것들은 예방이 중요하다.)\n하드웨어 결함\n하드웨어 평균 장애시간(mean time to faillure, MTTF)는 평균적으로 10~50년으로 보고됐다. 따라서 10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한개의 디스크가 죽는다고 예상해야한다.\n첫 번째 대응으로 하드웨어 컴포넌트에 중복을 추가하는 방법이 일반적이다.\n전원 컴포넌트라면 발전기와 건전지가 있고, 네트워크 컴포넌트라면 다중화된 네트워크 인터페이스가 있다.\n당연히 비용이 엄청나게 들어가는 일이라, 고가용성을 위한 비용을 지불할 수 있는 소프트웨어에 사용됐었다.\n하지만 클라우드가 보편화 되었고, AWS와 같은 클라우드 서비스들은 단일 장비의 신뢰성보다 유연성과 탄력성을 주요 관심사로 삼는다.\n즉 AWS의 단일 인스턴스는 쉽게 죽지만, 다른 인스턴스로 쉽게 대체할 수 있다.\n소프트웨어 오류\n하드웨어 결함은 보통 무작위적이고, 서로 독립적이다. 즉 특정 한 장비의 디스크에 장애가 있다고 해서 다른 장비의 디스크에 장애가 발생하지 않는다는 뜻이다. 반면 소프트웨어 결함은 보통 시스템 전체에 영향을 미친다.\n소프트웨어 결함은 보통 무작위적이지 않다. 즉, 특정한 조건에서만 발생한다.\n소프트웨어 결함은 보통 신속한 해결책이 없다. (주의깊게 생각하기, 빈틈없는 테스트, 프로세스 격리와 죽은 프로세스의 재시작 허용, 모니터링 \u0026hellip;)\n인적 오류\n장비의 결함으로 인한 장애율은 보통 10~25% 선이다. 반면 사람은 최선의 의도를 갖고 있어도 미덥지 않다.\n신뢰성은 얼마나 중요할까? \u0026ldquo;원자력 발전소\u0026rdquo;, \u0026ldquo;항공 관제 시스템\u0026rdquo;, \u0026ldquo;몇만명의 몇년치 추억을 보관한 저장소 서비스\u0026rdquo; 만큼\u0026hellip;\n확장성 시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다. 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만, 시스템에 부여하는 일차원적인 표식이 아니다.\n\u0026ldquo;X는 확장 가능하다\u0026rdquo;, \u0026ldquo;Y는 확장성이 없다\u0026rdquo; - (X)\n\u0026ldquo;시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가\u0026rdquo; - (O) \u0026ldquo;추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?\u0026rdquo; - (O)\n부하 기술하기\n먼저 부하를 정의하고 파악하기 위해서 load parameter를 기술해야 한다.\n대표적인 예시로, 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등이 될 수 있다.\n병목이 있다면 특정 하나의 파라미터가, 그게 아니라면 해당 값들의 평균이 중요 할 수 있다.\n부하 기술하기 tweeter 예제\n# 트위터의 주요 두가지 동작 트윗 작성 - 평균 초당 4.6k, 피크 초당 12k 홈 타임라인 - 초당 300k 트윗 작성은 핸들링 하기 쉽지만, 팬아웃이 문제였다고 한다.\n1번 방식 - 간단히 트윗을 전역 컬렉션에 삽입 (타임라인 조회시 팔로우하는 모든 사람을 찾고, 이사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합치기)\nSELECT tweets.*, users.* FROM tweets JOIN users ON tweets.sender_id = users.id JOIN follows ON follows.followee_id = users.id WHERE follows.follower_id = current_user 엄청난 부하가 예상되는 쿼리!\n2번 방식 - 개별 사용자의 홈 타임라인 캐시를 유지하는 방식. (사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 모든 사람을 찾고 각자의 홈 타임라인 캐시에 새 트윗 삽입)\n쓰기 시점에 작업을 부가적으로 하면서 조회 부담을 극단적으로 줄이는 방식!\n결론적으로 트위터는 타임라인 조회 건수가 압도적으로 많기 때문에, 후자가 맞는 설계였다 문제는 2번 방식은 작성에 부하가 매우 커진다는 것 이었는데, 평균값은 75명 정도의 팔로워가 있어 4.6k의 쓰기가 345k 건의 쓰기로 이어지는데다가 진짜 문제는 분포였다. 특정 사용자의 경우 3천만이 넘는 팔로워를 가지고 있었다.\n트위터 결론 1번과 2번의 혼합 방식을 사용한다. 다만 2번방식에서 유명한 사용자의 트윗은 팬아웃에서 빠지고, 1번 방식으로 데이터를 로드하는 시점에 가져온다고 한다.\n성능 기술하기 부하 매게변수를 잘 기술해두면 아래와 같은 테스트들이 가능하다.\n부하 매개변수를 증가시키고, 시스템 자원을 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까? 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까? 두 질문 모두 성능 수치가 필요한데, 하둡과 같은 일괄 처리 시스템은 처리량이 관심사일것이고, 온라인 시스템의 중요한 사항은 응답 시간일 것이다. 책에서는 응답 시간에 대한 이야기를 위주로 한다.\n먼저 응답시간은 측정 가능한 값의 분포로 생각해야 한다.\n응답 시간에 대한 이 책의 주요한 관점\n보통 평균 시간을 참고하는건 좋은 생각이 아니다. 그보다는 중앙값과 같은 백분위값을 이용하는게 좋다. (예를 들어 가장 중간값의 요청이 200ms 가 걸렸다면, 절반의 사용자는 200ms이내에 응답을 받았고, 반대도 마찬가지이다.) 상위 하위 백분위값으로 주요 지표를 추려갈 수 있다. 꼬리 지연시간 (tail latency)는 생각보다 중요한 지표이다. 가장 비싼 요청을 보낸 사용자는 가장 주요한 고객일 확률이 높다. 그렇다고 최상위의 백분위를 참고하는것은 최적화에 너무 큰 비용이 들거나 임의 이벤트의 영향을 받을 수 있기에 참고하기에는 너무 지엽적인 지표이다. 큐 대기 지연은 느리게 응답받은 요청건의 상당수를 차지한다. (오래걸리는 요청이 먼저 온 케이스) 6번과 같은 이유로 클라이언트사이드의 응답시간 측정이 주요하다. 부하 대응 접근 방식 다수의 장비에 stateless한 서비스를 배포하는일은 상당히 간단한다. 하지만 단일 노드에 상태 유지 데이터 시스템을 분산 설치하는일은 아주 많은 복잡도가 추가적으로 발생한다. 이런 이유로 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다. 이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는것이 최근까지의 통념이다.\n특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무없이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳는다.\n유지보수성 운용성: 운영의 편리함 만들기\n좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.\n좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미이다.\n이해하기 어려운 내용은 없고 기술적인 면이 있는 챕터라 책의 디테일한 부분을 발췌하지는 않았다.\n단순성: 복잡도 관리\n최상의 도구는 추상화다. 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길수 있다. 예를 들어, 고수준 프로그래밍 언어는 기계언어, cpu 레지스터, 시스템콜을 숨긴 추상화다. SQL은 디스크에 기록하고 메모리에 저장한 복잡한 데이터 구조와 다른 클라이언트의 동시 요청과 고장 후 불일치를 숨긴 추상화다.\n발전성 : 변화를 쉽게 만들기\n애자일과 TDD와 같은 좋은 이야기들..\n정리 데이터 시스템을 컴포넌트로 나누고 그 흐름을 어플리케이션의 흐름으로 제어하기 때문에 어플리케이션 설계는 데이터 시스템 설계와 같다 가 주요한 내용인것 같은데 아직 구체적인 이야기는 나오지 않았다. 확장성을 설명하는 접근 방식이 좋았다. 주요 지표를 설정하고 그 지표에 따라서 확장에 대응하는 실제 예시를 통해 실전적인 고민을 하는 부분이 좋았다. ","permalink":"http://localhost:1313/_wiki/1%EC%9E%A5/","summary":"데이터 중심 애플리케이션 설계 1장 00 머리말 환경에 대한 이야기를 한다. 머리말에서는 최근 사업적으로는 클라우드와 saas 환경, 하드웨어 적으로는 cpu클럭이 더이상 오르지 않고 멀티코어가 표준이 된 환경을 이야기하며 병렬 처리에 대한 환경을 강조한다. 위의 예시를 데이터 중심적 이라고 정의하며 반대로 cpu사이클이 병목인경우를 계산 중심적이라고 정의한다 이 책은 (\u0026hellip;) 데이터 시스템의 기초가 되는 다양한 원리와 트레이드오프에 대해 논의한다. 데이터 시스템 아키텍처와 데이터 중심 애플리케이션으로 데이터 시스템을 통합하는 방법을 주로 다룬다.\n이 책의 개요","title":"데이터 중심 애플리케이션 설계 1장"},{"content":"데이터 중심 애플리케이션 설계 1부 데이터 시스템의 기초\n처음 4개의 장에서는 데이터 시스템이 잔일 장비거나 여러 클러스터 장비에 분산됐거나 상관없이 모든 상황에서 적용되는 기본 개념을 알아본다.\n[[1장]] : 신뢰성, 확장성, 유지보수성같은 단어의 실제 의미와 이같은 목표를 달성하기 위해 어떻게 해야하는지 [[2장]] : 데이터 모델과 질의 언어, 데이터 모델의 종류와 각 모델이 어떤 상황에 적합한지 [[3장]] : 저장소와 검색 [[4장]] : 부호화와 발전 ","permalink":"http://localhost:1313/_wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84/","summary":"데이터 중심 애플리케이션 설계 1부 데이터 시스템의 기초\n처음 4개의 장에서는 데이터 시스템이 잔일 장비거나 여러 클러스터 장비에 분산됐거나 상관없이 모든 상황에서 적용되는 기본 개념을 알아본다.\n[[1장]] : 신뢰성, 확장성, 유지보수성같은 단어의 실제 의미와 이같은 목표를 달성하기 위해 어떻게 해야하는지 [[2장]] : 데이터 모델과 질의 언어, 데이터 모델의 종류와 각 모델이 어떤 상황에 적합한지 [[3장]] : 저장소와 검색 [[4장]] : 부호화와 발전 ","title":"데이터 중심 애플리케이션 설계 스터디"},{"content":"AeroSpace Cheat Sheet 🧊️ https://www.josean.com/posts/how-to-setup-aerospace-tiling-window-manager https://nikitabobko.github.io/AeroSpace/commands\noption + , : 타일링 레이아웃/아코디언 레이아웃 전환 option + q : 터미닐 워크스페이스로 이동 option + w : 웹 브라우저 워크스페이스로 이동 option + e : gpt 워크스페이스로 이동 option + r : 채팅앱을 위한 워크스페이스로 이동 ","permalink":"http://localhost:1313/_wiki/aerospace-macos/","summary":"i3 like tiling tool for macos","title":"AeroSpace Cheat Sheet"},{"content":"Settings for AeroSpace 🧊️ # Place a copy of this config to ~/.aerospace.toml # After that, you can edit ~/.aerospace.toml to your liking # It\u0026#39;s not necessary to copy all keys to your config. # If the key is missing in your config, \u0026#34;default-config.toml\u0026#34; will serve as a fallback # You can use it to add commands that run after login to macOS user session. # \u0026#39;start-at-login\u0026#39; needs to be \u0026#39;true\u0026#39; for \u0026#39;after-login-command\u0026#39; to work # Available commands: https://nikitabobko.github.io/AeroSpace/commands after-login-command = [] # You can use it to add commands that run after AeroSpace startup. # \u0026#39;after-startup-command\u0026#39; is run after \u0026#39;after-login-command\u0026#39; # Available commands : https://nikitabobko.github.io/AeroSpace/commands after-startup-command = [] # Start AeroSpace at login start-at-login = true # Normalizations. See: https://nikitabobko.github.io/AeroSpace/guide#normalization enable-normalization-flatten-containers = true enable-normalization-opposite-orientation-for-nested-containers = true # See: https://nikitabobko.github.io/AeroSpace/guide#layouts # The \u0026#39;accordion-padding\u0026#39; specifies the size of accordion padding # You can set 0 to disable the padding feature accordion-padding = 30 # Possible values: tiles|accordion default-root-container-layout = \u0026#39;tiles\u0026#39; # Possible values: horizontal|vertical|auto # \u0026#39;auto\u0026#39; means: wide monitor (anything wider than high) gets horizontal orientation, # tall monitor (anything higher than wide) gets vertical orientation default-root-container-orientation = \u0026#39;auto\u0026#39; # Possible values: (qwerty|dvorak) # See https://nikitabobko.github.io/AeroSpace/guide#key-mapping key-mapping.preset = \u0026#39;qwerty\u0026#39; # Mouse follows focus when focused monitor changes # Drop it from your config, if you don\u0026#39;t like this behavior # See https://nikitabobko.github.io/AeroSpace/guide#on-focus-changed-callbacks # See https://nikitabobko.github.io/AeroSpace/commands#move-mouse on-focused-monitor-changed = [\u0026#39;move-mouse monitor-lazy-center\u0026#39;] on-focus-changed = \u0026#34;move-mouse window-lazy-center\u0026#34; # Gaps between windows (inner-*) and between monitor edges (outer-*). # Possible values: # - Constant: gaps.outer.top = 8 # - Per monitor: gaps.outer.top = [{ monitor.main = 16 }, { monitor.\u0026#34;some-pattern\u0026#34; = 32 }, 24] # In this example, 24 is a default value when there is no match. # Monitor pattern is the same as for \u0026#39;workspace-to-monitor-force-assignment\u0026#39;. # See: https://nikitabobko.github.io/AeroSpace/guide#assign-workspaces-to-monitors [gaps] inner.horizontal = 10 inner.vertical = 10 outer.left = 10 outer.bottom = 10 outer.top = 10 outer.right = 10 # \u0026#39;main\u0026#39; binding mode declaration # See: https://nikitabobko.github.io/AeroSpace/guide#binding-modes # \u0026#39;main\u0026#39; binding mode must be always presented [mode.main.binding] # All possible keys: # - Letters. a, b, c, ..., z # - Numbers. 0, 1, 2, ..., 9 # - Keypad numbers. keypad0, keypad1, keypad2, ..., keypad9 # - F-keys. f1, f2, ..., f20 # - Special keys. minus, equal, period, comma, slash, backslash, quote, semicolon, backtick, # leftSquareBracket, rightSquareBracket, space, enter, esc, backspace, tab # - Keypad special. keypadClear, keypadDecimalMark, keypadDivide, keypadEnter, keypadEqual, # keypadMinus, keypadMultiply, keypadPlus # - Arrows. left, down, up, right # All possible modifiers: cmd, alt, ctrl, shift # All possible commands: https://nikitabobko.github.io/AeroSpace/commands # You can uncomment this line to open up terminal with alt + enter shortcut # See: https://nikitabobko.github.io/AeroSpace/commands#exec-and-forget # alt-enter = \u0026#39;exec-and-forget open -n /System/Applications/Utilities/Terminal.app\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#layout alt-slash = \u0026#39;layout tiles horizontal vertical\u0026#39; alt-comma = \u0026#39;layout accordion horizontal vertical\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#focus alt-h = \u0026#39;focus left\u0026#39; alt-j = \u0026#39;focus down\u0026#39; alt-k = \u0026#39;focus up\u0026#39; alt-l = \u0026#39;focus right\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#move alt-shift-h = \u0026#39;move left\u0026#39; alt-shift-j = \u0026#39;move down\u0026#39; alt-shift-k = \u0026#39;move up\u0026#39; alt-shift-l = \u0026#39;move right\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#resize alt-shift-minus = \u0026#39;resize smart -50\u0026#39; alt-shift-equal = \u0026#39;resize smart +50\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#workspace alt-1 = \u0026#39;workspace 1\u0026#39; alt-2 = \u0026#39;workspace 2\u0026#39; alt-3 = \u0026#39;workspace 3\u0026#39; alt-4 = \u0026#39;workspace 4\u0026#39; alt-5 = \u0026#39;workspace 5\u0026#39; alt-q = \u0026#39;workspace T\u0026#39; # for Terminal alt-w = \u0026#39;workspace B\u0026#39; # for Browsers alt-e = \u0026#39;workspace G\u0026#39; # for GPT alt-r = \u0026#39;workspace C\u0026#39; # for Chat alt-m = \u0026#39;workspace M\u0026#39; # for Music alt-n = \u0026#39;workspace N\u0026#39; # for Notes # See: https://nikitabobko.github.io/AeroSpace/commands#move-node-to-workspace alt-shift-1 = \u0026#39;move-node-to-workspace 1\u0026#39; alt-shift-2 = \u0026#39;move-node-to-workspace 2\u0026#39; alt-shift-3 = \u0026#39;move-node-to-workspace 3\u0026#39; alt-shift-4 = \u0026#39;move-node-to-workspace 4\u0026#39; alt-shift-5 = \u0026#39;move-node-to-workspace 5\u0026#39; alt-shift-q = \u0026#39;move-node-to-workspace T\u0026#39; alt-shift-w = \u0026#39;move-node-to-workspace B\u0026#39; alt-shift-e = \u0026#39;move-node-to-workspace G\u0026#39; alt-shift-r = \u0026#39;move-node-to-workspace C\u0026#39; alt-shift-m = \u0026#39;move-node-to-workspace M\u0026#39; alt-shift-n = \u0026#39;move-node-to-workspace N\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#workspace-back-and-forth alt-tab = \u0026#39;workspace-back-and-forth\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#move-workspace-to-monitor alt-shift-tab = \u0026#39;move-workspace-to-monitor --wrap-around next\u0026#39; # See: https://nikitabobko.github.io/AeroSpace/commands#mode alt-shift-semicolon = \u0026#39;mode service\u0026#39; alt-shift-f = \u0026#39;fullscreen\u0026#39; # \u0026#39;service\u0026#39; binding mode declaration. # See: https://nikitabobko.github.io/AeroSpace/guide#binding-modes [mode.service.binding] esc = [\u0026#39;reload-config\u0026#39;, \u0026#39;mode main\u0026#39;] r = [\u0026#39;flatten-workspace-tree\u0026#39;, \u0026#39;mode main\u0026#39;] # reset layout #s = [\u0026#39;layout sticky tiling\u0026#39;, \u0026#39;mode main\u0026#39;] # sticky is not yet supported https://github.com/nikitabobko/AeroSpace/issues/2 f = [\u0026#39;layout floating tiling\u0026#39;, \u0026#39;mode main\u0026#39;] # Toggle between floating and tiling layout backspace = [\u0026#39;close-all-windows-but-current\u0026#39;, \u0026#39;mode main\u0026#39;] alt-shift-h = [\u0026#39;join-with left\u0026#39;, \u0026#39;mode main\u0026#39;] alt-shift-j = [\u0026#39;join-with down\u0026#39;, \u0026#39;mode main\u0026#39;] alt-shift-k = [\u0026#39;join-with up\u0026#39;, \u0026#39;mode main\u0026#39;] alt-shift-l = [\u0026#39;join-with right\u0026#39;, \u0026#39;mode main\u0026#39;] [[on-window-detected]] if.app-id = \u0026#39;com.googlecode.iterm2\u0026#39; run = \u0026#39;move-node-to-workspace T\u0026#39; [[on-window-detected]] if.app-id = \u0026#39;com.google.Chrome\u0026#39; run = \u0026#39;move-node-to-workspace B\u0026#39; [[on-window-detected]] if.app-id = \u0026#39;com.kakao.KakaoTalkMac\u0026#39; run = \u0026#39;move-node-to-workspace C\u0026#39; [[on-window-detected]] if.app-id = \u0026#39;com.tinyspeck.slackmacgap\u0026#39; run = \u0026#39;move-node-to-workspace C\u0026#39; [[on-window-detected]] if.app-id = \u0026#39;com.openai.chat\u0026#39; run = \u0026#39;move-node-to-workspace G\u0026#39; ","permalink":"http://localhost:1313/_wiki/aerospace/","summary":"Settings for AeroSpace 🧊️ # Place a copy of this config to ~/.aerospace.toml # After that, you can edit ~/.aerospace.toml to your liking # It\u0026#39;s not necessary to copy all keys to your config. # If the key is missing in your config, \u0026#34;default-config.toml\u0026#34; will serve as a fallback # You can use it to add commands that run after login to macOS user session. # \u0026#39;start-at-login\u0026#39; needs to be \u0026#39;true\u0026#39; for \u0026#39;after-login-command\u0026#39; to work # Available commands: https://nikitabobko.","title":"AeroSpace Toml"},{"content":"Settings 🧊️ TODO : dotfiles 레포를 만들자!\n[[AeroSpace]] ","permalink":"http://localhost:1313/_wiki/settings/","summary":"Settings 🧊️ TODO : dotfiles 레포를 만들자!\n[[AeroSpace]] ","title":"Settings 🧊️"},{"content":"9.0.0 Error Handling Error는 소프트웨어의 한 요소이다. 당연히 러스트에서도 다양한 방식으로 에러를 핸들링 할 수 있도록 지원한다. 러스트 역시 에러의 가능성과 그에대한 대응을 컴파일 시점에 체크해준다. 러스트는 에러를 두가지로 그룹화한다. recoverable과 unrecoverable 에러로 나누어진다. 다른 언어에서는 해당 에러들을 굳이 구분하지 않고, 모두 exception과 같은 시스템으로 처리한다. 러스트는 이러한 에러를 Result\u0026lt;T, E\u0026gt;와 panic! 매크로를 통해 나눠서 처리한다.\n9.1.0 Unrecoverable Errors with panic! 가끔 우리의 코드에는 안좋은 일들이 일어나고, 그 부분에 대해서 더이상 뭔가를 할 수 없는 경우가 있다. 이러한 경우를 unrecoverable 에러라고 하며, 러스트는 이러한 에러를 처리하기 위해 panic! 매크로를 제공한다.\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } panic! 매크로는 프로그램을 즉시 종료하고, 스택을 걷어내고, 부모 프로세스에게 알린다. RUSST_BACKTRACE=1 환경변수를 사용하여 백트레이스를 출력할 수 있다. 9.2.0 Recoverable Errors with Result enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } Result는 Ok와 Err 두 가지의 열거형을 가지고 있다. Result는 recoverable 에러를 나타내는데 사용된다. use std::fs::File; fn main() { let greeting_file_result = File::open(\u0026#34;hello.txt\u0026#34;); let greeting_file = match greeting_file_result { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; panic!(\u0026#34;Problem opening the file: {error:?}\u0026#34;), }; } ","permalink":"http://localhost:1313/_wiki/error-handling/","summary":"9.0.0 Error Handling Error는 소프트웨어의 한 요소이다. 당연히 러스트에서도 다양한 방식으로 에러를 핸들링 할 수 있도록 지원한다. 러스트 역시 에러의 가능성과 그에대한 대응을 컴파일 시점에 체크해준다. 러스트는 에러를 두가지로 그룹화한다. recoverable과 unrecoverable 에러로 나누어진다. 다른 언어에서는 해당 에러들을 굳이 구분하지 않고, 모두 exception과 같은 시스템으로 처리한다. 러스트는 이러한 에러를 Result\u0026lt;T, E\u0026gt;와 panic! 매크로를 통해 나눠서 처리한다.\n9.1.0 Unrecoverable Errors with panic! 가끔 우리의 코드에는 안좋은 일들이 일어나고, 그 부분에 대해서 더이상 뭔가를 할 수 없는 경우가 있다.","title":"러스트 에러 처리하기"},{"content":"burrow-checker에 대해 도움이 될 만 한 내용을 정리한 문서, rust-in-action 내용을 참고하여 작성하였습니다. 대여 검사는 서로 연결된 세 가지 개념인 수명, 소유권, 대여에 의존한다.\n소유권 : 러스트에서 소유권은 해당 값이 더 이상 필요 없을 때 깨끗이 지우는 것 과 관련이 있다. 수명 : 값에 접근해도 문제없는 기간을 의미한다. 대여 : 값에 접근함을 의미한다. 원래 소유자에게 값을 되돌려 주지 않아도 된다는 점에서 현실의 대여와 헷갈린다. \u0026ldquo;값의 소유자는 하나이며, 프로그램의 많은 다른 부분에서 이 값을 접근하기 위한 장치\u0026quot;를 생각하면 조금 더 편하다. 01. Preriquisite #[derive(Debug)] struct SomeStruct { some_field: u64, } fn do_not_take_ownership(primitive_type_case_param: u64) { println!(\u0026#34;do nothing!\u0026#34;); } fn take_ownership(some_struct: SomeStruct) { println!(\u0026#34;do nothing!\u0026#34;); } fn main() { let fine_case: u64 = 1; let ownership_error_case: SomeStruct = SomeStruct { some_field: 1 }; do_not_take_ownership(fine_case); take_ownership(ownership_error_case); println!(\u0026#34;fine_case: {}\u0026#34;, fine_case); println!(\u0026#34;ownership_error_case: {:?}\u0026#34;, ownership_error_case); } error[E0382]: borrow of moved value: `ownership_error_case` --\u0026gt; src/main.rs:22:44 | 16 | let ownership_error_case: SomeStruct = SomeStruct { some_field: 1 }; | -------------------- move occurs because `ownership_error_case` has type `SomeStruct`, which does not implement the `Copy` trait ... 19 | take_ownership(ownership_error_case); | -------------------- value moved here ... 22 | println!(\u0026#34;ownership_error_case: {:?}\u0026#34;, ownership_error_case); | ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move | note: consider changing this parameter type in function `take_ownership` to borrow instead if owning the value isn\u0026#39;t necessary --\u0026gt; src/main.rs:10:32 | 10 | fn take_ownership(some_struct: SomeStruct) { | -------------- ^^^^^^^^^^ this parameter takes ownership of the value | | | in this function = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) fine_case는 u64 타입이기 때문에 Copy 트레이트를 구현하고 있어서 do_not_take_ownership 함수에 값을 전달해도 문제가 없다. ownership_error_case는 SomeStruct 타입이기 때문에 Copy 트레이트를 구현하고 있지 않아서 take_ownership 함수에 값을 전달하면 소유권이 이동하게 된다. 그래서 ownership_error_case를 사용하려고 하면 컴파일 에러가 발생한다. 여기까지는 rust 기본 문접 가이드에서 나온 내용이라 어렵지는 않다. } 를 만나면 스코프의 종료와 함께 해당 스코프에 있는 변수(정확히는 스코프 내에서 생성된, 아규먼트를 포함한)들을 drop한다. 값이 범위를 넘어가거나 다른 어떤 이유로 수명이 끝난다면, 파괴자가 호출된다. 파괴자는 값에 대한 참조를 지우고 메모리를 해제함으로써 프로그램으로부터 값의 흔적을 지우는 함다. \u0026hellip; (중략) 이 시스템에 함축된 한 가지 의미는 \u0026ldquo;값은 절대로 소유자보다 오래 지속될 수 없다\u0026rdquo; 는 것이다.\n시스템은 아이디어를 함의하기 때문에 단순히 일어나는 일보다 왜 이렇게 되었을까를 이해하는게 더 중요하다고 생각한다. 개인적인 생각으로는 언어가 아무것도 안하거나 (c/cpp) 가비지 컬렉션같이 성능을 깎아먹는 것 대신, 소유권 시스템을 만들고 컴파일러가 이를 체크하도록 하는 것 자체가 아이디어인 것 같다.(하나의 시스템을 컴파일러가 검사한다면 사용자는 알아서 잘 하겠지!) 02. 소유권 문제 해결하기 러스트의 소유권 시스템은 훌륭하지만, 시스템을 이해하기 전에는 실수하기 십상이다. 그래서 처음 시작할 때 도움되는 네가지 전략은 아래와 같다.\n완전한 소유권이 필요하지 않은 경우에는 참조를 사용한다. 값을 복제한다. 이동 문제를 보조하기 위해 설계된 타입으로 데이터를 감싼다. 사실 \u0026lsquo;장기간 유지되어야 하는 객체 수를 줄일 수 있도록 코드를 리팩토링 한다.\u0026rsquo; 와 같은 해결책도 책에서는 소개하고 있지만, 일반적인 내용이며 예시를 직접 보는게 도움이 될 것 같아 정리하지는 않았다.\n완전한 소유권이 필요하지 않은 경우에는 참조를 사용한다.\n가장 직접적이며 단순한 해결방법이다. \u0026amp; T, \u0026amp; mut T 를 사용한다. 기존에 다른 언어를 배운 사람들에게 익숙한 방법이면서도 러스트 소유권 시스템 룰을 따를 수 있다. 다만 트리나 그래프같은 상황에서 소유권으로 인해 생기는 이슈에는 대응하지 못한다. 값을 복제한다.\n소유권 이전이 문제가 되는 상황에 대해서 또 하나의 간단한 해결책은 값을 복제하는 것이고 크게 두가지 방법이 있다. std::marker::Copy 트레이트를 구현하고 있는 타입은 값이 복사되어 전달된다. 원시 타입과 같은 경우는 CPU 입장에서는 부하가 덜하다는 장점이 있어 보통 Copy 트레이트를 구현하고 있다. 그래서 때로 몇몇 상황에서는 암묵적으로 수행된다는 특징이 있다. 비트 대 비트 사본을 만들기 때문에, 비용이 싸고 값이 동일하다. std::clone::Clone 절대 암묵적일 수 없다. clone() 메서드를 호출해야 한다. 느리고 비쌀 수 있으며, 정의하는 것에 따라서 원래 값과 달라질 수 있다. 데이터를 특별한 타입으로 감싸기.\nRc\u0026lt;T\u0026gt;는 기본적으로 아래와 같이 구현되어 있다. (가장 핵심적인 부분과 그부분을 보기위해 필요한 부분만 정리했다.)\npub struct Rc\u0026lt;T\u0026gt; { ptr: NonNull\u0026lt;RcBox\u0026lt;T\u0026gt;\u0026gt;, // 실제 데이터에 대한 포인터, NonNull은 null이 아닌 포인터를 보장한다. } struct RcBox\u0026lt;T\u0026gt; { strong: Cell\u0026lt;usize\u0026gt;, // Strong 참조 count weak: Cell\u0026lt;usize\u0026gt;, // Weak 참조 count value: T, // 실제 데이터 } impl\u0026lt;T\u0026gt; Rc\u0026lt;T\u0026gt; { // RcBox\u0026lt;T\u0026gt;의 value를 가리키는 포인터를 반환 fn inner(\u0026amp;self) -\u0026gt; \u0026amp;RcBox\u0026lt;T\u0026gt; { unsafe { self.ptr.as_ref() } } } impl\u0026lt;T\u0026gt; Clone for Rc\u0026lt;T\u0026gt; { #[inline] fn clone(\u0026amp;self) -\u0026gt; Rc\u0026lt;T\u0026gt; { unsafe { // strong 카운트 증가 self.inner().inc_strong(); Rc { ptr: self.ptr, } } } } impl\u0026lt;T\u0026gt; Drop for Rc\u0026lt;T\u0026gt; { fn drop(\u0026amp;mut self) { unsafe { if self.inner().dec_strong() == 0 { // strong 카운트가 0이 되면 value를 드롭 ptr::drop_in_place(self.inner_mut().value_mut()); // weak 카운트도 0이면, 메모리를 해제 if self.inner().weak() == 0 { deallocate(self.ptr.as_ptr() as *mut u8); } } } } } 간단하게, Rc\u0026lt;T\u0026gt;는 RcBox\u0026lt;T\u0026gt;를 가리키는 포인터를 가지고 있고, RcBox\u0026lt;T\u0026gt;는 실제 데이터와 참조 카운트를 가지고 있다 Rc\u0026lt;T\u0026gt;는 Clone 트레이트를 구현하고 있어서 clone() 메서드를 호출하면 참조 카운트를 증가시킨다. 그리고 Drop 트레이트를 구현하고 있어서 참조 카운트가 0이 되면 메모리를 해제한다. RefCell\u0026lt;T\u0026gt;도 마찬가지로, 가장 핵심적인 부분과 그부분을 보기위해 필요한 부분만 정리했다.\npub struct RefCell\u0026lt;T: ?Sized\u0026gt; { value: UnsafeCell\u0026lt;T\u0026gt;, // 내부 데이터 (UnsafeCell로 내부 변경 가능) borrow: Cell\u0026lt;isize\u0026gt;, // 현재의 빌림 상태 (불변 빌림: 양수, 가변 빌림: -1) } ","permalink":"http://localhost:1313/_wiki/burrow-checker/","summary":"burrow-checker에 대해 도움이 될 만 한 내용을 정리한 문서, rust-in-action 내용을 참고하여 작성하였습니다. 대여 검사는 서로 연결된 세 가지 개념인 수명, 소유권, 대여에 의존한다.\n소유권 : 러스트에서 소유권은 해당 값이 더 이상 필요 없을 때 깨끗이 지우는 것 과 관련이 있다. 수명 : 값에 접근해도 문제없는 기간을 의미한다. 대여 : 값에 접근함을 의미한다. 원래 소유자에게 값을 되돌려 주지 않아도 된다는 점에서 현실의 대여와 헷갈린다. \u0026ldquo;값의 소유자는 하나이며, 프로그램의 많은 다른 부분에서 이 값을 접근하기 위한 장치\u0026quot;를 생각하면 조금 더 편하다.","title":"burrow-checker에 대한 추가 정리자료"},{"content":"Daily-Log 📝 2024-09-24 가장 큰 프로젝트가 오픈했고, 오픈 직후의 이슈들도 정리되어 가고 있다. 밀렸던 포스팅들을 하나씩 올리려고 한다. 프로젝트 때문에 몇날 밤을 새웠는데, 몇일 쉬었다고 정신 못차리고 스터디와 사이드 프로젝트를 진행하려고 한다. 그 때문에 러스트 공부를 시급하게 해야한다. 당장 오늘 Rust In Action 복습을 시작했다. 2024-09-25 러스트 사이드 프로젝트의 교모와 시기가 상당히 타이트 할 것 같다. 10월 초 긴 연휴 내에 각자 필요한 것들을 준비하기로 했다. 최소 서버는 러스트로 구현 할 것 같다 (actix-web) 러스트 문법에 대한 복습을 짧게 마치고, 프레임워크에 대한 공부와 러스트 웹소켓 관련 코드들을 찾아보려고 한다. 2024-09-26 공부 할 때 알고 있었던 내용에 대한 더 명쾌한 정의가 나오면 쾌감이 쩐다. 해피해킹 키보드를 선물받았다. 나도 일본을 다녀왔는데 구매하지 못했고 선물도 딱히 준비하지 못했는데 미안했다. 키보드에 대한 적응은 사실 필요없었음(카라비너를 이용해서 이미 미니배열에 최적화 되도록 설정들을 사용하고 있었는데 관련해서 해피해킹 사용자들이 어떻게 하나 많이 찾아보고 있었음) 2024-10-07 키보드의 2번 레이어의 스페이스바를 option키로 바꾸기 2024-10-11 이펙티브 러스트가 출시됐다, 아마 이 책도 읽으며 포스팅을 작성할까 한다. 이 탬플릿이 좋을 것 같다. Kotlin-in-Action aerospace config 에 아래 설정 추가하기 # See: https://nikitabobko.github.io/AeroSpace/commands#workspace alt-1 = \u0026#39;workspace 1\u0026#39; alt-2 = \u0026#39;workspace 2\u0026#39; alt-3 = \u0026#39;workspace 3\u0026#39; alt-4 = \u0026#39;workspace 4\u0026#39; alt-5 = \u0026#39;workspace 5\u0026#39; alt-r = \u0026#39;workspace T\u0026#39; # for Terminal alt-t = \u0026#39;workspace B\u0026#39; # for Browsers alt-q = \u0026#39;workspace G\u0026#39; # for GPT alt-y = \u0026#39;workspace C\u0026#39; # for Chat alt-m = \u0026#39;workspace M\u0026#39; # for Music alt-n = \u0026#39;workspace N\u0026#39; # for Notes # See: https://nikitabobko.github.io/AeroSpace/commands#move-node-to-workspace alt-shift-1 = \u0026#39;move-node-to-workspace 1\u0026#39; alt-shift-2 = \u0026#39;move-node-to-workspace 2\u0026#39; alt-shift-3 = \u0026#39;move-node-to-workspace 3\u0026#39; alt-shift-4 = \u0026#39;move-node-to-workspace 4\u0026#39; alt-shift-5 = \u0026#39;move-node-to-workspace 5\u0026#39; alt-shift-r = \u0026#39;move-node-to-workspace T\u0026#39; alt-shift-t = \u0026#39;move-node-to-workspace B\u0026#39; alt-shift-q = \u0026#39;move-node-to-workspace G\u0026#39; alt-shift-y = \u0026#39;move-node-to-workspace C\u0026#39; alt-shift-m = \u0026#39;move-node-to-workspace M\u0026#39; alt-shift-n = \u0026#39;move-node-to-workspace N\u0026#39; 블로그를 조금 유지보수 했다, 좀 보기 싫었던 css를 수정했다. 새로운 취미? 혹은 목표로 매일 수학 1시간 공부하기를 해볼 예정이다, 그 이유는 아래와 같다. 학창시절에는 수학을 그나마 좋아했지만, 어느 순간 이후로 담을 쌓고 있었고 필요 할 때 마다 필요한부분을 보는정도로 때워왔다. 경제학을 공부할때 미분 조금 뭐 이런식으로.. 그러다가 수학이 꼭 필요한 시점이 금방 오지 않을까? 라는 생각을 해왔는데, 뭔가 진짜 와가는 것 도 같고, 오늘은 특히 하스켈 관련한 포스팅을 보다가 수학이 필요하다는 생각이 들었다.(항상 뭔가를 볼 때 수학적인 내용이 나올 때 마다 가슴한켠을 찌르는데 바빠서 외면해왔다. ) 급한건 선형대수, 이산수학 (그리고 그걸 위한 미적분)이고, 개인적으로 빨리 보고싶은건 수리논리학이다. 그래도 지금은 재활이 필요한 시점이라 마침 적절한 인프런 강의도 있기에 기초대수학으로 시작해보려고 한다. 취미라고 한 이유는 지금 당장 할 일이 많아 죽겠고, 공부할것도 많아 죽겠어서 당장 이게 먼저가 아닌건 분명히 아는데 막연한 불안감과 양심때문에 굳이 하는거라서 그렇다. 선형대수학은 학부때 c를 받았고 그만큼 지루했는데 잘 해내길 바래야겠다. 2024-10-14 이펙티브 러스트트를 시작하려고한다. 이번 주 수요일까지 간단하게 초기세팅을 완료한 러스트 서버를 띄워야한다. 아마도 axum + mongodb + jwt관련 세팅 추가하고 띄울 것 같다. .ideavimrc 파일 을 만들고 관리해야 겠다, 점점더 dotfiles에 대한 요구가 많아져서 둘 다 같이 빨리 작업해야겠다 2024-10-17 러스트 axum 서버를 이용한 서버 초기 구현을 끝냈다. 생각보다 훨씬 오래걸렸다. 처음에는 axum관련 코드에 익숙하지 않았고, 이슈 해결하는게 오래걸렸다. 너무 복잡한 boiler_plate template을 선택해서 조금 더 해맸던 것 같다. 마침 layered architecture 패턴으로 된 템플릿 찾아서 그냥 해당 탬플릿으로 바꾸고 나아졌다. model과 model_controller를 기준으로 하고 라우팅 핸들러가 직접 참조하는식으로 하려고 했는데, 잘 안됐다 뭔가 코드가 애매하게 나온다. 기본적으로 아직 상태관리가 익숙하지 않아서 그런 것 같긴 하다 의존성주입 덕분에 편했던 부분을 직접 관리하려고 하니 생각보다 예쁘게 안나와서 일단 기본적으로 구현했다. AppState, Axum의 State 부분을 잘 관리하는 best case코드를 실제로 좀 보고싶은데 아무래도 자료가 조금 부족하다 2024-10-18 \u0026lsquo;올바른 문제\u0026rsquo;를 \u0026lsquo;올바른 때\u0026rsquo;에 \u0026lsquo;제대로된 방법\u0026rsquo;으로 풀어 가는 사람이 결국 이깁니다\n이번 주말의 목표로는 수학공부를 시작하는것과, dotfiles 레포 만들기가 있다 기대된다. 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의하자. \u0026ldquo;X는 확장 가능하다\u0026rdquo; 또는 \u0026ldquo;Y는 확장성이 없다\u0026rdquo; 같은 말은 의미가 없다. 오히려 확장성을 논한다는 것은 \u0026ldquo;시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?\u0026ldquo;와 \u0026ldquo;추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?\u0026rdquo; 같은 질문을 고려한다는 의미다.\n아주 좋은 관점이자 좋은 문구인 것 같다. (심지어 튜터링중에 써먹기도 너무 좋다) 가끔패턴이나 방법론책(이펙티브 시리즈, 클린코드, 클린아키텍처)나, 특정 패러다임등을 처음 공부하시는 분들이 너무 심취하셔서 \u0026ldquo;~ 패턴을 사용하지 않았으니 안좋은 코드다\u0026rdquo; 라는 식으로 생각하시는 경우가 있는데, 소개해주기 좋은 관점인 것 같다. 2024-10-21 주말에 수학공부를 시작하지 못했다! \u0026ldquo;내일부터 해야지\u0026rdquo; dotfile은 만들고 있고 만들던 와중에 ideavim도 결국 만져야 할 것 같아서 조금 걸리고 있다. Wezterm으로 갈아타는거에 한눈이 팔렸다. 2024-10-23 용기를 내서 질문했는데, 너무 따뜻한 답변을 받았다. 뭔가 내가 질문에 생략했던것들에 대해서도 알고 계신 듯 한 느낌을 받았다. 질문의 결과로 머리가 명확해지는 경우가 생각보다 일하면서도 흔치 않은데, 이번에는 그런 느낌을 받았다. 나중에 누군가를 도울 일이 있다면 꼭 오늘을 기억하고 싶다. 2024-10-24 ideavimrc를 만들고, dotfiles 작업을 마무리하려고 한다. 2024-10-26 내 인생에 가장 위대한 영화로 꼽힐 영화를 봤다. The Wild Robot 그래도 프로그래밍을 하는 사람으로써 절대 일어날 일 없는 일을 이 영화에서 단 한번만 일어나게 해달라고 때 쓰는 애처럼 봤다. 또 한 번 내 인생에서 가장 기억에 남을 순간을 같이해준, 그리고 기꺼이 그러자고 해준 아내에게 감사하다. 인생은 알 수 없는 일이지!\n2024-10-29 ideavim에 익숙해지기 위해서 여러 설정을 들춰보고 좋은쪽으로 수정도 해보고 있고, 와중에 더 좋아보이는 단축키로 원래 nvim 키매핑도 변경해가면서 하고 있다. 두 가지 이슈가 있는데, 블로그의 최근 변경된 문서 항목이 지나치게 늘어지는거랑, 로컬 빔위키가 느려지고 있다는 점이다(프로파일 해봐도 이유가 잘 안잡힌다.) ","permalink":"http://localhost:1313/_wiki/daily-log-2024/","summary":"Daily-Log 📝 2024-09-24 가장 큰 프로젝트가 오픈했고, 오픈 직후의 이슈들도 정리되어 가고 있다. 밀렸던 포스팅들을 하나씩 올리려고 한다. 프로젝트 때문에 몇날 밤을 새웠는데, 몇일 쉬었다고 정신 못차리고 스터디와 사이드 프로젝트를 진행하려고 한다. 그 때문에 러스트 공부를 시급하게 해야한다. 당장 오늘 Rust In Action 복습을 시작했다. 2024-09-25 러스트 사이드 프로젝트의 교모와 시기가 상당히 타이트 할 것 같다. 10월 초 긴 연휴 내에 각자 필요한 것들을 준비하기로 했다. 최소 서버는 러스트로 구현 할 것 같다 (actix-web) 러스트 문법에 대한 복습을 짧게 마치고, 프레임워크에 대한 공부와 러스트 웹소켓 관련 코드들을 찾아보려고 한다.","title":"Daily-Log 2024 (Daily 아님주의) 🙈"},{"content":"16. 세그멘테이션 16.1 베이스 바운드의 일반화 지금 가정의 단계에서 내부단편화가 발생하는 요인은 스택과 힙 사이에 사용하지 않는 메모리가 존재하는 것이다.\n세그멘테이션은 60년대에 이미 사용되던 메모리 관리 기법이다.\n기본적으로 세그멘테이션은 세그먼트마다 베이스와 바운드를 가지고 있다.\n세그먼트란 논리적인 단위로, 프로그램이나 데이터를 담고 있는 논리적인 단위이다. (스택, 힙, 데이터영역, 코드영역 등)\n즉 논리적인 단위로 나누어진 세그먼트(논리적 단위)에 각각 베이스와 바운드를 주는 것이다.\n그외에는 베이스 바운드 기법을 사용한다. 예를들어 가상주소가 100, 베이스가 50, 바운드가 110이라면, 베이스 주소인 50으로 가서 100을 더하면 150이 되는데, 이는 바운드보다 크기 때문에 오류가 발생한다. (똑같음) 참고로 베이스 + 오프셋(가상주소)이 바운드보다 크면 오류가 발생하는데, 이걸 Segment Fault라고 한다.\n\u0026lsquo;일반화\u0026rsquo; 라는 단어가 뭔가 묘하게 어울리지 않는 것 같아서 약간 헷갈릴 수 있지만 어려운 내용은 아니다.\n16.2 세그먼트 종류에 대한 파악 당연하게도 뭐하나 자동으로 되는건 없다. 세그먼트를 베이스를 기반으로 참조했을때 이 세그먼트가 어떤 종류인지도 알 수 있도록 조치해야한다.\n처음에는 네트워크에서 헤더 붙이는 것처럼 주소값에 최상위 몇 비트를 이용해서 구분했다. Segment = (VirtualAddress \u0026amp; SEGMENT_MASK) \u0026gt;\u0026gt; SEGMENT_SHIFT Offset = VirtualAddress \u0026amp; OFFSET_MASK if Offset \u0026gt; SegmentSize[Segment] then Raise Exception(SEGMENTATION_FAULT) else PhysicalAddress = Base[Segment] + Offset Register = Memory[PhysicalAddress] 해석 여기서 목표는 아래와 같음\n가상 주소: 1100 0101 0010 1101 1010 1111 0001 0011 (32비트) 세그먼트 번호: 1100 (상위 4비트) 오프셋: 0101 0010 1101 1010 1111 0001 0011 (하위 28비트) 근데 우리는 아니까 앞에 4비트를 떼어내서 세그먼트 번호를 구할수 있는데, 컴퓨터는 멍청해서 그게 안된다.\n첫줄은 이렇게 나누려고 SEGMENT_MASK로 \u0026amp;연산을 해서 세그먼트 번호를 구하는 코드\nSEGMENT_MASK: 1111 0000 0000 0000 0000 0000 0000 0000 (32비트) VirtualAddress: 1100 0101 0010 1101 1010 1111 0001 0011 SEGMENT_MASK: 1111 0000 0000 0000 0000 0000 0000 0000 결과: 1100 0000 0000 0000 0000 0000 0000 0000 여기서 결과값에 쉬프트 연산으로 다 밀어버리면 세그먼트 번호가 나온다.\n비슷한 과정을 거쳐 오프셋을 구한다.\nBase[Segment] : 해당하는 세그먼트의 베이스 주소, 여기다 오프셋을 더하면 물리주소가 나온다.\n그리고 해당 주소값을 참조하기!\n문제점\n문제는 이러한 방식은 최대 세그먼트의 크기와 같은 것들이 \u0026lsquo;고정\u0026rsquo;이고, \u0026lsquo;약속\u0026rsquo;이 되어 있다는 것!\n또한 위에 주소 비트를 이용해서 세그먼트를 구분하는데 쓰는것도 생각보다 더 비용이 많이 든다.\n예를들어 앞에 네 비트를 사용하면 실제 offset으로 사용할 수 있는 비트가 2^4만큼 줄어든다.\n16억개의 메모리 주소를 사용할 수 있었을건데 비트 네개를 까버리면 1억개만 사용할 수 있게 된다.\n16.3 스택 스택이라고 소개를 하지만, 사실 세그먼트의 특성에 따라 관리와 행동이 달라진다는 것을 보여주는 예시\n스택이라는 세그먼트는 주소가 음의 성장을 한다. 이거 cpp보면 진짜 그럼\n이젠 순방향으로 증가하는지 여부를 어딘가에 저장해야한다.\n그래서 스택 세그먼트에는 방향 비트를 추가해서 어느 방향으로 증가하는지를 표시한다.\n16.4 공유 지원(Support for Sharing) 여기는 번역이 너무 이상하다. 예시에 대한 설명이 부족한데 갑자기 보호비트 이야기가 나와서 당황하스러움..\n결론적으로는 일단, 특정 세그먼트를 공유하는게 메모리 공간상 효율적일 수 있는데, 바로 \u0026lsquo;code\u0026rsquo;를 공유하는 것이다.\n가장 직관적으로 비유하면 라이브러리 같은 것을 공유하는 것이다.(정확하지는 않지만 c로 작성된 프로그램이 여럿인데, stl을 여러개 메모리에 올릴 이유가 없음!)\n이건 진짜 좋긴 하지만 위험하니까, 공유를 위해 보호 비트를 추가해서 공유한다는게 주요 내용이다.\n여기까지 세그먼트 레지스터에 저장해야할 데이터는 아래와 같다. 16.5 소단위대 대단위 세그멘테이션 지금은 대단위 세그멘테이션을 한다. (스택, 힙, 코드, 데이터) 요정도로만 크게크게 나눠서 대단위라고함\n그런데 필요성에 따라서, 더 작은 단위로 나누어서 세그멘테이션을 할 수도 있다.\n이렇게 세그먼트를 줄이고 많이 가지고 있으면 세그멘트 테이블 같은 새로운 하드웨어 지원이 필요하다.\n16.6 운영체제의 지원 세그멘테이션 덕분에 낭비되는 \u0026lsquo;물리\u0026rsquo;메모리 없이 메모리를 효율적으로 사용할 수 있게 되었다. 근데 당연하게도 세그먼트가 야기하는 문제가 있고, 세그먼트가 아직 해결 못한 문제도 있다. 세그먼트가 야기하는 문제와 세그먼트로 해결 못한 문제 마지막으로 그걸 운영체제가 어떻게 해결 할 수 있는지 알아본다.\n세그먼트가 야기하는 문제 컨텍스트 스위치 시 세그먼트 레지스터 관리 문제 각 프로세스는 자신의 가상 주소 공간을 가지고 있어, 컨텍스트 스위치 시 운영체제가 세그먼트 레지스터를 저장하고 복원해야 한다.(오버헤드가 커지겠지!) 세그먼트 크기 변경 시의 문제 프로그램이 malloc()을 호출할 때, 기존 힙에서 요청을 처리할 수 없으면 힙 세그먼트가 커져야 한다. 메모리 할당 라이브러리가 시스템 호출을 통해 힙을 확장하고, 운영체제는 힙을 확장하여 세그먼트 크기 레지스터를 업데이트하고, 라이브러리에 성공을 알린다. 운영체제는 물리 메모리가 부족하거나 호출된 프로세스가 이미 너무 많은 메모리를 사용하고 있다고 판단하면 요청을 거부할 수 있다. 물리 메모리의 빈 공간 관리 문제 새로운 주소 공간을 생성할 때 운영체제는 세그먼트에 대한 물리 메모리 공간을 찾아야 한다. 물리 메모리가 작은 빈 공간들로 나뉘어 새로운 세그먼트를 할당하거나 기존 세그먼트를 확장하기 어려워진다. 이를 외부 단편화(external fragmentation)라고 한다. 세그먼트가 아직 해결 못한 문제 외부 단편화 문제 세그먼트가 가변 크기이기 때문에 빈 메모리가 작은 조각들로 나뉘어져 메모리 할당 요청을 충족하기 어렵게 된다. 완전히 일반화된 희박한 주소 공간 지원 부족 문제 큰 논리적 세그먼트(예: 희박한 힙)가 메모리에 완전히 상주해야 한다. 주소 공간 사용 모델이 세그멘테이션 설계 방식과 일치하지 않으면 세그멘테이션이 잘 작동하지 않는다. 운영체제가 세그멘테이션 문제를 해결하는 방법 메모리 압축 방법 운영체제는 프로세스를 멈추고 데이터를 연속된 메모리 영역으로 복사하고, 세그먼트 레지스터 값을 새로운 물리적 위치로 변경하여 큰 빈 메모리 공간을 확보한다. 그러나 메모리 압축은 비용이 많이 든다. 자유 리스트 관리 알고리즘 사용 큰 메모리 공간을 유지하려고 시도하는 자유 리스트 관리 알고리즘을 사용한다. 대표적인 알고리즘으로는 best-fit, worst-fit, first-fit, buddy algorithm 등이 있다. 이러한 알고리즘은 외부 단편화를 최소화하려고 시도한다. 세그멘테이션은 메모리 가상화에서 여러 문제를 해결하지만, 여전히 외부 단편화와 희박한 주소 공간 지원 부족 문제를 가지고 있다. 운영체제는 메모리 압축과 다양한 자유 리스트 관리 알고리즘을 통해 이러한 문제를 해결하려고 노력하지만, 근본적인 문제는 여전히 존재하므로 더 나은 솔루션이 필요하다.\n17. 빈 공간 관리 앞에서 세그먼트로 나눔으로써, 내부 단편화를 해결했지만 외부 단편화 문제가 주요하게 남아있다. 즉 고정 메모리 범위를 사용하면서 발생하는 문제를 세그먼트 단위로 적재하면서 해결했지만, 세그먼트를 메모리에 적재하는데 발생하는 문제가 외부 단편화이다.\n문제를 너무 잘 요약해서 책을 발췌하면, 관리해야 하는 공간이 가변 크기의 빈 공간으로 나뉘어져 있는 이슈를 해결해야한다. 17.1 가정 이 논의의 대부분은 사용자 수준의 메모리 할당 라이브러리의 발전 역사를 중심으로 한다. (malloc()과 free()는 실시간으로 힙 세그먼트 내부의 빈 공간을 조정해야 하는 역할을 필연적으로 가지게 된다.)\n외부 단편화를 해결하는데 초점을 맞춘다. 할당된 메모리는 다른 위치로 이동할 수 없다. 17.2 저 수준의 기법들 빈공간 list 만들기 빈 공간을 관리하기 위해 위처럼 말 그대로 빈 공간의 리스트를 만들어서 관리한다. 분할 빈 공간을 나누어서 할당하는 방법이다. 일단 요청이 청크보다 작으면, 청크를 나누어 사용자에게 할당하고, 남은 부분은 리스트에 남긴다. 병합 반환받은 메모리를 병합시키는 방법이다. 문제는 여기서 발생한다. 위의 사진에서 10을 사용하던 두 메모리가 반환됐을때, 10을 의미하는 빈공간 리스트의 세개의 노드가 존재하게 되고, 사실상 30이 연달아 있어 사용할 수 있는 메모리가 30이 되어야 하는데, list를 순회하며 10이 넘는 요청에 대한 메모리를 할당하지 못하도록 되어있다. 사실 병합의 문제는 간단히 해결 할 수 있다, 메모리가 반환되는 \u0026lsquo;시점\u0026rsquo;에 빈공간 리스트의 인접한 노드를 검사하고 병합시키면 된다.\n참고로 포인터는 헤더가 있어서 실제 할당하려고 하면, 요청한 메모리 + 헤더 크기만큼 할당한다.\n#include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; typedef struct __node_t { int size; struct __node_t *next; } node_t; #define MAGIC 1234567 typedef struct { int size; int magic; } header_t; node_t *head = NULL; // 힙 초기화 함수 void init_heap(int size) { head = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0); if (head == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); exit(1); } head-\u0026gt;size = size - sizeof(node_t); head-\u0026gt;next = NULL; } // 메모리 할당 함수 void *my_malloc(int size) { node_t *current = head; node_t *prev = NULL; while (current != NULL) { if (current-\u0026gt;size \u0026gt;= size + sizeof(header_t)) { header_t *hptr = (header_t *)((char *)current + sizeof(node_t)); hptr-\u0026gt;size = size; hptr-\u0026gt;magic = MAGIC; node_t *new_free = (node_t *)((char *)hptr + sizeof(header_t) + size); new_free-\u0026gt;size = current-\u0026gt;size - sizeof(header_t) - size - sizeof(node_t); new_free-\u0026gt;next = current-\u0026gt;next; if (prev == NULL) { head = new_free; } else { prev-\u0026gt;next = new_free; } return (void *)(hptr + 1); } prev = current; current = current-\u0026gt;next; } return NULL; // 할당 실패 } // 메모리 해제 함수 void my_free(void *ptr) { header_t *hptr = (header_t *)ptr - 1; assert(hptr-\u0026gt;magic == MAGIC); node_t *free_block = (node_t *)hptr; free_block-\u0026gt;size = hptr-\u0026gt;size + sizeof(header_t); node_t *current = head; node_t *prev = NULL; while (current != NULL \u0026amp;\u0026amp; current \u0026lt; free_block) { prev = current; current = current-\u0026gt;next; } free_block-\u0026gt;next = current; if (prev == NULL) { head = free_block; } else { prev-\u0026gt;next = free_block; } // 병합 if (free_block-\u0026gt;next != NULL \u0026amp;\u0026amp; (char *)free_block + free_block-\u0026gt;size + sizeof(node_t) == (char *)free_block-\u0026gt;next) { free_block-\u0026gt;size += free_block-\u0026gt;next-\u0026gt;size + sizeof(node_t); free_block-\u0026gt;next = free_block-\u0026gt;next-\u0026gt;next; } if (prev != NULL \u0026amp;\u0026amp; (char *)prev + prev-\u0026gt;size + sizeof(node_t) == (char *)free_block) { prev-\u0026gt;size += free_block-\u0026gt;size + sizeof(node_t); prev-\u0026gt;next = free_block-\u0026gt;next; } } // 힙 상태 출력 함수 void print_heap() { node_t *current = head; printf(\u0026#34;Free list:\\n\u0026#34;); while (current != NULL) { printf(\u0026#34;Address: %p, Size: %d\\n\u0026#34;, current, current-\u0026gt;size); current = current-\u0026gt;next; } } int main() { init_heap(4096); // 4KB 힙 초기화 void *a = my_malloc(100); void *b = my_malloc(100); void *c = my_malloc(100); print_heap(); my_free(b); print_heap(); my_free(a); my_free(c); print_heap(); return 0; } 17.3 힙의 확장 기본 전략 힙의 확장은 빈 공간이 부족할 때, 더 큰 메모리 공간을 할당하는 것을 의미한다. 없으면 NULL을 반환한다 -끝- 이 아니고\n아래와 같은 기본 전략들이 있다. 1. 최적 적합 (Best-Fit) 동작 방식: 메모리 할당 요청 시, 전체 자유 리스트를 탐색하여 요청된 크기에 가장 가까운(즉, 요청 크기에 가장 적게 남는) 자유 블록을 선택하는 방식이다. 선택된 블록을 할당하고 남은 부분을 다시 자유 리스트에 추가하는 방식이다. 장점: 메모리 공간을 최소한으로 낭비하게 하여 외부 단편화를 줄이는 데 도움이 된다. 단점: 전체 자유 리스트를 탐색해야 하므로 탐색 시간이 오래 걸릴 수 있다. 작은 조각들이 많이 남아 내부 단편화가 증가할 수 있다. 2. 최초 적합 (First-Fit) 동작 방식: 메모리 할당 요청 시, 자유 리스트의 첫 번째부터 시작하여 요청된 크기를 만족하는 첫 번째 블록을 선택하는 방식이다. 선택된 블록을 할당하고 남은 부분을 다시 자유 리스트에 추가하는 방식이다. 장점: 탐색 시간이 짧아 효율적이다. 대체로 빠른 할당이 가능하다. 단점: 초기 부분에 작은 조각들이 많이 남아 외부 단편화가 발생할 수 있다. 자주 사용되는 영역에 단편화가 발생할 가능성이 있다. 3. 최악 적합 (Worst-Fit) 동작 방식: 메모리 할당 요청 시, 전체 자유 리스트를 탐색하여 가장 큰 자유 블록을 선택하는 방식이다. 선택된 블록을 할당하고 남은 부분을 다시 자유 리스트에 추가하는 방식이다. 장점: 큰 블록을 분할하여 큰 조각들이 남아 큰 메모리 요청을 처리하기 쉽다. 단점: 큰 블록을 분할하면서 작은 조각들이 많이 남아 외부 단편화가 증가할 수 있다. 4. 다음 적합 (Next-Fit) 동작 방식: 메모리 할당 요청 시, 이전 할당이 끝난 위치부터 시작하여 요청된 크기를 만족하는 첫 번째 블록을 선택하는 방식이다. 선택된 블록을 할당하고 남은 부분을 다시 자유 리스트에 추가하는 방식이다. 장점: 최초 적합과 유사한 성능을 가지며, 자주 사용되는 영역에 단편화가 덜 발생한다. 단점: 자유 리스트가 순환 구조를 가지므로 리스트의 끝에서 다시 시작해야 할 경우 탐색 시간이 길어질 수 있다. 5. 개별 리스트 (Segregated List) 동작 방식: 크기별로 여러 개의 자유 블록 리스트를 따로 관리하는 방식이다. 요청된 크기에 맞는 리스트에서 블록을 할당하고, 필요 시 더 큰 블록을 분할하여 할당한다. 장점: 특정 크기의 블록을 빠르게 찾을 수 있어 탐색 시간이 짧다. 크기별로 관리하므로 특정 크기의 블록들이 적절히 분리되어 단편화를 줄이는 데 도움이 된다. 단점: 여러 리스트를 관리해야 하므로 구현이 복잡할 수 있다. 크기별 리스트에 따라 메모리 낭비가 발생할 수 있다. 6. 버디 할당기 (Buddy Allocation) 동작 방식: 메모리를 2의 거듭제곱 크기로 분할하여 관리하는 방식이다. 요청된 크기에 가장 적합한 크기의 블록을 할당하며, 필요 시 블록을 분할한다. 장점: 메모리 병합이 쉽고 빠르며, 내부 단편화가 적다. 단점: 항상 2의 거듭제곱 크기로 할당하므로, 일부 경우 외부 단편화가 발생할 수 있다. 18. 페이징: 개요 ","permalink":"http://localhost:1313/_wiki/week-06/","summary":"16. 세그멘테이션 16.1 베이스 바운드의 일반화 지금 가정의 단계에서 내부단편화가 발생하는 요인은 스택과 힙 사이에 사용하지 않는 메모리가 존재하는 것이다.\n세그멘테이션은 60년대에 이미 사용되던 메모리 관리 기법이다.\n기본적으로 세그멘테이션은 세그먼트마다 베이스와 바운드를 가지고 있다.\n세그먼트란 논리적인 단위로, 프로그램이나 데이터를 담고 있는 논리적인 단위이다. (스택, 힙, 데이터영역, 코드영역 등)\n즉 논리적인 단위로 나누어진 세그먼트(논리적 단위)에 각각 베이스와 바운드를 주는 것이다.\n그외에는 베이스 바운드 기법을 사용한다. 예를들어 가상주소가 100, 베이스가 50, 바운드가 110이라면, 베이스 주소인 50으로 가서 100을 더하면 150이 되는데, 이는 바운드보다 크기 때문에 오류가 발생한다.","title":"Week-06"},{"content":" static_cast static_cast는 가장 기본적인 형태의 캐스팅이다. 컴파일 시간에 타입 변환을 수행하며, 컴파일러가 타입 안전성을 어느 정도 보장해 준다. 주로 기본 타입 간의 변환, 명시적 생성자를 사용한 객체 생성, 상속 관계에 있는 클래스 간의 변환 등에 사용된다. Copy code int a = 10; double b = static_cast\u0026lt;double\u0026gt;(a); // int를 double로 변환 dynamic_cast dynamic_cast는 주로 다형성(polymorphism)을 사용하는 클래스 계층에서의 포인터 또는 참조 타입 변환에 사용된다. 실행 시간에 타입 검사를 수행하여 안전한 타입 변환을 보장해 준다. dynamic_cast는 주로 상속 관계에서 부모 클래스 포인터를 자식 클래스 포인터로 변환할 때 사용되며, 변환이 실패하면 nullptr을 반환한다. RTTI(Runtime Type Information)를 사용하여 실행 시간에 타입 정보를 확인하므로, dynamic_cast를 사용하려면 반드시 가상 함수(virtual function)가 정의된 클래스여야 한다. Copy code class Base { virtual void foo() {} }; class Derived : public Base { void foo() override {} }; Base* basePtr = new Derived; Derived* derivedPtr = dynamic_cast\u0026lt;Derived*\u0026gt;(basePtr); // 성공하면 derivedPtr이 유효한 포인터가 된다 const_cast const_cast는 변수의 const 또는 volatile 속성을 제거하거나 추가할 때 사용된다. 주로 기존의 const 객체를 변경해야 할 때 사용되며, 이는 안전하게 사용해야 한다. 비유하자면, const_cast는 책을 읽기 전용으로 두었다가 다시 수정 가능하도록 설정하는 것과 비슷하다. Copy code const int a = 10; int* b = const_cast\u0026lt;int*\u0026gt;(\u0026amp;a); // const를 제거하여 a를 수정 가능하게 만든다 reinterpret_cast reinterpret_cast는 가장 강력하고 위험한 형태의 캐스팅이다. 포인터나 데이터의 비트 패턴을 단순히 다른 타입으로 해석한다. 주로 포인터 타입 간의 변환이나 비트 패턴을 그대로 유지한 채 다른 타입으로 해석하고자 할 때 사용된다. Copy code int a = 65; char* b = reinterpret_cast\u0026lt;char*\u0026gt;(\u0026amp;a); // int 포인터를 char 포인터로 변환 ","permalink":"http://localhost:1313/_wiki/cpp-casting/","summary":"static_cast static_cast는 가장 기본적인 형태의 캐스팅이다. 컴파일 시간에 타입 변환을 수행하며, 컴파일러가 타입 안전성을 어느 정도 보장해 준다. 주로 기본 타입 간의 변환, 명시적 생성자를 사용한 객체 생성, 상속 관계에 있는 클래스 간의 변환 등에 사용된다. Copy code int a = 10; double b = static_cast\u0026lt;double\u0026gt;(a); // int를 double로 변환 dynamic_cast dynamic_cast는 주로 다형성(polymorphism)을 사용하는 클래스 계층에서의 포인터 또는 참조 타입 변환에 사용된다. 실행 시간에 타입 검사를 수행하여 안전한 타입 변환을 보장해 준다.","title":"cpp-casting 🐋"},{"content":"C++ 타입 변환 int main() { // -------비트열 재구성 여부에 따른 분류 -------- { // 1. 값 타입 변환(implicit conversion) // 특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성 // 실제로 메모리를 까보면, 원본 데이터와 다른 비트열로 재구성되어있는 부분을 확인할 수 있다. int a = 123456789; float b = (float)a; } { // 2. 참조 타입 변환 // 특징) 참조 타입 변환은 참조 타입을 이용해서, 원본 객체의 비트열을 그대로 참조 (보는 관점만 변화) // 실제로 메모리를 까보면, 원본 데이터와 같은 비트열로 재구성되어있는 부분을 확인할 수 있지만, 실제 값을 출력시 원본 객체와 다른 값을 출력한다. int a = 123456789; float b = (float\u0026amp;)a; } // -------안전도 분류(데이터 손실) -------- { // 3. 안전한 타입 변환 // 업캐스팅 하는 경우 (char -\u0026gt; short -\u0026gt; int) int a = 123456789; __int64 b = a; } { // 4. 안전하지 않은 타입 변환 // 의미가 항상 100% 보장되지 않는 경우 // 타입이 다르거나, 다운캐스팅 하는 경우 int a = 123456789; float b = a; short c = a; } // -------의도에 따른 분류 -------- { // 5. 암시적 타입 변환 // 타입 반환 규칙에 따라서 자동 타입 변환 int a = 123456789; float b = a; } { // 6. 명시적 타입 변환 int a = 123456789; float b = (float)a; } return 0; } ","permalink":"http://localhost:1313/_wiki/%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98/","summary":"멀끔한 정리는 항상 좋다.","title":"cpp 타입 변환"},{"content":"malloc()이 반환하는 값은 void* 타입이다. 사실 할당하고 데이터의 시작 주소를 반환하긴 하지만, 사실은 내부적으로 헤더값이 있어, 방금 할당한 메모리 공간에 대한 메타 정보를 가지고 있다. ","permalink":"http://localhost:1313/_wiki/free%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%A0%EB%8B%B9%EC%9D%84-%ED%95%B4%EC%A0%9C%ED%95%98%EB%8A%94%EA%B0%80/","summary":"malloc()이 반환하는 값은 void* 타입이다. 사실 할당하고 데이터의 시작 주소를 반환하긴 하지만, 사실은 내부적으로 헤더값이 있어, 방금 할당한 메모리 공간에 대한 메타 정보를 가지고 있다. ","title":"c/cpp free는 어떻게 할당을 해제하는가"},{"content":"Post 엔티티 @Entity public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String title; private String content; @OneToMany(mappedBy = \u0026#34;post\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) private List\u0026lt;Comment\u0026gt; comments = new ArrayList\u0026lt;\u0026gt;(); } Comment 엔티티 @Entity public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;post_id\u0026#34;) private Post post; } 일반적으로 이렇게 작성하셨으면, 실제 데이터베이스에는 아래처럼 테이블이 생성됩니다.\nPost 테이블 컬럼 이름 데이터 타입 제약 조건 id BIGINT PRIMARY KEY, AUTO_INCREMENT title VARCHAR(255) NOT NULL content TEXT Comment 테이블 컬럼 이름 데이터 타입 제약 조건 id BIGINT PRIMARY KEY, AUTO_INCREMENT content TEXT post_id BIGINT FOREIGN KEY, NOT NULL 연관관계의 주인 연관관계 주인을 설정한다는건 외래키를 어디에 두는지 설정하는거고. mappedBy를 설정한다는건 외래키를 가지고 있는 쪽이 아니라, 반대쪽(코멘트쪽!)에 있는 엔티티가 주인이라는 것입니다. DB관점에서 생각해보면,\npost_id가 3번인 코멘트를 찾아라! 와 같이 질문하는 상황이 맞겠죠? (여기를 가장 헷갈려하시는 것 같아요)\n예를들어 만약 그럴일 없겠지만, Post에 Comment의 외래키를 일대다로 가지고 싶다면, 외래키의 배열을 가지고 있어야 하는 겁니다.\n1번 포스트에 [3번코멘트, 4번코멘트, 5번 코멘트] 이런식으로요.\n이러한 경우 post를 온전히 조회하려면, 3번 4번 5번 코멘트를 각각 조회해야합니다.(물론 in 쿼리로 한번에 조회할 수 있지만, 비유적인 상황이니까 ..)\n결론적으로 1번 코멘트 찾아라!, 2번 코멘트 찾아라!, 3번 코멘트를 찾아라! 와 같은 어색한 상황이 생기게 됩니다.\n그래서 일반적으로 연관관계의 주인, 즉 외래키를 위와 같이 정하는 것 입니다.\nN + 1 문제 그렇다면, 기본적으로 연관관계를 설정해두면 조회가 두번 발생한다는게 자연스럽게 이해가 되실겁니다.\n\u0026ldquo;1번 Post를 찾아줘!\u0026rdquo;, \u0026ldquo;1번 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo; 이렇게 두번의 쿼리가 발생하게 되는데요.\n여기서 문제는 여러건의 Post를 조회할 때 발생합니다.\n\u0026ldquo;Post 5개 찾아줘!\u0026rdquo;\n\u0026ldquo;첫 번째 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo;\n\u0026ldquo;두 번째 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo;\n\u0026ldquo;세 번째 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo;\n\u0026ldquo;네 번째 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo;\n\u0026ldquo;다섯 번째 Post의 id를 외래키로 가지고 있는 Comment를 찾아줘!\u0026rdquo;\n이렇게 총 (5 + 1) 번의 쿼리가 발생하게 됩니다.\nSELECT c.id, c.content, c.post_id FROM Comment c WHERE c.post_id = 1; SELECT c.id, c.content, c.post_id FROM Comment c WHERE c.post_id = 2; ... SELECT c.id, c.content, c.post_id FROM Comment c WHERE c.post_id = 5; 해결방법 1. fetchType.LAZY 사실 이러한 상황은 fetchType의 기본값인 EAGER 때문에 발생합니다.\nEAGER는 즉시로딩이라는 뜻으로, Post를 조회할 때 Comment도 같이 조회하겠다는 의미입니다. (정확하게는 연관된 엔티티를 같이)\n반면에 LAZY는 지연로딩이라는 뜻으로, Post를 조회할 때 Comment는 조회하지 않겠다는 의미입니다.\n여기서 프록시 객체가 사용되는데요, 프록시는 \u0026ldquo;우회한다\u0026quot;는 뜻으로, 디비에서 바로 조회하는 대신 프록시 객체를 먼저 조회하고, 실제로 사용할 때 디비에서 조회하는 방식입니다.\n조금 더 직관적으로는 \u0026ldquo;가짜 객체를 만들어두고, 실제로 사용할 때 디비에서 조회한다\u0026rdquo; 라고 생각하시면 됩니다.\n조금 과격한 비유이지만, 가짜 코멘트들을 만들어두고 포스트에 점찍어서 코멘트를 쓸때 실제 디비에서 조회하는 방식이라고 생각하시면 됩니다.\n물론 이건 근본적인 해결책은 아니지만, 정말 필요할 경우에만 디비로 쿼리가 나가니 실제로는 N + 1번 쿼리가 발생하지 않는 정도로 퉁칠수 있는 상황이 있습니다.\n\u0026lsquo;의도치 않게\u0026rsquo; N+1로 쿼리가 발생하는 \u0026lsquo;상황\u0026rsquo;이 문제라면, FetchType.LAZY로 설정하는 것도 하나의 해결책이 될 수 있습니다.\n물론 근본적인 이야기를 하자면, 실제로 \u0026lsquo;모든 연관된 엔티티에 대한 참조가 일어난다면\u0026rsquo; FetchType.LAZY는 절대 해결책이 될 수 없습니다. 다만, 이건 Big O 표기법과 마찬가지로, 최악의 경우를 가정했을때 N + 1 문제가 발생한다는 것 입니다. 그래서 많이들 하시는 실수가, 해당 엔티티의 참조가 충분히 간헐적이고 유동적일 수 있는데 모두 Fetch Join을 사용해버리면 오히려 리소스의 낭비가 발생할 수 있습니다. 이러한 경우 실제 연관 엔티티의 참조가 필요한 경우가, 한 번 더 쿼리가 필요한 시점이라고 인지한다면 Fetch join을 사용하는 것 보다 훨씬 효율적일 수 있습니다.\n해결방법 2. fetch join 사실 이게 근본적인 해결책인데, 여기서부터는 조금 더 정확한 쿼리를 작성해서 해결하는 방법입니다.\npublic interface PostRepository extends JpaRepository\u0026lt;Post, Long\u0026gt; { @Query(\u0026#34;SELECT p FROM Post p JOIN FETCH p.comments WHERE p.id = :postId\u0026#34;) Post findPostWithComments(@Param(\u0026#34;postId\u0026#34;) Long postId); } 쿼리를 아까처럼 풀면, (다소 의역) \u0026ldquo;Post를 조회하면서, Post테이블과 Comment을 붙여서 코멘트도 같이 조회해줘!\u0026rdquo; 라고 요청하는 쿼리입니다.\nPost 테이블 id title content 1 First Post This is the first post. 2 Second Post This is the second post. 3 Third Post This is the third post. Comment 테이블 id content post_id 1 First comment 1 2 Second comment 1 3 Third comment 2 조인된 결과 Post.id Post.title Post.content Comment.id Comment.content 1 First Post This is the first post. 1 First comment 1 First Post This is the first post. 2 Second comment 2 Second Post This is the second post. 3 Third comment 이렇게 쿼리를 작성하면, Post와 Comment를 조인해서 조회하게 되므로, N + 1 문제가 발생하지 않고 단건의 쿼리로 조회가 가능합니다.\n","permalink":"http://localhost:1313/_wiki/jpa-%EC%97%94%EC%81%A0%EB%9F%AC%EC%8A%A4%EC%9D%BC/","summary":"Post 엔티티 @Entity public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String title; private String content; @OneToMany(mappedBy = \u0026#34;post\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) private List\u0026lt;Comment\u0026gt; comments = new ArrayList\u0026lt;\u0026gt;(); } Comment 엔티티 @Entity public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;post_id\u0026#34;) private Post post; } 일반적으로 이렇게 작성하셨으면, 실제 데이터베이스에는 아래처럼 테이블이 생성됩니다.","title":"N + 1 문제와 해결방법 🧊️"},{"content":"블로그 글을 퉁치려는 얄팍한 시도 근데 진짜 바쁘니까.. [[JPA-엔쁠러스일]]\n","permalink":"http://localhost:1313/_wiki/%ED%8A%9C%ED%84%B0%EB%A7%81-%EC%A7%88%EC%9D%98-%EC%9D%91%EB%8B%B5-%EB%AA%A8%EC%9D%8C/","summary":"블로그 글을 퉁치려는 얄팍한 시도 근데 진짜 바쁘니까.. [[JPA-엔쁠러스일]]","title":"튜터링 질의 응답 모음 🧊️"},{"content":"Intro 😃 프로토콜의 집합을 프로토콜 스위트라고 합니다. 프로토콜 스위트의 다양한 프로토콜이 서로 어떻게 연관되어 있으며 수행할 작업을 어떻게 나누는지 명시하는 설계를 아키텍처 또는 참조 모델이라고 합니다. TCP/IP는 인터넷 아키텍처를 구현하는 프로토콜 스위트이며, ARPANET 참조 모델(ARM)에서 유래했습니다.\nClark는 인터엣 아키텍처의 주된 목표가 \u0026ldquo;기존 상호 연결된 네트워크의 다중화된 활용을 위한 효과적인 기술을 개발하는 것\u0026quot;이라고 설명한다. 즉 이 진술의 핵심은 인터넷 아키텍처가 여러 개별 네트워크를 상호 연결할 수 있어야 하고, 그 결과 생성된 상호 연결된 네트워크에서 여러 활동이 동시에 실행될 수 있어야 한다는 것이다.\n네트워크 또는 게이트웨이 손실에도 불구하고 인터넷 통신은 계속되어야 합니다. 인터넷은 여러 유형의 통신 서비스를 지원해야 합니다. 인터넷 아키텍처는 다양한 네트워크를 수용해야 합니다. 인터넷 아키텍처는 자원의 분산 관리가 가능해야 합니다. 인터넷 아키텍처는 비용 효율적이어야 합니다. 인터넷 아키텍처는 호스트 연결을 쉽게 허용해야 합니다. 인터넷 아키텍처에서 사용되는 자원은 책임져야 합니다. ","permalink":"http://localhost:1313/_wiki/introduction/","summary":"Intro 😃 프로토콜의 집합을 프로토콜 스위트라고 합니다. 프로토콜 스위트의 다양한 프로토콜이 서로 어떻게 연관되어 있으며 수행할 작업을 어떻게 나누는지 명시하는 설계를 아키텍처 또는 참조 모델이라고 합니다. TCP/IP는 인터넷 아키텍처를 구현하는 프로토콜 스위트이며, ARPANET 참조 모델(ARM)에서 유래했습니다.\nClark는 인터엣 아키텍처의 주된 목표가 \u0026ldquo;기존 상호 연결된 네트워크의 다중화된 활용을 위한 효과적인 기술을 개발하는 것\u0026quot;이라고 설명한다. 즉 이 진술의 핵심은 인터넷 아키텍처가 여러 개별 네트워크를 상호 연결할 수 있어야 하고, 그 결과 생성된 상호 연결된 네트워크에서 여러 활동이 동시에 실행될 수 있어야 한다는 것이다.","title":"TCP/IP Illustrated 📚"},{"content":"14. 막간 : 메모리 관리 API stack : 프로그래머를 위해, 컴파일러에 의해 자동으로 할당과 해제가 이루어진다(automatic). void func() { int x; } func()가 호출되면 스택에 공간을 확보하고, func()가 종료되면 스택에서 공간을 해제한다.\nheap : 프로그래머가 직접 할당과 해제를 해야한다.\nvoid func() { int *x = (int *) malloc(sizeof(int)); free(x); } malloc()을 통해 메모리를 할당하고, free()를 통해 메모리를 해제한다.\nheap에 데이터를 저장하고, func()의 스택에는 heap에 저장된 데이터의 주소를 저장한다.\nstack만큼 명시적이고 단순하기는 하지만, 쓰임새가 다양하고 실수를 할 여지가 많다.\n14.2 malloc()함수 malloc()은 메모리를 할당하는 함수이다.\n약간 더 자세하게 설명하면, malloc()은 힙에 요청할 공간의 크기를 받아 성공하면 할당한 메모리의 주소를 반환하고, 실패하면 NULL을 반환한다.\n참고로 sizeof()는 연산자의 관점에서 바라보면 조금 더 적절한 부분이 있다.\nsizeof()는 컴파일 시간에 계산되는 연산자이다. 예를들어 int *x = malloc(sizeof(int) * 10); printf(sizeof(x)). 이 코드에서는 4 또는 8값이 반환된다. 즉 동적으로 할당된 메모리의 크기가 아닌, 포인터의 크기를 반환하기 때문이다. 14.3 free()함수 free()는 malloc()을 통해 할당된 메모리를 해제하는 함수이다.\nfree()를 통해 메모리를 해제 할 때 할당된 영역의 크기를 알 필요가 없다. (라이브러리가 알아서 처리한다.)\n14.4 흔한 오류 | 기본적으로 malloc()과 free()를 사용할 때 자주 오류가 발생하는데, 특히 가비지컬렉터가 없는 경우에 더욱 신경써야 한다.\n메모리 할당 잊어버리기 많은 루틴은 자신이 호출되기 전에 필요한 메모리가 이미 할당되었다고 가정한다. 이런 경우 메모리를 할당하지 않고 사용하려고 할 때, 프로그램은 세그멘테이션 폴트를 발생하고 종료된다.\n| 사실 이러한 경우는 너무 흔해서 조금 더 안전한 루틴이나 라이브러리를 사용하는 것이 좋다.\n버퍼 오버플로우 : 충분하지 않은 메모리 할당 프로그램이 할당된 메모리보다 더 많은 데이터를 쓰려고 할 때, 문제 없이 동작하는 것 처럼 보이지만, 실제로는 할당받지 않은 메모리를 사용하게 된다. 다른 변수나 중요한 데이터를 덮어쓰는 경우가 발생할 수 있고, 보안적으로 매우 위험하다.\n할당받은 메모리 초기화 하지 않기 malloc()을 통해 할당받은 메모리는 초기화되지 않는다. 나중에 uninitialized read가 발생할 수 있다. 마찬가지로 공격자의 데이터를 읽을 수 있게 되는 보안적인 문제가 발생할 수 있다.\n할당받은 메모리 해제하지 않기 free()를 호출하지 않으면, 메모리 누수가 발생한다. 이는 프로그램이 실행되는 동안 메모리 사용량이 계속 증가하게 되고, 결국 프로그램이 더 이상 실행되지 않게 된다.\n메모리 사용이 끝나기 전에 메모리 해제하기 dangling pointer는 이미 해제된 메모리를 사용하려고 할 때 발생한다. 이는 프로그램이 종료되거나, 다른 메모리를 할당받을 때 발생할 수 있다.\n두 번 해제하기 double free는 이미 해제된 메모리를 다시 해제하려고 할 때 발생한다. 이는 프로그램이 종료되거나, 다른 메모리를 할당받을 때 발생할 수 있다.\nfree() 잘못 호출하기 14.5 운영체제의 지원 malloc()과 free()는 라이브러리 함수이기 때문에, 시스템콜을 직접적으로 언급하지는 않았지만, 라이브러리 자체는 당연히 시스템콜을 사용한다.\nbrk, sbrk 시스템콜을 사용하고 있지만, 직접적으로 사용하지는 않는다.\n15. 주소 변환의 원리 LDE에서 프로그램이 하드웨어에 의해 직접 실행되면서도, 약간의 하드웨어 지원을 받은 운영체제의 개입으로 어떻게 가상화를 제공하면서도, 프로그램을 방해하지 않는지에 대해서 알아봤다, 메모리 가상화에도 마찬가지로, 비슷한 동작을 알아본다.\n메모리 가상화에서도 제어와 효율성을 동시에 추구한다.\n제어 : 프로그램이 자기 자신의 메모리 이외에 다른 메모리에 접근하지 못하는것을 운영체제가 보장한다.\n효율성 : 하드웨어의 지원으로 하여금, 다양한 자원을 사용하여 가상화를 효율적으로 수행할 수 있도록 한다.\n여기서 다룰 기법은 hardware-based address translation, 짧게는 address translation이다.\naddress translation은 프로그램이 메모리에 접근할 때, 가상 주소를 물리 주소로 변환하는 기법이다.\n그리고 해당 기법을 다루며 달성하고자 하는 목표는 프로그램이 자신의 전용 메모리 공간을 가지고 있다고 믿게 하면서도, 실제로는 물리 메모리를 공유하도록 하는 것이다.\n15.1 가정 CPU 가상화 부분에서 LDE에 대한 이야기를 했었는데, 요약하자면 대부분의 프로그램은 하드웨어에서 직접 실행되면서, 프로세스가 시스템콜을 호출하거나 타이머 인터럽트가 발생하면, 하드웨어는 커널로 제어권을 넘기고, 운영체제가 적절한 작업을 수행한다. 즉 실행 프로그램에 문제가 발생하지 않도록 적절한 시점에 개입해서 하드웨어 지원을 받아 역할을 수행한다는 것이다.\nLDE에서 위와 같은 것들을 달성하기 위해서, 중요한 포인트를 효율성과 제어라고 할 수 있었다.\n메모리 가상화도 마찬가지로, 가상화를 제공하는 목표는 효울성과 제어를 달성하기 위함이다.\n물론 이런것들을 달성하려면 적절한 하드웨어의 지원이 필요하다.\n이전 장에서와 마찬가지로, 처음에는 단순 하드웨어의 지원(레지스터만 사용하는 정도)에서 TLB, 페이지 테이블등 점차 복잡한 하드웨어 지원을 공부하는 방식으로 진행한다.\n마지막으로 메모리 가상화 관점에서 효율성과 제어의 목표를 각각 알아보면 다음과 같다.\n효율성 : 메모리 가상화는 물리적 메모리를 효율적으로 사용할 수 있도록 해야한다. 제어 : 메모리 가상화는 프로세스가 다른 프로세스의 메모리에 접근하지 못하도록 해야한다. 결론, 핵심 질문 메모리 가상화를 배우는 시작 장에서 핵심 질문은 다음과 같다. 어떻게 효율적이고 유연하게 메모리를 가상화할 수 있을까?\n먼저 다룰 기법은 하드웨어 기반 주소 변환(hardware-based address translation), 그냥 짧게 주소 변환(address translation)이라고도 한다.\n핵심은 그냥 프로그램의 모든 메모리 참조를 실제 메모리 주소로 재지정하기 위해서 하드웨어가 주소를 변환하는 것이다.\n하드웨어만으로는 메모리 가상화를 제공 할 수 없다. 운영체제가 실제로 메모리의 빈공간과 사용중인 공간을 알고 관리해야 하며, 메모리 사용을 제공해야한다.\n그리고 모든 프로그램이 자신의 전용 메모리 공간을 가지고 있다는 환상을 제공해야 한다.\n15.1 가정 스케줄링을 배울 때 문제를 쉽게 이해하기 위해서 가정을 통해 고려 요인을 단순화 했듯이, 여기서도 가정을 통해 많은 제한사항을 두고 시작한다.\n먼저 사용자 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정한다. 그리고 주소 공간의 크기가 너무 크지 않다고 가정한다. 마지막으로, 각 주소공간의 크기가 같다고 가정한다. 쉬워보이지만, 가정을 완화하는 과정에서 머리가 깨질 예정! 🤪\n15.2 사례 void func() { int x = 3000; x = x + 3; } 위 코드를 x86 어셈블리로 변환하면 다음과 같다. movl 0x0(%ebx), %eax; // 0 + ebx를 eax에 저장 addl $3, %eax; // eax에 3을 더한다. movl %eax, 0x0(%ebx); // eax를 ebx에 저장 이 명령어가 실행되면 프로세스 관점에서 아래와 같은 메모리 접근이 발생한다.\n(출처 : OSTEP)\n주소 128의 명령어를 반입\n이 명령어 실행(주소 15kb에서 탑재)\n주소 132의 명령어를 반입\n이 명령어 실행 (메모리 참조 없음)\n주소 135의 명령어를 반입\n이 명령어 실행 (주소 15kb에 저장)\n지금 시점의 프로그램 관점에서 주소공간은 0부터 16kb까지의 주소공간을 가지고 있다. (프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 한다.)\n그러나 우리는 메모리 가상화를 위해 물리 메모리 주소 0이 아닌 다른곳에 위치시키고 싶다.\n이걸 실제로 프로세스 모르게 어떻게 재배치 하냐가 메모리 가상화의 핵심이다.\n일단 위의 그림처럼 간단한 상황이 있을 수 있다.\n15.3 동적 재배치 이 문제에 대한 첫 번째 해결 사례는 동적 재배치(dynamic relocation), 또는 base and bounds로 불리는 방법이.\n이 방법은 프로세스가 시작될 때, 운영체제가 프로세스의 주소 공간을 위한 두 가지 레지스터(base, bounds)를 설정한다.\nbase : 프로세스에 할당된 메모리의 시작 주소를 가리키는 레지스터\nbounds : 프로세스에 할당된 마지막 주소를 가리키는 레지스터\n그리고 아주 간단한 가상화 공식을 얻을 수 있다! physical address = virtual address + base\n그러면 자연스럽게 bounds는 보호를 위해 쓰이며, 이 메모리 주소에 대한 참조가 유효한지 확인한다.\n결론적으로아래와 같은 간단한 로직으로 동작한다.\nif (virtual address \u0026lt; 0 || virtual address \u0026gt; bounds) { raise an error(fault); } else { physical address = virtual address + base; } 15.4 하드웨어 지원 : 요약 위의 로직을 달성하기 위해서 필요한 하드웨어 지원은 다음과 같다.\n커널 모드 : 유저모드의 프로세스가 특권 연산을 수행할 수 없도록 한다. base, bounds 레지스터 : 주소 변환과, 번위 검사를 위해 CPU당 두 개의 레지스터가 필요하다. 가상 주소를 변환하고 범위 안에 있는지 확인하는 능력 : 주소 변환과 검사를 위한 회로가 필요하다. 베이스/바운드를 갱신하기 위한 privileged instruction : 프로그램 시작 전에 이를 설정할 수 있어야 한다. 예외 핸들러 등록을 위한 privileged instruction : 범위를 벗어난 주소에 접근할 때, 예외 처리 코드를 하드웨어에 등록할 수 있어야 한다. 예외 발생 기능 : 범위를 벗어난 주소에 접근할 때, 예외를 발생시킬 수 있어야 한다. 15.5 운영체제 이슈 위와 같은 하드웨어 지원을 받는다고 하더라도, 운영체제는 여전히 몇 가지 문제를 해결해야 한다.\n먼저 베이스-바운드를 구현하기 위해서 운영체제가 반드시 개입해야하는 시점이 세가지가 있다.\n프로그램이 시작될 때 : 운영체제는 주소 공간이 저장될 메모리 공간을 찾아야 한다. 프로그램이 종료될 때 : 운영체제는 사용된 메모리를 회수해야 한다. 컨텍스트 스위칭 : 컨텍스트 스위칭이 일어날 때, 프로세스별 자료구조에 베이스-바운드 레지스터 값을 저장해야 한다. (참고로 이 프로세스별 자료구조를 PCB라고 한다.) 당연히 새로 실행되는 프로세스의 베이스-바운드 레지스터 값을 로드해야 한다. 부팅시 LDE + 동적 재배치 ![부팅시 LDE + 동적 재배치]((https://github.com/SmallzooDev/OSTEP/assets/121675217/9f3e8fba-2003-4210-9c40-10476366983d)\n프로세스 실행중 15.6 정리 를 따로 하기보다는 여기서 생겨난 문제를 알아본다.\n기본적으로 동적 재배치는 비효율적이다.\n예를들어 힙이 아주 작은 프로세스라도 동일한 크기의 베이스-바운드를 가지고 있어야 한다.\n그렇게 낭비되는 메모리를 내부 단편화라고 한다.\n메모리의 실제 이용률을 높이기 위해서 더 나은 방법이 필요한데, 첫 번째는 base and bounds를 일반화 하는 것인데 이것을 segmentation이라고 한다.\n","permalink":"http://localhost:1313/_wiki/week-05/","summary":"14. 막간 : 메모리 관리 API stack : 프로그래머를 위해, 컴파일러에 의해 자동으로 할당과 해제가 이루어진다(automatic). void func() { int x; } func()가 호출되면 스택에 공간을 확보하고, func()가 종료되면 스택에서 공간을 해제한다.\nheap : 프로그래머가 직접 할당과 해제를 해야한다.\nvoid func() { int *x = (int *) malloc(sizeof(int)); free(x); } malloc()을 통해 메모리를 할당하고, free()를 통해 메모리를 해제한다.\nheap에 데이터를 저장하고, func()의 스택에는 heap에 저장된 데이터의 주소를 저장한다.\nstack만큼 명시적이고 단순하기는 하지만, 쓰임새가 다양하고 실수를 할 여지가 많다.","title":"Week-05"},{"content":"이사 후 사고싶은 물품 정리 커튼이랑 블라인드를 사기로 한 생각은 맞는 것 같다 책상방에 등에 거치용 행거를 사면 알맞을것 같다(등쪽에) 👉 클릭 아직은 냄세가 익숙치 않아서 초반 사용을 위한 디퓨저를 두고싶다. (이건 민숙이랑 같이 고르고 싶다) 러그는 있으면 좋을 것 같다, 조금 큰사이즈에 나무색깔을 거실에, 적당한 사이즈의 남색 러그를 침실에. 리노는 벌써 가스쪽을 돌아다니는데, 우리가 없어도 완전 안심할 수 있게 뭔가 안전장치가 필요하다. 밤에 형광등인게 생각보다 분위기가 별로인 것 같다, 따뜻한 색 조명을 침실과 거실에 두고싶다.(가능하면 벽걸이로) 👉 이런거 여러개? 팬트리를 잘 활용해야 할 것 같다 (공구, 리노음식-우리음식, 청소도구, 세탁도구) 수납함은 가능하면 책상방에 행거 아래에 두면 좋을 것 같다. 화장대는 여기 클릭 조금 더 돈을 쓴다면 이게 참 예쁘네 👉 클릭 ","permalink":"http://localhost:1313/_wiki/%EC%9D%B4%EC%82%AC/","summary":"이사 후 사고싶은 물품 정리 커튼이랑 블라인드를 사기로 한 생각은 맞는 것 같다 책상방에 등에 거치용 행거를 사면 알맞을것 같다(등쪽에) 👉 클릭 아직은 냄세가 익숙치 않아서 초반 사용을 위한 디퓨저를 두고싶다. (이건 민숙이랑 같이 고르고 싶다) 러그는 있으면 좋을 것 같다, 조금 큰사이즈에 나무색깔을 거실에, 적당한 사이즈의 남색 러그를 침실에. 리노는 벌써 가스쪽을 돌아다니는데, 우리가 없어도 완전 안심할 수 있게 뭔가 안전장치가 필요하다. 밤에 형광등인게 생각보다 분위기가 별로인 것 같다, 따뜻한 색 조명을 침실과 거실에 두고싶다.","title":""},{"content":"int arr[10] = {1,2,3,4,5,6,7,8,9,10}; int *p = arr; cout \u0026lt;\u0026lt; p[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p[5] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr[5] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(p+5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(arr+5) \u0026lt;\u0026lt; endl; int arr2[2][2] = {{1,2},{3,4}}; int** pp = (int**)arr2; // error : 2차원 배열은 다중 포인터와 다름 int** pp = (int**)arr2; // error : 2차원 배열은 다중 포인터와 다름 : 이 부분에서 에러가 나는 이유.\n첫 *(포인터 연산)은 arr2[0]의 주소값을 가리킨다.\n두번째 *(포인터 연산)은 arr2[0][0]의 value를 가리킨다.\n포인터 연산은 해당 메모리 주소로 가서 값을 참조하는것이다.\n위의 예시에서 다중 포인터의 의도에서는 첫번째 포인터 연산을 끝냈을 때, 포인터형 변수의 값이라 인지하고 값을 참조한다. 즉 첫 포인터 연산 이후 참조한 값은 int형 변수의 주소값이다.\n하지만 실제로 해당 주소칸에 존재하는 값은 int형 변수의 값이다.\n여기서 해당 값을 주소로 생각하고 참조하려다 보니 에러가 발생한다.\nPointerCheatSheat\n","permalink":"http://localhost:1313/_wiki/pointer-%EC%A7%80%EC%98%A5/","summary":"int arr[10] = {1,2,3,4,5,6,7,8,9,10}; int *p = arr; cout \u0026lt;\u0026lt; p[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p[5] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr[5] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(p+5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(arr+5) \u0026lt;\u0026lt; endl; int arr2[2][2] = {{1,2},{3,4}}; int** pp = (int**)arr2; // error : 2차원 배열은 다중 포인터와 다름 int** pp = (int**)arr2; // error : 2차원 배열은 다중 포인터와 다름 : 이 부분에서 에러가 나는 이유.","title":"포인터 지옥😢"},{"content":" int main() { const char* test1 = \u0026#34;Hello World\u0026#34;; // test1[0] = \u0026#39;A\u0026#39;; // error: assignment of read-only location \u0026#39;*(test1 + 0)\u0026#39; const char test2[] = \u0026#34;Hello World\u0026#34;; test2[0] = \u0026#39;A\u0026#39;; // ok } 배열 이름은 배열의 시작 주소를 가리키는 상수 포인터이다.\n인덱스 연산자 []는 배열 요소에 접근할 때 사용되며, 이는 사실 포인터 연산으로 구현된다.\ntest1[i]는 내부적으로 *(test1 + i)로 변환된다.\n여기서 arr은 배열의 첫 번째 요소의 주소를 가리키는 포인터로 간주되며, i는 인덱스이다.\n","permalink":"http://localhost:1313/_wiki/pointer-array-%ED%97%B7%EA%B0%88%EB%A6%B4%EB%95%8C-%ED%8C%81/","summary":"int main() { const char* test1 = \u0026#34;Hello World\u0026#34;; // test1[0] = \u0026#39;A\u0026#39;; // error: assignment of read-only location \u0026#39;*(test1 + 0)\u0026#39; const char test2[] = \u0026#34;Hello World\u0026#34;; test2[0] = \u0026#39;A\u0026#39;; // ok } 배열 이름은 배열의 시작 주소를 가리키는 상수 포인터이다.\n인덱스 연산자 []는 배열 요소에 접근할 때 사용되며, 이는 사실 포인터 연산으로 구현된다.\ntest1[i]는 내부적으로 *(test1 + i)로 변환된다.\n여기서 arr은 배열의 첫 번째 요소의 주소를 가리키는 포인터로 간주되며, i는 인덱스이다.","title":""},{"content":"int value = 10; int\u0026amp; reference = value; int* pointer = \u0026amp;value; PrintInfoByRef(*pointer); PrintInfoByPointer(\u0026amp;reference); ","permalink":"http://localhost:1313/_wiki/pointer-reference-%ED%97%B7%EA%B0%88%EB%A6%B4%EB%95%8C-%ED%8C%81/","summary":"int value = 10; int\u0026amp; reference = value; int* pointer = \u0026amp;value; PrintInfoByRef(*pointer); PrintInfoByPointer(\u0026amp;reference); ","title":"아주 간단한 팁!"},{"content":"11. CPU 가상화에 대한 마무리 대화 간단한 Wrapup 대화를 진행한다. 이 정책 전쟁은 영원히 계속 될 것처럼 보이네요.\n공학은 원래 그런거라네, 그리고 그것은 또한 권장 사항이야! 관점의 차이지, 나는 개인적으로 실용적인 것이 좋다고 생각하네. 실용주의자들은 모든 문제가 깔끔하고 쉬운 해결책이 있다고 생각하지 않아.\n12. 메모리 가상화에 관한 대화 수면 부족, 그것은 간단하게 해결할 수 있지. 좀 덜 놀고 더 자도록 하게. 가상 메모리를 이해하기 위해서는 여기서 부터 시작해야 하네. 사용자 프로그램이 생성하는 모든 주소는 가상주소이지. 운영체제는 각 프로세스에게 단지 환상을 제공하지. 구체적으로 프로세스가 자신만의 커다란 전용 메모리를 가진다는 환상 을 제공하는 것이지. 하드웨어로부터 약간의 도움을 얻어 운영체제는 이 가장된 가상 주소를 실제 물리 주소로 변환하고 원하는 정보의 위치를 찾을 수 있네.\n사용하기 쉬운 시스템을 제공하기 위하여 일세, 운영체제는 각 프로세스에게 코드와 데이터를 저장할 수 있는 대용량의 연속된 주소 공간(address space) 을 가지고 있다는 시각을 제공하고자 하는거지, 프로그래머는 이 변수를 어디에 저장해야 하는 거지?\u0026ldquo;와 같은 걱정은 하지 않아도 된다는 거야. 프로그램의 가상 주소 공간이 크고 변수 등을 위한 많은 공간을 가지고 있기 때문이지. 만일 코드 와 데이터를 작고 붐비는 공간에 넣을 걱정을 해야만 했다면 프로그래머로서의 인생은 더 힘들어졌을 거야.\n13. 주소 공간의 개념 13.1. 초기 시스템 메모리 관점에서, 초기 컴퓨터는 많은 개념을 가지고 있지 않았다.\n운영체제는 메모리에 상주하는 프로그램(당시의 운영체제)를 올리고, 남은 메모리를 사용자 프로그램에게 할당했다.\n13.2 멀티프로그래밍과 시분할 멀티프로그래밍이란, CPU가 프로그램을 번갈아가며 실행하는 것을 의미한다.\n그리고 특히 대화식(interactive) 개념이 중요한 요구 사항이 되었다.\n초기에는 엉성하게도, 프로세스에게 모든 메모리 접근 권한을 주고 실행하다가 중지하면, 다른 프로그램을 메모리에 올리는 방식으로 운영체제가 동작했다.\n당연히 느리다\n그래서 메모리에 여러 프로세스를 올리면, 보호의 문제가 대두되게 된다.\n특히나 현대의 프로그램을 생각해보면 힙과 같이 동적으로 메모리를 할당하는데, 이러한 상태로 해당 프로그램을 두게 하면 너무 위험하다.\n13.3 주소 공간 이러한 문제를 해결하기위해, 여러 프로세스가 메모리에 올라갔음에도, 사용하기 쉬운 메모리 개념을 만들어야 했고,\n그것이 바로 주소 공간이다.\n결론적으로 운영체제는 가상 주소 공간을 제공하고, 프로세스는 이 가상 주소 공간을 사용한다.\n이렇게 하는것을 virtualizing memory라고 한다.\n13.4 목표 가상화를 통해 얻고 싶은 목표는 다시 다음과 같다.\n투명성(transparency) : 사용자는 가상화를 인지하지 않아야 한다. 효율성(efficiency) : 가상화는 비용이 적어야 한다. 보호(protection) : 프로세스는 서로의 메모리에 접근할 수 없어야 한다. ","permalink":"http://localhost:1313/_wiki/week-04/","summary":"11. CPU 가상화에 대한 마무리 대화 간단한 Wrapup 대화를 진행한다. 이 정책 전쟁은 영원히 계속 될 것처럼 보이네요.\n공학은 원래 그런거라네, 그리고 그것은 또한 권장 사항이야! 관점의 차이지, 나는 개인적으로 실용적인 것이 좋다고 생각하네. 실용주의자들은 모든 문제가 깔끔하고 쉬운 해결책이 있다고 생각하지 않아.\n12. 메모리 가상화에 관한 대화 수면 부족, 그것은 간단하게 해결할 수 있지. 좀 덜 놀고 더 자도록 하게. 가상 메모리를 이해하기 위해서는 여기서 부터 시작해야 하네. 사용자 프로그램이 생성하는 모든 주소는 가상주소이지.","title":"Week-04 📚"},{"content":"네트워크 기본 개념Cheatsheet 🦉 from 외워서 끝내는 네트워크 핵심이론 OSI 7 Layer : 의존적 관계가 성립하는 (Layered, 상위 계층이 하위 계층에 의존) 프로토콜을 계층적으로 나열한 것 Protocol suite, Protocol Stack Protocol Suite, Protocol Stack : 여러 프로토콜의 집합 Network 성능 지표 throughput : 처리율 (bps, Mbps, Gbps 등), 실시간성을 띄며, 평균값을 보통 지표로 사용\nbandwidth : 대역폭, 통신망이 전송할 수 있는 데이터의 양, 단위는 bps\npacket loss : 패킷 손실률, 패킷이 전송 중 소멸되는 비율\nOSI \u0026amp; Layer와 식별자 알기쉽게 Bottom-up으로 다룬다. 개인적으로 개발 네트워크 서적이 Top-down으로 설정되어있는데, 개발자입장에서는 편하지만, 그냥 네트워크를 처음 배우는 입장에서는 이해가 힘든 것 같다. 요즘 네트워크 서적이나 강의는 보통 그래서 Bottom-up식으로 앞부분은 교양처럼 듣고, 뒤에 힘을 주는 방식으로 되어 있는 것 같다.\nHost Host : Computer + Network End-point : 네트워크의 이용 주체 (server, client 는 네트워크 이용 주체의 역할 구분, 구분하지 않으면 peer) Switch : 네트워크 자체를 이루는 host (Infra) Router : l3 스위치 IPS : 보안 Switch가 하는 일 네트워크를 고속도로로 비유하면, 고속도로망을 지나가다 교차로를 마주하고 경로를 선택하게 되는데 그 근거는 이정표이다.\n자동차를 패킷으로 비유 경로 선택의 근거인 이정표가 IP주소이면 L3 스위칭(라우터, 라우팅 테이블), 다른 계층도 마찬가지 스위칭에서 경로별 비용을 Matric에 비유 L2 NIC : Network Interface Card, H/W, MAC주소를 갖는다. (기본적으로는 신호를 프레임으로, 프레임을 신호로 변환)\n프레임을 검출해서 폐기하거나 전달하는 역할도 여기서 다나와 : 남자들의 쇼핑몰 😏\nPacket : 데이터 단위(사실 L2에서는 Frame을 씀 10kb 내외)\nMAC : Ethernet 계층의 48bit 식별자\nL2 Access switch : End-point와 직접 연결되는 스위치(MAC) 주소를 근거로 스위칭\n물리적인 단자 하나당 하나의 인터페이스 그냥 포트라고도 함 Link-up, Link-down : 연결 상태 (와이어샤크 수업이 생각난다..) L2 Distribution switch : L2 스위치를 위한 스위치(VLAN 기능을 제공)\n규모를 감잡기 위해서 l2스위치는 방하나, l2d 스위치는 층하나, 라우터는 건물 하나\nBroadcast : Unicast와는 반대, Broadcast주소라는 매우 특별한 주소가 존재(111111111111111111)\n목적지 주소가 Broadcast 주소이면, 전체 네트워크 모두로 전송 Broadcast이 발생하면, 다른 네트워크가 통신을 못함 Ethernet 프레임 헤더 구조\nPreamble : 7byte, 10101010, 10101010, 10101010, 10101011 : 전송 시작을 알리는 신호 SFD : 1byte, 10101011 : 프레임의 시작을 알리는 신호 Destination MAC Address : 6byte : 목적지 MAC 주소 Source MAC Address : 6byte : 출발지 MAC 주소 Type : 2byte, IP, ARP, RARP, etc (Ethernet Type) Data : 46 ~ 1500byte : 실제 데이터 FCS : 4byte, CRC : 오류 검출을 위한 계산값, 틀리면 버림 L3 IP Address : l3 식별자, 32bit(8bit * 4) 즉 (0 ~ 255).(0 ~ 255).(0 ~ 255).(0 ~ 255)\n. 으로 구분되며 앞의 세개의 숫자는 Network Id, 뒤의 하나의 숫자는 Host Id Packet : L3 IP Packet\nHeader, Payload로 나뉘는데, 이건 상대적인 분류 최대 크기는 MTU (Maximum Transmission Unit) : 특별한 이유가 없다면 1500bytes Encapsulation, Decapsulation\n패킷의 생성, 전달, 소멸\n계층별 데이터 단위 정리 Frame : l1 ~ l2\nPacket : IP에서(~ MTU)\nSegment : TCP에서(~ MSS)\nStream : 소켓에서 (연속적으로 이루어져 있으며, 크기를 정확히 알 수 없음)\nIPv4 Header 형식과 구성요소\nVersion : 버전 IHL : Header Length Type of Service : 서비스의 종류 Total Length : 전체 길이 Identification : 패킷의 식별자 Flags : Fragmentation Fragment Offset : Fragmentation Time to Live : 패킷의 수명 Protocol : 상위 계층 프로토콜 Header Checksum : 헤더의 체크섬 Source Address : 출발지 주소 Destination Address : 목적지 주소 Subnet Mask : 네트워크 주소와 호스트 주소를 구분하는데 사용되는 32bit 값 (1111 1111. 1111 1111. 1111 1111. 0000 0000)\n기본적으로 원래는 클래스를 나눠서 호스트 주소와 네트워크 주소를 구분했었음 a클래스면 앞에 8bit, b클래스면 16bit, c클래스면 24bit 와 같이 사용했는데, 이제는 서브넷 마스크로 구분 비트 and 연산을 통해 네트워크 주소와 호스트 주소를 구분 CIDR : Classless Inter-Domain Routing, 서브넷 마스크를 표기하는 방법\n192.168.0.10/24 와 같이 표기 호스트 주소와 네트워크 주소를 가르는 1의 개수를 표기 클래스 구분은 없지만 예를들어 a클래스면 /8, b클래스면 /16, c클래스면 /24 즉 앞에 n개의 비트만 and 연산을 해서 네트워크 주소를 추출하겠다는 의미 Broadcast IP Address : 네트워크의 모든 호스트에게 데이터를 전송하는데 사용되는 특별한 주소\n네트워크 주소의 마지막 호스트 주소를 Broadcast 주소로 사용 Multicast IP Address : 특정 그룹에 속한 호스트에게 데이터를 전송하는데 사용되는 특별한 주소\nHost 주소로 사용할 수 없는 주소\n0 : 서브넷 주소 255 : Broadcast 주소 1 : Default Gateway 주소(보통은) 참고 : 127.0.0.1 (localhost, loopback 주소) 인터넷 사용 전에 해야 할 설정\nIP 주소 설정 서브넷 마스크 설정 Gateway IP 설정 DNS 설정 귀찮으니까 DHCP를 사용한다.\nDHCP : Dynamic Host Configuration Protocol, 호스트에게 IP 주소를 동적으로 할당하는 프로토콜 (Broadcast로 요청하고, DHCP 서버가 응답, 즉 Broadcast domain에 묶여있어야함)\nDHCP Discover (client to dhcp server) : 클라이언트가 DHCP 서버를 찾는 과정 DHCP Offer (dhcp server to client) : DHCP 서버가 클라이언트에게 IP 주소를 제안 DHCP Request (client to dhcp server) : 클라이언트가 IP 주소를 요청 DHCP Ack (dhcp server to client) : DHCP 서버가 IP 주소를 할당 ARP : Address Resolution Protocol, IP 주소를 MAC 주소로 변환하는 프로토콜\nNAT : Network Address Translation, 사설 IP 주소를 공인 IP 주소로 변환하는 프로토콜\n| 참고로 공유기는 라우터 + 스위치 + DHCP Server + NAT 기능을 가지고 있음\nPing과 RTT\nICMP : Internet Control Message Protocol, 네트워크 장비 간에 메시지를 주고받는 프로토콜 Echo Request : Ping Echo Reply : Ping에 대한 응답 Time Exceeded : TTL이 0이 되어서 패킷이 소멸될 때 Destination Unreachable : 목적지에 도달할 수 없을 때 L4 TCP, UDP : 둘을 구분하는 가장 큰 차이는 Connection이다.\n문제는 연결이 Virtual이라는 것 (Virtual Circuit) 연결은 결과적으로 순서 번호로 구현 (Sequence Number) 연결은 상태 기반 (Stateful) TCP : Transmission Control Protocol, 신뢰성 있는 데이터 전송을 보장하는 프로토콜\nClient-Server 모델 클라이언트가 소켓을 열면, OS가 TCP 포트를 부여함 3-way Handshake : TCP 연결 설정 과정\nSYN : 클라이언트가 서버에게 연결을 요청\nSYN-ACK : 서버가 클라이언트에게 응답\nACK : 클라이언트가 서버에게 응답\nHandshake 과정에서 Sequence Number와 Acknowledgement Number가 사용됨, 그리고 정책을 교환함 (MSS, Window Size 등)\n4-way Handshake : TCP 연결 해제 과정\nFIN : 클라이언트가 연결 종료 요청 ACK : 서버가 응답 FIN : 서버가 연결 종료 요청 ACK : 클라이언트가 응답 TCP Header 형식과 구성요소\nSource Port : 출발지 포트 Destination Port : 목적지 포트 Sequence Number : 순서 번호 Acknowledgement Number : 확인 번호 Data Offset : 데이터 오프셋 Reserved : 예약 필드 Flags : 플래그 필드 Window Size : 윈도우 크기 Checksum : 체크섬 Urgent Pointer : 긴급 포인터 Options : 옵션 필드 Padding : 패딩 필드 UDP : User Datagram Protocol, 신뢰성 없는 데이터 전송을 보장하는 프로토콜\nConnectionless : 연결 설정 과정이 없음\nStateless : 상태를 유지하지 않음\nBest Effort : 최선을 다하지만, 데이터 손실이 발생할 수 있음\n혼잡제어, 버퍼 관리, 흐름제어가 없음\n클라이언트를 배려하지 않음\n그런데도 쓰는 이유\nIPTV의 경우, 실시간 스트리밍을 하는데, 사용자마다 네트워크 속도가 다르면 하향 평준화 밖에 답이 없음 게임서버의 경우 마찬가지로 TCP를 사용하면 하향 평준화가 발생함, UDP + 혼잡제어를 직접 구현해서 사용하는 것이 더 효율적 UDP Header 형식과 구성요소\nSource Port : 출발지 포트 Destination Port : 목적지 포트 Length : 길이 Checksum : 체크섬 세 가지 네트워크 장치 구조 Inline, 대표 장치 Packet + Drop/Bypass + Filtering Out-of-path Packet + Read only, Sensor Proxy Socket stream + Filtering ","permalink":"http://localhost:1313/_wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/","summary":"네트워크 기본 개념Cheatsheet 🦉 from 외워서 끝내는 네트워크 핵심이론 OSI 7 Layer : 의존적 관계가 성립하는 (Layered, 상위 계층이 하위 계층에 의존) 프로토콜을 계층적으로 나열한 것 Protocol suite, Protocol Stack Protocol Suite, Protocol Stack : 여러 프로토콜의 집합 Network 성능 지표 throughput : 처리율 (bps, Mbps, Gbps 등), 실시간성을 띄며, 평균값을 보통 지표로 사용\nbandwidth : 대역폭, 통신망이 전송할 수 있는 데이터의 양, 단위는 bps\npacket loss : 패킷 손실률, 패킷이 전송 중 소멸되는 비율","title":"네트워크 기본 개념 Cheatsheet 🦉"},{"content":"Intro 😃 게임 서버 프로그래밍을 보는데, 소켓등 네트워크 관련 지식이 부족하다고 느껴서 마찬가지로 책을 한권 읽어보려고 하는데, TCP/IP Illustrated로 정했다. 워낙 네트워크를 싫어하고 귀찮아하는데, 이번에는 좀 더 깊게 이해하고 싶고, 쉬운 개념부터 복습해두고 책을 시작해보려고 한다. Warm-up 👋 [[네트워크-기본-개념]] TCP/IP Illustrated 📚 Chapter 1 : [[Introduction]] ","permalink":"http://localhost:1313/_wiki/network/","summary":"Intro 😃 게임 서버 프로그래밍을 보는데, 소켓등 네트워크 관련 지식이 부족하다고 느껴서 마찬가지로 책을 한권 읽어보려고 하는데, TCP/IP Illustrated로 정했다. 워낙 네트워크를 싫어하고 귀찮아하는데, 이번에는 좀 더 깊게 이해하고 싶고, 쉬운 개념부터 복습해두고 책을 시작해보려고 한다. Warm-up 👋 [[네트워크-기본-개념]] TCP/IP Illustrated 📚 Chapter 1 : [[Introduction]] ","title":"Network 🦉"},{"content":"8.0 스케줄링 : 멀티 레벨 피드백 큐 MLFQ가 해결하려고 하는 기본적인 문제는 두 가지 이다. 짧은 작업을 먼저 실행시켜 반환 시간을 최적화 하는 것. 대화형 사용자에게 빠른 시스템이라는 느낌을 주기 위해서 응답 시간을 최적화 하는 것. 이 과정에서 해결해야 하는 가장 큰 문제는 다음과 같다. \u0026ldquo;우리가 프로세스에 대한 정보가 없다면 이러한 스케줄러를 어떻게 구현할 수 있을까?\u0026rdquo;\n위의 문제는 이 장의 핵심 질문으로 이어진다.\n8.1 MLFQ: 기본 규칙 MLFQ는 여러개의 큐로 구성되며, 각각 다른 우선순위를 가진다.\n실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다.\nMLFQ는 프로세스 실행을 결정할 때 우선순위를 사용한다.\n물론 하나의 큐에 여러개의 작업이 들어갈 수 있지만, 이 경우 RR을 사용한다.\n여기까지는 쉬운데 어려운건 우선순위를 어떻게 정할 것인가이다.\nMLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아니라, 작업의 행동에 따라 우선순위를 동적으로 조절한다.\n예를들어 대화형 프로세스처럼 빠른 반응이 필요한 프로그램은 우선순위를 높게 설정하고, 한 작업이 긴 시간동안 CPU를 사용하면 우선순위를 낮추는 방식이다.\nMLFQ의 두 가지 규칙은 다음과 같다.\n규칙 1 : Priority A \u0026gt; Priority B 이면, A의 프로세스는 B의 프로세스보다 먼저 실행된다. 규칙 2 : Priority A = Priority B 이면, A와 B는 RR을 사용하여 실행된다. 당장은 위의 그림과 같이 작업이 구성된다고 했을 때, A B가 RR으로 처리되면 CD는 실행되지도 않는 문제가 발생한다.\n아래의 목차에서 작업 수선순위자체가 변경되는 방법에 대해 알아보자.\n8.2 MLFQ: 우선순위의 변경 첫번째 변경은 다음과 같은데 주로 대화형 프로세스와 cpu bound 프로세스를 구분하는 방법이다.\n대화형 프로세스는 짧은 시간동안 CPU를 사용하고, 대기시간이 길다. CPU bound 프로세스는 긴 시간동안 CPU를 사용하고, 대기시간이 짧다. MLFQ에 추가된 규칙\n규칙 3 : 작업이 시스템에 들어오면, 우선순위는 가장 높은 큐에 할당된다.\n규칙 4-a : 작업이 타임슬라이스를 전부 사용하면, 우선순위는 낮은 큐로 이동된다.\n규칙 4-b : 타음 슬라이스를 사용하지 않고 CPU를 양도하면, 우선순위는 유지된다.\n이 규칙의 의의는 일단 전부 짧은 시간을 사용하는 프로세스라 가장하고, 실제로 실행시간이 짧다면 위에 두거나 우선순위가 하락하는 동안 끝내는 것이고,\n실행시간이 길다면 우선순위가 하락하면서 아래로 내려가게 된다.\n대화형 프로그램에서는 굳이 살피지 않아도 잘 동작함을 알 수 있다.\n현재 MLFQ의 문제점 일견 완벽해 보이지만, MLFQ에도 문제점이 존재한다. 기아 상태(starvation)가 발생할 수 있다. (예를 들어 대화형 프로세스가 너무 많은 경우) 지금 상태를 알 수 있다면, CPU를 독점 하는 프로세스를 만들 수 있다. 프로그램의 구분이 바뀔 수 있다. 8.3 우선순위의 상향 조정 당연히 기본적인 아이디어는 우선순위를 상향 조정하는 것이다.\n이를 위해 다음과 같은 규칙을 추가한다.\n규칙 5 : 일정 기간 S가 지나면, 모든 프로세스의 우선순위를 최상위 큐로 이동시킨다.\n이 규칙을 통해 기아 상태와 프로그램의 구분이 바뀔 수 있는 문제를 해결할 수 있다.\n물론 여기에도 많은 고민이 남아있는데, 바로 S의 값을 어떻게 설정할 것인가이다.\nS의 값이 너무 작으면, 대화형 작업이 적절한 시간동안 실행되지 않을 수 있고, 너무 크면 기아 상태가 발생할 수 있다.\n8.4 우선순위의 하향 조정 나머지 문제(스케줄러를 독점하는 이슈)도 하나의 규칙으로 해결할 수 있다.\n규칙 6 : 우선 순위 단계에서 시간 할당량을 사용하면, 우선 순위를 하향 조정한다.\n8.5 MLFQ조정과 다른 이슈들 MLFQ의 아이디어는 위와 같지만, 아직 실제 구현에는 많은 문제가 남아있다.\n타임슬라이스의 길이를 어떻게 설정할 것인가?\nS의 값을 어떻게 설정할 것인가?\n9.0 스케줄링 : 비례 배분 이번 장에서는 스케줄러의 또 다른 방법인 비례 배분에 대해 알아본다.\n비례 배분의 목표는 간단한데, 반환시간이나 응답시간을 최적화 하는 대신 스케줄러가 각 프로세스에 CPU 시간을 공평하게 분배하는 것이다.\n가장 좋은 예시는 Waldspurger와 Weihl의 연구인 lottery scheduling이다. (간단하게 말하면, 각 프로세스에 티켓을 부여하고, 스케줄러가 랜덤하게 티켓을 뽑아서 실행하는 방식 더 중요한 프로세스에 더 많은 티켓을 준다)\n9.1 기본 개념 : 추첨권이 당신의 지분이다 추첨권이라는 기본적인 개념이 추천 스케줄링의 근간을 이룬다.\n기본적인 아이디어는 위와 같고, 장점은 무작위성이다.\n무작위성이 장점인 이유\n기본적으로 기존의 문제를 해결한다 (LRU의 예시를 생각해보자) 가볍다 (관리해야 할 정보가 거의 없다) 빠르다 (로직이 덜 붙어 난수생성 시간정도에 불과하다) 9.2 추첨 기법 추첨권을 다루는 다양한 기법이 있는데, 그 중 가장 먼저 고려할 것 은 추첨권 화폐이다.\n이 개념은 사용자가 추첨권을 자신의 화폐 가치로 추첨권을 자유롭게 할당 할 수 있게 한다. (시스템은 자동적으로 화폐 가치를 변환한다)\n이건 다른 사용자와 다른 프로세스가 할당한 추첨권의 가치를 비교할 수 있게 해준다.\n그리고 추첨권 양도라는 개념도 있는데, 이는 다른 프로세스에게 추첨권을 양도할 수 있게 해준다.\n이를 통해 사용자는 자신의 추첨권을 다른 프로세스에게 양도할 수 있고, 이는 다른 프로세스가 더 많은 추첨권을 가지게 해준다.\n마지막으로 추첨권 팽창라는 개념도 있는데, 이는 시스템이 특정 이벤트가 발생할 때 추첨권을 증가시키는 것이다.\n9.3 구현 // counter : 당첨자를 발견했는지 확인하는 변수 int counter = 0; // winner : 0부터 총 추첨권의 수까지 랜덤하게 추첨된 당첨자 int winner = getRandom(0, total_tickets); // 추첨권을 가진 프로세스를 찾는다. node_t *current = head; while (current) { counter += current-\u0026gt;tickets; if (counter \u0026gt; winner) { // 당첨자를 발견했으므로 프로세스를 실행한다. run(current-\u0026gt;process); break; } current = current-\u0026gt;next; } 위의 코드는 추첨권을 가진 프로세스를 찾아 실행하는 코드이다. 9.4 추첨권 시스템 예제 기본적으로 불공정 지표 U를 정의한다.(U = 1 - (첫 작업 종료 시간 / 두 번째 작업 종료 시간))\n기본적으로는 1(가장 공정함)으로 수렴하긴 하지만 랜덤의 특성상 초반에는 불공정함이 발생할 수 있다.\n다만 추첨권 시스템에서 가장 큰 문제는 추첨권을 어떻게 할당할 것인가이다.\n이는 추첨권을 어떻게 할당할 것인가에 따라 성능이 달라질 수 있고 아직 미해결 상태이다.\n9.6 결정론적 스케줄링 결정론적 스케줄링은 랜덤성을 제거하고, 스케줄링을 결정론적으로 만드는 것이다.\n대표적으로 보폭 스케줄링(stride scheduling)이 있다.\n보폭 스케줄링은 각 프로세스에 보폭을 할당하고, 스케줄러는 가장 작은 보폭을 가진 프로세스를 실행한다.\n이를 통해 랜덤성을 제거하고, 스케줄링을 결정론적으로 만들 수 있다.\ncurr = remove_min(queue); schedule(curr); curr-\u0026gt;pass += curr-\u0026gt;stride; insert(queue, curr); 처음부터 U가 1에 수렴하는 것을 볼 수 있다.\n그렇다면 왜 결정론적 스케줄링을 사용하지 않을까?\n이유는 단순한데, 새로운 프로세스가 들어오면, 스케줄러는 새로운 보폭을 할당해야 하는데, 이것이 결정론적 스케줄링의 단점이다.(랜덤 추첨권 방식에서 훨씬 쉽다)\n9.7 리눅스 CFS(Completely Fair Scheduler) 리눅스는 기존과 다른 방식으로 공정 배분 스케줄링을 구현한다.\n이 스케줄러의 장점은 효율성과 확장성이다.\n효율성을 위해 CFS는 최적의 내부 설계와 자료구조를 사용한다.\n일단 기본적으로 virtual runtime이라는 counting 기반 방식을 사용한다.\n프로세스 실행시 virtual runtime이 증가하고, 스케줄러는 가장 작은 virtual runtime을 가진 프로세스를 실행한다.\n이 역시 아이디어는 간단하지만, 스케줄러가 어느 시점에 멈출지를 결정하는 것이 중요하다.\n너무 자주 스케줄러를 호출하면 오버헤드가 발생하고, 너무 늦게 호출하면 공정성이 떨어진다.\n이를 위해 다양한 통제 변수를 사용한다.\n첫 번째 변수로 sced_latency가 있다. 이 변수는 스케줄러가 얼마나 자주 호출되는지를 결정한다(보통 48ms).\n예를 들어 네개의 프로세스가 있다면, CFS는 sced_latency를 1/4로 나누고 프로세스당 타임슬라이스를 해당 값으로 설정한다.\n문제는 너무 많은 프로세스가 있다면 너무 많은 context switching이 발생할 수 있다.\n이를 해결하기 위해 min_granularity라는 변수를 사용한다. (보통 최솟값은 6ms)\n예를들어 10개의 프로세스가 있다면, 원래는 sced_latency에 따라 4.8ms로 나누어진다.\n하지만 min_granularity가 6ms이므로, 6ms로 설정된다. 스케줄링의 효울성은 이렇게 보호된다.\n이러한 방식으로 CFS는 공정성과 효율성을 모두 확보한다.\n추가적인 기능으로 가중치(Niceness)를 사용한다. 이는 프로세스의 우선순위를 보정한다.\n수식은 다음과 같다. time_slice = (weight_of_task / weight_of_all_tasks) * sced_latency (가중치 표는 -20 ~ 19까지에 해당하는 값을 대응 시킨다)\n이런 수식을 도입하면 가중치에 따라서 프로세스의 타임슬라이스(재조정 시간)이 달라지게 된다.\nvruntime도 가중치에 따라서 고도화 되어있다.\n고도화 수식은 다음과 같다. vruntime = vruntime + (weight_of_all_tasks / weight_of_task) * time_slice (가중치가 높을수록 vruntime이 느리게 증가한다)\nRedBlack Tree의 활용\nCFS는 효율적인 알고리즘이 꼭 필요하다. (다음 실행할 프로세스를 빠르게 찾아야 하기 때문)\n예를들어 대기중인 프로세스를 LinkedList로 관려하면, 검색에 너무 많은 시간이 소요된다.\n커질수록 O(n)의 시간복잡도를 가지기 때문인데, 아주 작은 타임슬라이스 시간 안에 수천개의 프로세스가 대기할 수 있는데, 이는 매우 큰 문제이다.\nI/O와 잠자는 프로세스 다루기\nCFS는 I/O와 잠자는 프로세스를 어떻게 다루는지에 대한 문제도 있다.\n이를 위해 CFS는 vruntime을 사용한다.\n정확히는 잠자는 프로세스가 깨어났을 때 vruntime을 업데이트한다(트리에서 찾을 수 있는 가장 작은 vruntime을 찾아서 업데이트한다)\n10.0 멀티프로세서 스케줄링 이번 장에서는 멀티프로세서 스케줄링에 대해 알아본다.\n원래는 병행성을 다루고 보는 것이 중요하지만, 이번 장에서는 멀티프로세서 스케줄링에 대해 알아본다.\n다만 기존의 프로그램들(하나의 코어만 사용하도록 설계된)을 멀티프로세서에서 실행시키는 것에 대해서 알아본다.\n10.1 배경: 멀티프로세서 구조 기본적으로 멀티 프로세서 하드웨어는 두가지 문제를 야기한다.\n다수의 프로세서 간의 데이터 공유 문제 하드웨어 캐시의 사용방식 문제 캐시는 지영성에 기반한다. 지역성에는 시간 지역성과 공간 지역성이 있다.\n시간 지역성 : 최근에 접근한 데이터는 다시 접근할 확률이 높다. 공간 지역성 : 최근에 접근한 데이터와 인접한 데이터에 다시 접근할 확률이 높다. 이러한 특징에서, 캐시 일관성 문제가 발생한다.\n캐시 일관성 문제를 요약하면, 캐시된 데이터를 다른 프로세서가 변경했을 때, 어떻게 처리할 것인가이다.\n기본적인 해결책은 하드웨어에서 제공된다, 하드웨어는 메모리 주소를 계속 감시하고, 항상 올바른 순서로 처리되도록 시스템을 관리한다.\n여러개의 프로세서가 하나의 메모리를 갱실할때는 항상 공유도되록한다.\n버스 기반 시스템에서는 버스 스누핑이라는 기술을 사용한다. (캐시가 자신과 메모리를 연경하는 버스의 통신 내용을 감시하는 것)\n10.2 동기화를 잊지 마시오 멀티프로세서에서는 동기화가 더욱 중요하다.\n이건 병행성에서 다룰 것 같고, 간단히 요약하면, 동기화 문제가 발생하는 경우를 간단히 설명하는 장이다.\nlock이 대안이지만, lock을 사용하면 성능이 떨어지는 trade-off가 발생한다.\n10.3 캐시 친화성 캐시 친화성도 문제를 야기한다 (CPU가 번갈아가며 캐시에 데이터를 올리면서 오는 지연과 낭비)\n멀티프로세서는 이런점을 고려해서 프로세서를 스케줄링 해야 한다.\n결론적으로 사실 병행성에서 나와야 하는 주제이고, 앞의 설명이 부족해서 단번에 이해가 어렵고 혼동스러울 수 있다. 멀티 프로세서 환경에서 스케줄링을 하기 위해서 고려해야할 것들에 대한 언급정도로 이해하면 될 것 같다.\n10.4 단일 큐 스케줄링 결국 다시 스케줄링으로 돌아와서 이야기해보면, 멀티프로세서 스케줄링에서 가장 간단한 방법은 단일 큐 스케줄링이다.\n단일 큐 멀티프로세서 스케줄링(Single Queue Multiprocessor Scheduling)은 모든 프로세서가 하나의 큐를 공유하고, 스케줄러는 가장 높은 우선순위를 가진 프로세스를 실행한다.\n간단히 말하면, 큐에 넣고 비어있는 프로세서에게 할당하는 방식이다. (작업이 두개고 프로세서가 두개면, 두개의 프로세서에게 각각 할당하는 방식)\n이 방식은 대부분의 단점을 무시하기도 하고, 간단하지만, 확장성이 결여되어있다.\n이 방식은 락을 사용하는데(실행시킬 다른 프로세서를 찾을 때) 이는 성능을 떨어뜨릴 수 있다.\n또한 아무런 보정이 없다면, 캐시 친화성이 떨어질 수 있다.\n이를 해결하기 위해서 같은 프로세서가 같은 프로세스를 실행하도록 유도해서 오버헤드를 줄이는 방법도 있다.\n이같은 방식은 좋지만, 구현이 어렵다는 단점이 있다.\n10.5 멀티 큐 스케줄링 멀티 큐 스케줄링(Multi Queue Scheduling)은 단일 큐 스케줄링의 단점을 보완한 방식이다.\n이것도 개념자체는 어렵지 않아서 간단하게 요약하면, 각 프로세서에 큐를 할당하고, 각 큐에 프로세스를 할당하는 방식이다.\nA,B,C,D 네가지 작업이 있다면, A,B는 큐1에, C,D는 큐2에 할당하는 방식이다.\n기본적으로 캐시친화적이고, 큐로 인한 락을 줄일 수 있다.\n단 이 방식도 문제가 있는데, 워크로드가 불균형하다면, 한쪽 큐가 너무 많은 작업을 처리하게 된다.\n이걸 해결하기 위한 방법은 이주 (migration)이다.\n이주는 프로세스를 다른 큐로 이동시키는 것이고 이를 통해 불균형을 해결할 수 있다.\n개인적으로 모든 스케줄링 방법의 한계는 작업을 정확히 예측 할 수 없다는 것에 있다고 생각하는데, 그러한 정보의 단절 속에서 사전적인 해결책을 찾는 것이 어렵다고 생각한다. 이주는 그러한 것들을 잘 극복한 사례라고 생각한다.\n","permalink":"http://localhost:1313/_wiki/week-03/","summary":"8.0 스케줄링 : 멀티 레벨 피드백 큐 MLFQ가 해결하려고 하는 기본적인 문제는 두 가지 이다. 짧은 작업을 먼저 실행시켜 반환 시간을 최적화 하는 것. 대화형 사용자에게 빠른 시스템이라는 느낌을 주기 위해서 응답 시간을 최적화 하는 것. 이 과정에서 해결해야 하는 가장 큰 문제는 다음과 같다. \u0026ldquo;우리가 프로세스에 대한 정보가 없다면 이러한 스케줄러를 어떻게 구현할 수 있을까?\u0026rdquo;\n위의 문제는 이 장의 핵심 질문으로 이어진다.\n8.1 MLFQ: 기본 규칙 MLFQ는 여러개의 큐로 구성되며, 각각 다른 우선순위를 가진다.","title":"Week-03 📚"},{"content":"1. 변수의 메모리 공간 [데이터 영역]\n초기화된 데이터를 저장하는 공간 전역 변수, 정적 변수, 상수 등이 저장된다. .data(미리 초기화 해 둔 경우), .rodata(읽기 전용 데이터), .bss(초기화 안해둔 경우) 섹션에 저장된다. [스택 영역]\n지역 변수, 매개변수, 리턴 값 등이 저장된다. 함수 호출 시 생성되고 함수 종료 시 소멸된다. 함수 호출 시 생성되는 프레임에 저장된다. [힙 영역]\n","permalink":"http://localhost:1313/_wiki/cpp-%EB%B3%80%EC%88%98%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%B5%EA%B0%84/","summary":"1. 변수의 메모리 공간 [데이터 영역]\n초기화된 데이터를 저장하는 공간 전역 변수, 정적 변수, 상수 등이 저장된다. .data(미리 초기화 해 둔 경우), .rodata(읽기 전용 데이터), .bss(초기화 안해둔 경우) 섹션에 저장된다. [스택 영역]\n지역 변수, 매개변수, 리턴 값 등이 저장된다. 함수 호출 시 생성되고 함수 종료 시 소멸된다. 함수 호출 시 생성되는 프레임에 저장된다. [힙 영역]","title":"Cpp 변수의 메모리 공간(작성중)"},{"content":"1. 어셈블러 어셈블러는 어셈블리어를 기계어로 변환해주는 프로그램이다.\nSection 구분이 있다.\n.data : 데이터를 저장하는 공간 변수의 선언 및 사용 초기화 된 데이터를 저장하는 공간 .text : 코드를 저장하는 공간 .bss : 초기화되지 않은 데이터를 저장하는 공간 #include \u0026lt;iostream\u0026gt; using namespace std; char str[] = {\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;}; // .data 영역에 저장 int main() { char str2[] = {\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;}; // stack 영역에 저장 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; return 0; } 12345 12345�% str은 초기화된 데이터이기 때문에 .data 영역에 저장된다. str2는 stack 영역에 저장된 문자 배열이고 우연히 escape null을 찾을때까지 출력한다. 8비트 : 1바이트 16비트 : 2바이트: 1워드 32비트 : 4바이트: 1더블워드 64비트 : 8바이트: 1쿼드워드\n레지스터의 크기는 일반적으로 64비트 운영체제에서 64비트 레지스터를 사용한다.(8바이트) 종류는 총 16개이다. 64비트 레지스터 : RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8, R9, R10, R11, R12, R13, R14, R15 32비트 레지스터 : EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP 16비트 레지스터 : AX, BX, CX, DX, SI, DI, BP, SP 8비트 레지스터 : AL, BL, CL, DL, SIL, DIL, BPL, SPL 1.1. 어셈블리어 명령어 어셈블리어 명령어는 기계어로 변환되는 명령어이다.\n어셈블리어 명령어는 기계어 명령어와 1:1 대응된다.\nmov : 레지스터에 값을 저장하는 명령어\nadd : 레지스터에 값을 더하는 명령어\nsub : 레지스터에 값을 빼는 명령어\nmul : 레지스터에 값을 곱하는 명령어\ndiv : 레지스터에 값을 나누는 명령어\ninc : 레지스터에 값을 1 증가시키는 명령어\ndec : 레지스터에 값을 1 감소시키는 명령어\ncmp : 레지스터에 값을 비교하는 명령어\njmp : 레지스터에 값을 비교하는 명령어\nje : 레지스터에 값을 비교하는 명령어\njne : 레지스터에 값을 비교하는 명령어\njg : 레지스터에 값을 비교하는 명령어\njge : 레지스터에 값을 비교하는 명령어\njl : 레지스터에 값을 비교하는 명령어\njle : 레지스터에 값을 비교하는 명령어\ncall : 함수를 호출하는 명령어\nret : 함수를 종료하는 명령어\npush : 스택에 값을 저장하는 명령어\npop : 스택에 값을 꺼내는 명령어\nlea : 주소를 저장하는 명령어\nand : 논리곱을 하는 명령어\nor : 논리합을 하는 명령어\nxor : 배타적 논리합을 하는 명령어\nnot : 논리부정을 하는 명령어\nshl : 왼쪽 시프트를 하는 명령어\nshr : 오른쪽 시프트를 하는 명령어\nnop : 아무것도 하지 않는 명령어\ndb: Define Byte - 바이트 단위의 데이터를 정의합니다. dw: Define Word - 워드(2바이트) 단위의 데이터를 정의합니다. dd: Define Doubleword - 더블워드(4바이트) 단위의 데이터를 정의합니다. dq: Define Quadword - 쿼드워드(8바이트) 단위의 데이터를 정의합니다.\n","permalink":"http://localhost:1313/_wiki/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC/","summary":"어셈블리 디버깅을 위한 간단한 cheat sheet","title":"어셈블리"},{"content":"cpp 비트 연산 비트 연산은 거의 모든 low한(상대적으로) 언어는 지원하는데, 실제로 사용할때는 코테 문제나, 시험보는 상황 외에는 거의 없었다. 게임업계는 진짜 사용하는 것 같아 간단히 예제를 정리해보았다.\n비트 연산자 \u0026amp; : AND 연산자 | : OR 연산자 ^ : XOR 연산자 ~ : NOT 연산자 \u0026lt;\u0026lt; : 왼쪽 시프트 연산자 \u0026gt;\u0026gt; : 오른쪽 시프트 연산자 비트 연산 예제 비트 플래그 사용 예제 비트 부호를 플래그로 사용하여, 게임내의 캐릭터 상태를 표현할 수 있다.\n0b0000 [무적][변이][스턴][공중부양]\n#include \u0026lt;iostream\u0026gt; using namespace std; unsigned char flag; // 부호 비트가 딸려오는건 엄청 헷갈리기 때문에 보통 unsigned로 선언한다. flag = (1 \u0026lt;\u0026lt; 3); // 무적 플래그를 켠다. flag |= (1 \u0026lt;\u0026lt; 2); // 변이 플래그를 켠다(무적 + 변이). // 무적인지 확인하고 싶다 : bitmask if (flag \u0026amp; (1 \u0026lt;\u0026lt; 3) != 0) { cout \u0026lt;\u0026lt; \u0026#34;무적 상태입니다.\u0026#34; \u0026lt;\u0026lt; endl; } // 무적이나 스턴 상태인지 확인하고 싶다 : bitmask bool mask = (1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 2); if (flag \u0026amp; mask != 0) { cout \u0026lt;\u0026lt; \u0026#34;무적이나 스턴 상태입니다.\u0026#34; \u0026lt;\u0026lt; endl; } ","permalink":"http://localhost:1313/_wiki/%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0/","summary":"거의 처음으로 실사용 하는 예제를 찾아서 정리하는 중","title":"비트 연산"},{"content":"C++ 기본 문법 정리 [[어셈블리]] [[비트-연산]] [[cpp-변수의-메모리-공간]] [[pointer-reference-헷갈릴때-팁]] [[pointer-array-헷갈릴때-팁]] [[pointer-지옥]] [[free는-어떻게-할당을-해제하는가]] [[타입-변환]] [[cpp-casting]] ","permalink":"http://localhost:1313/_wiki/cpp-basic/","summary":"결국 리마인드 강의를 보면서 Cheatsheet 형식정도로만 가볍게 정리","title":"Cpp-basic 🐋"},{"content":"로드맵 https://www.inflearn.com/roadmaps/375\n","permalink":"http://localhost:1313/_wiki/2024-05/","summary":"로드맵 https://www.inflearn.com/roadmaps/375","title":""},{"content":"05.0 막간 : 프로세스 API 거의 모든 소스코드와 강의자료는 아래 링크가 출처 입니다.\n강의 소스코드 : OSTEP 테스트 프로그램 : OSTEP Test Programs 역자 강의 자료 : 강의자료 개념적인 내용이 아닌 실제적인 측면에서 코드를 보는 장은 막간이라고 별도 표기한다.\n이번 절에서는, Unix 시스템의 프로세스 생성에 관해 배운다.\nUnix는 프로세스를 생성하는 시스템콜로 다음 두가지를 제공한다.\nfork()\nexec()\n그리고 wait() 함수를 통해 자식 프로세스가 종료될 때까지 기다릴 수 있다.\n핵심 질문 : 프로세스를 생성하고 제어하는 방법, 프로세스를 생성하고 제어하려면 운영체제가 어떤 인터페이스를 제공해야 하는가? 유용성, 편리성, 그리고 성능을 위해서는 어떻게 인터페이스를 설계해야 하는가?\n5.1 fork() 참고로 fork() 시스템콜은 가장 이해하기 힘들거나 적어도 가장 특이한 시스템콜 중 하나이다. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;hello world (pid:%d)\\n\u0026#34;, (int) getpid()); int rc = fork(); if (rc \u0026lt; 0) { fprintf(stderr, \u0026#34;fork failed\\n\u0026#34;); exit(1); } else if (rc == 0) { printf(\u0026#34;hello, I am child (pid:%d)\\n\u0026#34;, (int) getpid()); } else { printf(\u0026#34;hello, I am parent of %d (pid:%d)\\n\u0026#34;, rc, (int) getpid()); } return 0; } gcc -o c1 c1.c -Wall ./c1 hello world (pid:4605) hello, I am parent of 4607 (pid:4605) hello, I am child (pid:4607) \u0026lsquo;hello world\u0026rsquo;는 부모 프로세스가 출력하고 본인 pid를 출력했다.\nfork() 시스템콜 이후 if 분기를 자세히 볼 필요가 있다.\n부모 프로세스 (pid 4605)는 else 분기로 가고 자식 프로세스 (pid 4607)는 else if 분기로 간다.\n이해하기 힘든 포인트는, fork() 시스템콜 이후에는 두 개의 똑같은(더 정확히 말하면 거의 똑같은) 프로세스가 생성된다는 것이다.\n더 이해하기 힘든 포인트는, 자식 프로세스가 main() 함수의 처음부터 실행하지 않는다는 것이다.\n거의 동일한 프로세스의 복사본이 생성되고, 그 복사본은 스스로의 주소 공간, 레지스터, 자신의 pc값을 갖지만 매우 중요한 차이점이 있다.\n부모 프로세스는 fork() 시스템콜 이후에 자식 프로세스의 pid를 반환하고, 자식 프로세스는 0을 반환한다는 것이다.\n이것은 부모 프로세스와 자식 프로세스가 서로 다른 일을 할 수 있게 해준다.\n5.2 wait() #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;hello world (pid:%d)\\n\u0026#34;, (int) getpid()); int rc = fork(); if (rc \u0026lt; 0) { fprintf(stderr, \u0026#34;fork failed\\n\u0026#34;); exit(1); } else if (rc == 0) { printf(\u0026#34;hello, I am child (pid:%d)\\n\u0026#34;, (int) getpid()); } else { int wc = wait(NULL); printf(\u0026#34;hello, I am parent of %d (wc:%d) (pid:%d)\\n\u0026#34;, rc, wc, (int) getpid()); } return 0; } wait() 함수를 사용하면 부모 프로세스가 자식 프로세스가 종료될 때까지 기다릴 수 있다.\n그래서 아래처럼 의도한 실행 순서를 보게 된다.\nhello world (pid:4605) hello, I am child (pid:4607) hello, I am parent of 4607 (pid:4605) 5.3 exec() exec() 시스템콜은 새로운 프로그램을 실행하는데 사용된다.\np2.c 프로그램은 같은 프로그램의 카피를 실행할때만 유용하다.\np3.c 프로그램은 exec() 시스템콜을 사용하여 wc 프로그램을 실행한다.\nwc는 unix 명령어로 파일의 줄, 단어, 문자 수를 세는 프로그램이다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;hello world (pid:%d)\\n\u0026#34;, (int) getpid()); int rc = fork(); if (rc \u0026lt; 0) { // fork failed; exit fprintf(stderr, \u0026#34;fork failed\\n\u0026#34;); exit(1); } else if (rc == 0) { // child (new process) printf(\u0026#34;hello, I am child (pid:%d)\\n\u0026#34;, (int) getpid()); char *myargs[3]; myargs[0] = strdup(\u0026#34;wc\u0026#34;); // program: \u0026#34;wc\u0026#34; (word count) myargs[1] = strdup(\u0026#34;p3.c\u0026#34;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count printf(\u0026#34;this shouldn\u0026#39;t print out\u0026#34;); } else { // parent goes down this path (original process) int wc = wait(NULL); printf(\u0026#34;hello, I am parent of %d (wc:%d) (pid:%d)\\n\u0026#34;, rc, wc, (int) getpid()); } return 0; } 실행 결과\n❯ ./p3 hello world (pid:7119) hello, I am child (pid:7120) 30 120 896 p3.c hello, I am parent of 7120 (wc:7120) (pid:7119) ❯ wc p3.c 30 120 896 p3.c 참고 : wc 프로그램이 잘 동작하는지 보기 위해 쉘에서 별도로 한 번 더 실행했다. char *myargs[3]; myargs[0] = strdup(\u0026#34;wc\u0026#34;); // program: \u0026#34;wc\u0026#34; (word count) myargs[1] = strdup(\u0026#34;p3.c\u0026#34;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count execvp() 함수는 exec() 시스템콜을 호출하는데, p3.c파일을 인자로 준 wc 프로그램을 실행한다. 30 120 896 p3.c 그래서 위와 같이 p3.c 파일의 줄, 단어, 문자 수를 세는 결과를 출력한다.\n해당 wc 프로그램이 끝나면, 자식 프로세스는 종료되고,\n// parent goes down this path (original process) int wc = wait(NULL); printf(\u0026#34;hello, I am parent of %d (wc:%d) (pid:%d)\\n\u0026#34;, rc, wc, (int) getpid()); wait() 함수를 통해 기다리고 있던부모 프로세스가 재실행되어 아래 문구를 출력한다. hello, I am parent of 7120 (wc:7120) (pid:7119) fork()역시 매우 독특하다.\nfork() 시스템콜은 실행할 프로그램(executable)과 몇개의 인자를 제공한다.\nfork() 시스템콜이 호출되면, 인자로 제공한 프로그램의 코드가 로드되고, 지금 코드의 세그먼트와 정적 데이터를 덮어쓴다.\n또한 힙이나 세그먼트 같은 메모리 공간은 새로 초기화된다.\n즉 새로운 프로세스를 실행시키는것이 아니라, 지금 프로세스를 새로운 프로그램으로 덮어쓰는 것이다.\n그 증거로 exec() 시스템콜 이후의 기존 프로세스는 실행되지 않는다 (\u0026ldquo;this shouldn’t print out\u0026rdquo;).\n즉 다른 program을 덮어씌워 실행시키는 것이다.\nPID는 변하지 않고, 말인 즉슨 새로운 프로세스를 실행시키는것은 아닌, 다른 프로그램을 실행시키는 것이다.\n프로그램과 프로세스의 차이에 대한 감을 잡기 좋은 예제이다.\nTip : Getting It Right Lamson은 \u0026ldquo;옳은 일을 하라\u0026rdquo; 그리고 그것은 어떠한 추상화나 단순화로도 대체될 수 없다고 말한다. 책에서는 다양한 프로세스의 생성 디자인이 있을 수 있지만, 정확히 해야 할 일 은 fork(), exec()과 같이 단순하고 올바른 방법이 이라며 강조했다.\n5.4 왜, 이런 API를? 프로세스를 생성하는 간단한 일에 왜이렇게 이상하고 복잡한 인터페이스를 제공하는 것일까?\n밝혀진 바에 따르면, Unix의 Shell을 구현하려면 fork()와 exec()의 분리는 꼭 필요했다.\n쉘은 코드를 fork() 이후, 그리고 exec()이전에 실행해야 했기 때문이다.\n쉘은 기본적으로 단순한 유저 프로그램이다.\n프롬프트를 보여주고, 입력을 기다린다.\n만약 커맨드(일반적으로 실행 가능한 프로그램과 인자)를 입력받으면,\n(대부분의 경우에) 쉘은 해당 실행 가능한 프로그램이 파일시스템의 어디에 있는지 찾는다.\n그리고 fork()를 호출하여 커맨드를 실행할 자식 프로세스를 생성한다.\n그리고 exec()를 호출하여 그 프로그램을 실행한다.\n마지막으로 wait()를 호출하여 자식 프로세스가 종료될 때까지 기다린다.\n자식프로세스가 종료되었다면, 쉘은 wait()의 결과를 리턴하고 다시 프롬프트를 보여준다(다음 커맨드를 위해).\nfork()와 exec()의 분리는 이런 상태에서 다양한 유용한 것들을 쉽게 할 수 있도록 만들어준다.\nwc p3.c \u0026gt; newfile.txt 위의 예제어서, wc 프로그램의 출력은 newfile.txt 파일로 리다이렉트된다.\n쉘이 이걸 해내는 방법은 매우 단순한데, 자식스포세스가 생성되면, 쉘은 standard output을 닫고, newfile.txt를 open한다.\n그래서 wc 프로그램의 출력은 화면에 뿌려지는대신, newfile.txt로 들어가게 된다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, char *argv[]) { int rc = fork(); if (rc \u0026lt; 0) { // fork failed; exit fprintf(stderr, \u0026#34;fork failed\\n\u0026#34;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file close(STDOUT_FILENO); open(\u0026#34;./p4.output\u0026#34;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU); // now exec \u0026#34;wc\u0026#34;... char *myargs[3]; myargs[0] = strdup(\u0026#34;wc\u0026#34;); // program: \u0026#34;wc\u0026#34; (word count) myargs[1] = strdup(\u0026#34;p4.c\u0026#34;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count } else { // parent goes down this path (original process) int wc = wait(NULL); assert(wc \u0026gt;= 0); } return 0; } 위의 작업을 보여주는 코드이다.\nfork()를 호출해서 자식 프로세스(기존의 프로세스의 복사본)를 생성한다.\n자식 프로세스가 타게될 분기에서는 close(STDOUT_FILENO)로 표준 출력을 닫는다.\n그리고 open()을 호출하여 p4.output 파일을 열고, 그 파일을 표준 출력으로 사용한다.\n그리고 exec()의 실행으로 인해서 기존의 프로그램이 wc로 덮어씌워지고 그동안의 출력은 p4.output 파일로 리다이렉트된다.\n유닉스의 파이프는 이와 같은 방식으로 동작한다.\n더 정확히는 한 프로세스의 출력이 커널 내 파이프(큐)로 들어가고, 다른 프로세스는 그 파이프로부터 입력을 받는다.\n이러한 방식으로 프로세스의 체인을 구현해뒀다.\n추가적으로 찾아본 내용 : pipe() 시스템 호출은 파이프를 생성하는데 사용된다, pipe() 를 호출하면 커널 내부에 파이프라고 불리는 메모리 버퍼가 생성된다. 실제로 큐로 구현되어있어, 한쪽 끝에서 데이터가 쓰이고 다른 한 쪽 끝에서 데이터가 읽힌다. (읽기 쓰기용 디스크립터가 각각 있음)\n5.5 프로세스 제어와 사용자. 유닉스에는 fork(), exec(), wait()와 같은 프로세스 제어를 위한 api들 외에도 다양한 프로세스 제어를 위한 api들이 있다.\n예를 들어, kill() 시스템콜은 다른 프로세스를 멈추거나 끝내기 위한 시그널 을 보내기 위해 사용된다.\n시그널이라는 운영체제의 매커니즘은 외부 사건을 프로세서에 전달하는 토대이다.\n실제로 signal() 시스템콜은 시그널을 받았을 때 어떻게 반응할지를 알려줄 수 있도록 되어있는 시스템 콜이다.\n이러한 프로세스 제어를 위한 시스템콜을 알게된다면 자연스럽게 보안과 관련된 이슈들도 알게된다.\n예를 들어, 누구나 다른 프로세스를 죽일 수 있는 권한을 가지고 있으면, 그것은 보안 이슈가 될 수 있다.\n그래서 user와 같은 개념을 도입하였다.\n간단하게만 알아보면 user는 인증과정을 거쳐 시스템에 로그인 할 수 있고, 하나 이상의 프로세스를 실행할 수 있는 권한을 가진다.\n일반적으로 그 프로세스들에 대해서만 제어 권한을 가진다.\n운영체제는 CPU, 메모리와 디스크 같은 자원을 각 사용자와 프로세스들에 할당하여 전체적인 시스템의 목적에 도달하도록 만드는 역할을 한다.\n5.7 요약 이번 장에서는 프로세스를 다루는 API중 일부를 알아봤다!\n각 프로세스는 이름이 있다. 대부분의 시스템에서 이름은 PID라는 번호이다.\nUNIX 시스템에서는 fork 시스템 콜을 사용하여 새로운 프로세스를 생성한다.\n생성의 주체가 되는 프로세스는 부모 프로세스, 생성된 프로세스는 자식 프로세스라고 한다.\nwait() 시스템 콜을 사용하여 부모 프로세스가 자식 프로세스가 종료될 때까지 기다릴 수 있다.\nexec() 시스템 콜을 사용하여 자식 프로세스가 부모와의 연관성을 완전히 끊어서 새로운 프로그램을 실행할 수 있다.\nUNIX 쉘은 보통 fork, exec, wait를 사용하여 사용자의 명령을 시작한다. fork와 exec을 분리하였기에 실행 중인\n프로그램을 조작하지 않고도 입/출력 재지정, 파이프, 그리고 다른 기능을 처리하는것이 가능하다.\n프로세스 제어는 시그널이라는 형태로 제공되며, 이를 활용하여 작업을 멈추고, 재시작하거나, 종료할 수 있다.\n누가 어떠한 프로세스를 제어 할 수 있는지는 사용자라는 개념속에 포함되어있다.\n슈퍼사용자는 시스템의 모든 프로세스를 제어할 수 있지만, 일반 사용자는 자신의 프로세스만을 제어할 수 있다.\n5.8 과제! https://github.com/SmallzooDev/OSTEP/tree/main/Chapter05\n6.0 제한적 직접 실행 원리 CPU를 가상화 하기 위해서 운영체제는 여러 작업들이 동시에 실행되는 것처럼 보이게 해야 한다. 기본적인 아이디어는 간단하다, 하나의 프로세스를 잠깐 실행하고 다른 프로세스를 실행하고, 그것을 반복하는 것이다. 그것을 위해서는 두가지 주요한 이슈를 해열해야 하는데, 첫 번째는 오버헤드이며, 두 번째는 제어문제이다. 오버헤드로 인한 성능 저하를 최소화하고, CPU의 통제를 잃지 않는 것이 주된 목표이다. 그중에서 이번장의 핵심 질문은 : 제어를 유지하면서 효과적으로 CPU를 가상화하는 방법은 무엇인가? 이다.\n6.1 기본 원리: 제한적 직접 실행(Limited Direct Execution) Limited Direct Execution에서 Direct Execution부분은 간단하다. CPU 상에서 프로그램을 직접 실행하는 것을 의미한다. 즉 운영체제가 프로그램을 실행하기 시작 할 때 프로세스 목록에 해당 프로세스 항목을 만들고, 메모리 할당하고, 코드를 디스크에 탑재하고, 진입점(main()함수 또는 다른 언어에서 그러한 역할을 하는 진입점)코드를 찾아 실행한다. 직접 실행의 예시를 들면 다음과 같다.\n운영체제 프로그램 프로세스 목록의 항목을 생성 메모리 할당 디스크에서 코드를 읽어 메모리에 탑재 argv, envp를 스택에 넣고, main()함수를 호출 레지스터 초기화 main()함수 실행 main에서 return 명령어 실행 프로세스 메모리 반환 프로세스 목록에서 항목 제거 이 방법은 (Direct Execution)은 간단하고 효율적이지만, 두가지 문제가 있다.\n첫 번째 문제는, 만약 프로그램을 직접 실행시킨다면 프로그램이, 운영체제가 원치않는 일을 하지 않는다는 것을 어떻게 보장할 수 있는가? 이고\n두 번째 문제는, 프로세스 실행 시 운영체제는 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환시킬 수 있는가, 즉 CPU를 가상화하는 데 필요한 시분할(time sharing)을 어떻게 구현할 수 있는가? 이다.\n아래의 단락에서 이러한 문제를 어떻게 해결하는지 알아본다.\n프로그램 실행에 제한을 두지 않으면 운영체제는 어떠한것 도 제어 할 수 없는 단순한 라이브러일 뿐이다.\n사실 이부분이 책에서, 원서를 봐도 크게 와닿지 않아 역자의 강의를 보니 핀트가 아주 적절하게 맞춰졌다.\n2장에서 이야기 한 상황 (procedure call)을 수행하는 운영체제는 사실상 라이브러리와 다름 없다고 했다. DE를 수행하고 있는 시점이 정확히 그 상황이고, 문제에 맞닥뜨린다는 포인트를 짚은 것이다.\n강의에서는 매우 간단한 예제 두개로 핀트를 잘 맞춰준다.\n// user can do wrong things int *i; i = 0; *i = 1; 이 코드가 실제로 실행된다면, 메모리 \u0026lsquo;주소\u0026rsquo; 부분에 값을 넣으려고 하기 때문에, 다른 시스템 전부에 장애를 일으킬 수 있다. // getting control back from CPU is not easy int i = 0; while (i = 0) { do something but never touch i; } 이 코드는 무한 루프에 빠지게 되고, CPU는 이 루프를 빠져나오지 못하게 된다.\n즉 이러한 상황이 DE, 즉 권한과 제어를 제한하지 않으면 발생할 수 있는 문제점이다.\n마지막으로 역자는 두가지 포인트의 부재를 짚고 있다 첫 번째 코드에는 protect system이 부재하고, 두 번째 코드에는 control execution이 부재하다.\n6.2 문제점 1: 제한된 연산 (첫 번째 이슈 해결하기) 핵심 질문, 어떻게 제한된 연산을 수행해야 하는가? 프로세스는 I/O 연산과 또 다른 restricted operation을 수행할 수 있어야 한다. 그러나 시스템에 대한 모든 권한을 주지 않은 상태에서 어떻게 그런 연산을 수행 할 수 있을까?\n(Direct Execution)의 가장 큰 장점은 빠르다는 것 이다\n그러나 디스크 입출력 요청이나 CPU나 메모리 같은 시스템 자원의 추가할당 같은 특수한 연산을 수행 할 수 없다.\n물론 프로세스가 이러한 연산을 직접 수행하도록 방치하는 방법도 있지만, 아래와 같은 문제점이 생긴다.\n예를들어 프로세스가 입출력 권한을 직접 가지는 상황을 생각해보면, 파일을 직접 접근하기위해 접근권한등을 파일시스템에 구현해뒀는데, 해당 프로세스로 인해 무력화된다. 이 때문에 user mode와 같은 새로운 모드가 도입되었다, 이 모드에서 실행중인 프로세스에서 입출력요청을 직접 하게되면 프로세서는 예외를 발생시키고, 운영체제는 프로세스를 제거한다.\n반대는 계속 언급된 kernel mode이다, 이 모드에서는 운영체제가 모든것을 제어할 수 있다.\nuser mode와 kernel mode를 구분하는 것으로 특수한 연산에 대한 제어는 할 수 있게 되었다.\n하지만 다른 이슈 하나가 더 있는데 바로 특권 명령 (privileged operation)이다.\n디스크 읽기와 같은 실제 하드웨어 동작을 수행하기 위해서 필요한 일인데, 이것은 시스템콜 (system call)을 통해 수행된다.\n거의 모든 현대의 하드웨어들은 시스템 콜을 지원하고 있고, 표준은 POSIX를 찾아보면 확인 할 수 있다.\n시스템 콜을 사용하기 위해서 프로그램은 trap 명령어를 사용한다.\ntrap 명령어를 사용하면, privileged level을 kernel모드로 격상시키고, 시스템 콜을 수행할 수 있다.\n일련의 작업이 끝난 이후에는 return-from-trap 명령어를 사용하여 다시 user모드로 돌아온다.\ntrap 명령어를 사용할 때는 매우 신중해야하는데, 호출한 프로세스의 레지스터를 충분히 저장하고, 그로 인해 return-from-trap 명령어를 사용했을 때 실제 호출 프로세스로 제대로 리턴 할 수 있어야 한다.\n예를 들어 x86 아키텍처에서는, 프로그램 카운터, 플래그와 다른 몇 개의 레지스터를 각 프로세스의 커널 스택에 저장한다.\n그리고 return-from-trap 명령어가 커널 스택에서 pop해서 다시 usermode의 프로그램 실행을 하게 된다. (거의 대부분의 아키텍처에서 실제 구현은 다를 수 있어도 개념적으로는 이와 비슷한 방식으로 동작한다.)\n여기서 또 하나의 중요한 이슈는 어떻게 trap 이후에 OS 내부에서 어떠한 코드가 실행되어야 하는지를 알 수 있는가? 이다.\n호출한 프로세서가 명시해주는것은 매우 나쁜 아이디어이다, 주소를 명시하는것은 커널 내부의 원하는 지점을 접근 할 수 있다는 것이고, 그렇게 두는게 매우 위험하기 때문이다.\n대신에, 커널에 trap table을 두는 것으로 해결한다.\ntrap table은 부팅중에 세팅된다, machine이 부팅 될 때는 커널 모드로 동작되기 때문에, 모든 하드웨어를 마음대로 사용할 수 있다.\n그동안 운영체제가 하는 일은 하드웨어에게 특정한 이벤트가 발생 했을 때 어떤 코드를 실행해야 하는지를 알려주는 것이다.\n예를들어, 하드디스크가 인터럽트가 발생했을 때, 키보드 인터럽트가 발생했을 때, 프로그램이 인터럽트를 발생했을 때 등 인터럽트가 발생했을 때 어떤 코드를 실행해야 하는지를 알려주는 것이다.\n더 정확한 용어를 사용하면 trap handler라고 부르는데, 이것은 인터럽트가 발생했을 때 실행되어야 하는 코드를 가리킨다.\ntrap handler를 하드웨어에게 알려주면, 하드웨어는 해당 위치를 기억하고 있다가 시스템 콜과 같은 예외적인 사건이 발생했을 때 하드웨어는 어떤 코드 분기를 실행해야 하는지 알 수 있게 된다.\n시스템콜을 특정하기 위해 system-call number라는 것이 있으며, 사용자 프로그램은 원하는 시스템콜을 호출하기 위해서, 해당 시스템 콜 번호를 레지스터 또는 스택의 지정된 위치에 저장하고 trap을 호출한다.\n그러면 운영체제는 트랩 핸들러 내부에서 시스템콜을 처리하는데, 이 번호를 확인하고 일치하는 코드를 실행한다.\n즉 시스템 콜 번호를 통해서 시스템콜 주소를 찾아내고, 그 주소로 점프하여 시스템콜을 실행하는 방식의 간접적인 방식이 Protection을 제공한다.\n또한 하드웨어에게 trap table의 위치를 알려주는것은 매우 강력한 기능이며, 당연히 privileged operation이다.\n잠시 정리 프로세스가 모든 권한을 갖게 되면 두가지 이슈가 있는데 첫 번째는 protect system이 부재하고, 두 번째는 control execution이 부재하다.\nLimited Direct Execution은 프로세스가 특정한 연산을 수행할 수 있도록 하는데, 이것은 user mode와 kernel mode를 사용하여 구현되고 protect system을 해결하는 방법이다.\n유저모드에서 할 수 없는 일들(system call, privileged instruction)등을 분리하고 커널에서만 실행이 가능하도록 했다.\n커널의 진입은 trap 명령어를 사용한다.\n커널에서 실제로 실행되는 코드를 직접 알게하면 위험하기 때문에 trap table을 사용한다.\ntrap table은 trap handler의 주소를 가지는 테이블이다.\ntrap table은 부팅시에 설정되며, 하드웨어에게 어떤 코드(= 트랩 핸들러에 있는 코드)를 실행해야 하는지 알려준다.\n여기서 살짝 헷갈릴 수 있는 부분은 트랩 테이블에 있는 주소는 시스템콜의 주소가 아니라, 시스템콜이 필요할때 사용 할 수 있는 트랩 핸들러의 주소이다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; int main() { #define SYS_CUSTOM_SYSCALL 333 long result = syscall(SYS_CUSTOM_SYSCALL); if (result == 0) { printf(\u0026#34;System call was successful!\\n\u0026#34;); } else { printf(\u0026#34;System call failed!\\n\u0026#34;); } return 0; } 위의 코드에서 예를 들어보면, syscall() 함수를 사용하여 시스템 콜을 호출한다.\n내부적으로 \u0026lsquo;시스템 콜에 대한 트랩 핸들러가 호출되고\u0026rsquo;, 해당 핸들로에서 시스템 콜 번호에 해당하는 코드를 실행한다. (이부분이 가장 헷갈림)\n6.3 문제점 2: 두 프로세스 사이에 스위칭 하기 (두 번째 이슈 해결하기) 프로세스를 switch 하는 것은 매우 간단해 보인다, 하나를 멈추고 다른 하나를 시작하면 될 것 같다.\n운영체제도 프로그램이라는것을 인지하면 문제가 tricky해진다.\n하나의 프로세스가 실행중이란 이야기는 os라는 프로그램이 cpu에서 실행중이지 않는다는 이야기이다.\n\u0026lsquo;실행중\u0026rsquo;이지 않은 상태에서 어떻게 액션을 취할 수 있을까?\n핵심 질문 : 어떻게 프로세스로부터 CPU 제어권을 다시 가져올 수 있을까?\n6.3 협동적인 접근 방법 : System Call을 기다리기 예전에 주로 채택되었던 해결책 중 하나는 cooperative 방식이다.\nOS는 프로세스가 합리적으로 동작할 것 이라고 신뢰하고, 프로세스 스스로 너무 오래 점유하거나 하면 운영체제로 제어권을 넘겨주는 방식이다.\n대부분의 프로세스들은 기대한대로 동작했고, 운영체제로 제어권을 넘겨주는 system call을 잘 사용했다.\n이러한 시스템에서는 yield()라는 시스템 콜을 사용하여 제어권을 넘겨주는 방식이 사용되었다.\n그리고 의도치 않게 동작하는 상황에서도, 프로세스를 스스로 정리하려는 시도를 하게 된다.\n이러한 협동 방식을 생각하면 다음과 같은 의심이 들기 시작한다.\n너무 수동적인게 아닌가? 프로그램이 무한루프에 빠지면 어떻게 되는가? 6.4 비협동적인 접근 방법 : OS Takes Control 협동적인 방식의 문제점들이 대두되고 있었다, 특히 무한루프와 같은 경우에는 재부팅 밖에 방법이 없었다.\n이러한 문제들은 아까 이야기한 해결책을 다시 찾도록 되돌리게 되었다\n핵심 질문 : 어떻게 프로세스로부터 CPU 제어권을 다시 가져올 수 있을까?\n이러한 문제를 해결하기 위해 timer interrupt를 사용한다.\ntimer interrupt는 정해진 시간이 지나면 발생하는 인터럽트이다.\n이 인터럽트는 미리 설정된 interrupt handler를 실행하게 되는데, 이렇게 하는 것 만으로도 운영체제는 프로세스로부터 제어권을 다시 가져올 수 있다.\n운영체제는 인터럽트에서 마찬가지로, 실행해야 할 코드의 주소를 기록해둬야 한다. (이것이 바로 interrupt handler이다.)\n인터럽트가 발생하면, 운영체제는 해당 주소로 점프하여 코드를 실행한다.\n즉 타이머 인터럽트가 발생하면, 운영체제는 현재 실행중인 프로세스를 멈추고, (아마도 일반적으로)다른 프로세스로 전환하는 코드를 실행한다.\n6.5 Saving and Restoring Context OS가 제어권을 얻었을 때, (그게 인터럽트든, 협력적인 방식이든) 결정을 내려야 한다 : 지금 실행중인 프로세스를 실행할 것인가? 아니면 다른 프로세스로 전환할 것인가?\n여기서 이 결정을 내려주는 시스템은 scheduler (스케줄러는 정책에 따라서 프로세스를 선택하는 역할을 하는데, 해당 정책은 다음 챕터에서!)\n만약 switch로 결정이 내려진다면, 운영체제는 context switch라 불리는 low-level operation을 수행해야 한다.\ncontext switch는 현재 실행중인 프로세스의 상태를 저장하고, 다음 실행할 프로세스의 상태를 복원하는 것이다. (저장도 복원도 일반적으로는 커널 스택에서)\n이러한 것들이 수행된 이후 OS는 return-from-trap 명령어 실행 이후에 다음 프로세스를 실행된다는 것을 알 수 있다.\ncontext switch가 발생했을 때 프로세스에서 저장해야 할 정보는 다음과 같다\n레지스터 값 커널 스택 포인터 프로세스 상태 (running, ready, blocked) 등 context switch가 발생했을 때 저장/복원이 두 번 일어나는것을 이해해야 한다.\n첫 번째는 현재 실행중인 프로세스의 상태를 저장하는 것이고, 두 번째는 커널 레지스터를 전환될 프로세스 구조체에 저장된다, 이것으로 인해 두번째 프로세스가 레지스터를 복원할 수 있다.\n두 번째 복원 작업으로 인해, 1번 프로세스로 인해 커널로 진입했지만, 2번 프로세스 실행중에 커널로 트랩한것처럼 보이게 된다.\n6.6 동시성이 걱정되시나요? 똑똑하다면 이제 concurrency에 대해 걱정할 수 있을 것이다. 만약 시스템 콜을 처리하는 중에 다른 시스템콜이 발생한다면 어떻게 될까? 반대로 인터럽트를 핸들링 하는 중에 다른 인터럽트가 발생한다면 어떻게 될까?\n당장 다룰 주제는 아니고 가장 간단한 해법을 생각하면, 인터럽트를 disable하는 것이다. 인터럽트를 disable하면, 다른 인터럽트가 발생하지 않지만, 손실되는 인터럽트가 생기게 된다.\n사실 실제로는 lock이라는 것을 사용하는데, 실제로 매우 복잡하게 구현되어 있어 운영체제의 복잡도를 높이게 된다.\n7.0 스케줄링: 개요 운영체제 수업에서 가장 핵심 주제라 여러번 보는 내용이 스케줄링이다. 이 장은 스케줄링 정책에 대해서 다룬다.\n스케줄링의 기원은 컴퓨터 등장 이전에도 존재했다. 예를 들어, 공장에서 작업을 할당하는 것(Operation Management)이 스케줄링의 예시이다.\n핵심 질문: 스케줄링 정책은 어떻게 개발하는가\n7.1 워크로드에 대한 가정 먼저 프로세스 동작에 대한 몇가지 가정을 해야 한다, 프로세스가 동작하는 일련의 행위를 워크로드라 한다.\n워크로드의 선정은 매우 중요한 일이다, 실제로는 매우 어려운 일이다, 다만 이번 장에서는 비현실적일 정도로 간단한 워크로드를 가정한다.\n그리고 나중에 실제 워크로드를 다루는 방법에 대해서도 다룰 것이다.\n각각의 프로세스는 동일한 시간 동안 실행된다. 모든 프로세스는 동일한 시간에 도착한다. 일단 시작되면, 각각의 프로세스는 완료된다. 프로세스는 CPU만 사용한다. 각각의 프로세스의 실행시간은 알려져 있다. 7.2 스케줄링의 평가 항목 스케줄링의 평가 항목은 다양하지만 대표적인 것들은 아래와 같다.\nturnaround time : 프로세스가 도착한 시간부터 완료될 때까지 걸리는 시간 turnaround time = completion time - arrival time\nfairness : 모든 프로세스가 얼마나 공평하게 CPU를 사용하는가\n참고로 성능과 공정성은 trade-off 관계이다.\n7.3 FIFO 가장 간단한 스케줄링 정책은 FIFO이다.\nFIFO는 First In First Out의 약자로, 가장 먼저 도착한 프로세스가 가장 먼저 CPU를 사용하는 방식이다.\nFIFO는 매우 간단하고 구현하기 쉽다.\nA : 10, B : 10, C : 10 라는 프로세스가 있다고 가정하면, FIFO는 아래와 같이 동작한다.\ntime 0 : A, B, C도착 time 10 : A 완료 time 20 : B 완료 time 30 : C 완료 turnaround time은 각각 10, 20, 30이다, 즉 평균 turnaround time은 20이다.\n이제 1번의 가정을 변경해보자, A : 100, B : 10, C : 10이라는 프로세스가 있다고 가정하면, FIFO는 아래와 같이 동작한다.\ntime 0 : A, B, C 도착 time 100 : A 완료 time 110 : B 완료 time 120 : C 완료 turnaround time은 각각 100, 110, 120이다, 즉 평균 turnaround time은 110이다.\nFIFO의 문제점은 convoy effect이다, convoy effect는 긴 프로세스가 먼저 도착하면, 뒤에 도착한 프로세스들이 기다려야 하는 현상을 말한다.\n마트에서 나는 콜라 하나만 계산하려고 하는데, 내 앞에 카트 세개를 풀로 채운 사람이 계산하고 있다면\u0026hellip;?\n7.4 최단 작업 우선 (SJF) FIFO의 문제점을 해결하기 위한 방법 중 하나는 Shortest Job First이다.\nSJF는 가장 짧은 프로세스가 가장 먼저 CPU를 사용하는 방식이다.\nA : 100, B : 10, C : 10 시나리오를 다시 보자\ntime 0 : A, B, C 도착 time 10 : B 완료 time 20 : C 완료 time 120 : A 완료 turnaround time은 각각 100, 10, 20이다, 즉 평균 turnaround time은 43.3이다.\n동일한 시간에 도착하는 프로세스의 경우, SJF는 최적의 성능을 보여준다.\n인생은 쉽지 않으니 2번의 가정을 무력화 해보자, A : (100, 0), B : (10, 10), C : (10, 10) 시나리오를 다시 보자(첫 번째 숫자는 실행시간, 두 번째 숫자는 도착시간)\ntime 0 : A 도착 time 10 : B, C 도착 time 100 : A 완료 time 110 : B 완료 time 120 : C 완료 turnaround time은 각각 100, 100, 110이다, 즉 평균 turnaround time은 103.3이다. (다시 convoy effect가 발생했다) 7.5 최소 잔여 시간 우선 (STCF) SJF의 변형으로 Shortest Time-to-Completion First이다.\nSTCF는 가장 짧은 남은 실행시간을 가진 프로세스가 가장 먼저 CPU를 사용하는 방식이다.\nSTCF는 SJF와 비슷하지만, STCF는 프로세스가 도착할 때마다 스케줄링을 다시 수행한다.\nA : (100, 0), B : (10, 10), C : (10, 10) 시나리오를 다시 보자\ntime 0 : A 도착 time 10 : B, C 도착 time 10 : B 완료 time 20 : C 완료 time 120 : A 완료 turnaround time은 각각 120, 10, 20이다, 즉 평균 turnaround time은 50이다.\nSTCF는 SJF보다 더 좋은 성능을 보여준다.\n7.6 새로운 평가 기준 : Response Time Response Time은 프로세스가 처음으로 CPU를 사용하기까지 걸리는 시간을 말한다. (처음으로 스케줄 될 때까지의 시간)\nResponse = first time - arrival time\nSTCF를 비롯해서 비슷한 정책들은 응답시간이 짧다고 보장할 수 없다.\n예를 들어, A : (100, 0), B : (1, 10) 시나리오를 보자\ntime 0 : A 도착 time 10 : B 도착 time 100 : A 완료 time 101 : B 완료 B는 10초 동안 기다려야 하지만, STCF는 A를 먼저 처리하기 때문에 B는 90초 동안 기다려야 한다.\n이러한 문제를 해결하기 위해 Round Robin이라는 정책이 등장한다.\n7.7 라운드 로빈 (Round Robin) Round Robin은 각 프로세스에게 동일한 시간을 할당하는 방식이다.\nRR은 작업이 끝날 때 까지 기다리지 않고, 다른 프로세스로 전환한다.\n이 때 작업이 실행되는 시간을 time slice, 또는 scheduler quantum이라고 한다.\nRR은 타이머 인터럽트의 배수로 동작한다.\nA : 100, B : 10, C : 10 시나리오를 다시 보자\ntime 0 : A, B, C 도착 time 10 : A 실행, B, C 대기 time 20 : A 완료, B 실행, C 대기 time 30 : B 완료, C 실행 time 40 : C 완료 ... 타임 슬라이스의 시간이 짧아질수록, 성능의 기준이 응답시간일수록 RR은 좋은 성능을 보여준다.\n하지만 타임 슬라이스가 너무 짧으면, context switch로 인한 오버헤드가 발생할 수 있다.\ncontext switch를 상쇄할 만큼 길어야하지만, 응답시간이 너무 길어지지 않도록 적절한 타임 슬라이스를 선택해야 한다.\n반환 시간이 가장 중요한 경우에는 반대로 RR은 좋은 성능을 보여주지 못한다.\n이것은 RR과 같이 공정한 정책(CPU를 공평하게 나눠쓰는 정책)은 반환 시간 기준으로는 성능이 좋지 않다는 것을 의미한다.\n일단 응답시간, 반환시간을 기준으로 좋은 성능을 가지는 정책들을 알아봤다.\n하지만 아직도 완화하지 않은 두가지 가정이 있다. (작업은 입출력을 하지 않는다, 각 작업의 실행시간을 알고 있다)\n7.8 입출력 연산의 고려 가정 4를 완화해보자, 프로세스는 CPU만 사용하는 것이 아니라 입출력도 사용한다.\n만약 지금 실행중인 프로세스가 입출력을 요청하면, 스케줄러는 다음에 어떤 작업을 실행할지 결정해야 한다.\n현재 실행 중인 프로세스는 입출력이 끝날 때까지 기다려야 한다. 왜냐하면 입출력이 끝나기 전까지 작업을 대기해야 하기 때문이다.\n반대로 입출력이 끝난 프로세스도 의사 결정을 해야한다. 입출력이 완료되면 인터럽트가 발생하고, 이때 스케줄러는 어떤 작업을 실행할지 결정해야 한다.\n위의 그림은 입출력이 끝난 프로세스가 CPU를 사용하지 않는 시간을 보여준다.\n반면 STCF 스케줄링 정책을 사용한 케이스\n7.9 만병 통치약은 없다 (No More Oracle) 간단한 스케줄링 정책들을 살펴봤다, 각각 극단적인 장단점을 가지고 있다.\n거기에 아직도 보호받는 가정이 있다, 실제로는 프로세스는 입출력을 하고, 실행시간을 알 수 없다.\n아무런 사전지식 없이 SJF/STCF 처럼 행동하는 알고리즘은 없을까?\n추가적으로 RR 스케줄러의 장점을 살리는 방법은 없을까?\n7.10 다음 장에서\u0026hellip; (요약) 다음 장에서는 더 정확한 스케줄링에 필요한 것들을 살펴볼 것이다.\n정확한 스케줄링을 위해서는 미래 동작을 예측할 수 있는 방법이 필요하다.\n프로세서의 미래 동작을 예측함에 있어 과거 동작 이력을 반영하는 방법이 필요하다.\n이 스케줄러를 멀티 레벨 피드백 큐라고 부르며 다음 장에서 다룰 예정이다.\n","permalink":"http://localhost:1313/_wiki/week-02/","summary":"05.0 막간 : 프로세스 API 거의 모든 소스코드와 강의자료는 아래 링크가 출처 입니다.\n강의 소스코드 : OSTEP 테스트 프로그램 : OSTEP Test Programs 역자 강의 자료 : 강의자료 개념적인 내용이 아닌 실제적인 측면에서 코드를 보는 장은 막간이라고 별도 표기한다.\n이번 절에서는, Unix 시스템의 프로세스 생성에 관해 배운다.\nUnix는 프로세스를 생성하는 시스템콜로 다음 두가지를 제공한다.\nfork()\nexec()\n그리고 wait() 함수를 통해 자식 프로세스가 종료될 때까지 기다릴 수 있다.\n핵심 질문 : 프로세스를 생성하고 제어하는 방법, 프로세스를 생성하고 제어하려면 운영체제가 어떤 인터페이스를 제공해야 하는가?","title":"운영체제 아주 쉬운 세 가지 이야기 📚"},{"content":"01. 명확하고 가장 좋은 기준 1 - 어찌보면 가장 당연하게도, 가장 중요한 기준은 내가 가장 익숙한 언어이다.\n아무래도 기존에 사용하는 언어를 사용하면, std나 기본 라이브러리에 대한 이해도가 확실하고,\n문법적인 부분에서도 손이 바로 나갈 수 있다는 것이 가장 큰 장점이다.\n특히나 대부분의 코딩 테스트는 직군이 갈려 있기 때문에, 내가 자주 사용하는 언어를 내가 가고싶은 회사의 인터뷰에서 지원 할 확률이 높다.\n02. 명확하고 가장 좋은 기준 2 - 파이썬 모든 기준을 무시하고서라도 파이썬은 한 번쯤 고려해볼만한 언어이다\n간결하고 강력한 문법을 가지고 있다. 문법 간결한건 굳이 설명 안해도 되고, 어지간한 포매팅이나 정규식, 문자열 다루는 메서드 등은 기본 문법에 내장되어 있다.\n초 강력한 범용성 (코테에서 가장 중요한 요소 중 하나, 아직 파이썬을 지원 안하는 코테는 만나보지 못했다.)\n위와 같은 이유로 매우 익숙한 언어가 있어도 파이썬은 한 번쯤 고려해볼만한 언어이다.\n참고로 파이썬의 속도를 단점으로 지적하시는 분들도 계신데, PS대회급이 아닌 취업용 코테에서는 언어 자체의 성능으로 인해 달라지는 경우는 사실상 없다고 봐도 무방하다.\n03. 근데 난 왜 이렇게 고민을 많이 할까? 파이썬이 싫다 지금 회사에서 주로 사용하는 자바는 간혹 지원하지 않거나, 코테에서 언어 자체로 이점이 있다고 보긴 힘들다. 그렇다고 cpp를 선택하자니, cpp와 담을 쌓은지 너무 오래다.. 러스트는 아직 코테에서 지원 안하는 곳이 많다 (99%\u0026hellip;.) 파이썬이 싫은 이유 :\n파이썬이 안좋아서가 절대 아니다. 일단 코테에서 동적 타입언어를 쓰는게 뭔가 오히려 더 적응이 안되고 불편함. java 다음으로 ts를 많이 사용하는데, 뭔가 ts와 닮아있으면서 애매하게 다르니까 실수를 더 많이함 들여쓰기로 블록 구분되는게 진짜 정말 너무 심하게 헷갈림(개인적인 문제이지만, 이게 파이썬을 못쓰겠는 가장 큰 이유인듯) 결론은 본인 숙련도 이슈이다. 자바 안쓰는 이유 :\n빈도는 요즘은 매우 낮지만, 찾아본 20군데의 회사중에 3군데 정도 지원을 안하는 곳이 있었다. 자바를 못 쓸 때 파이썬을 쓰기 싫다.. 04. 결론 그러던 중 운영체제 스터디까지 시작하면서 결국 다시 c를 봐야 했고, 결론이 나버렸다. cpp 문법을 열심히 다시 보고 있다. ","permalink":"http://localhost:1313/_wiki/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%96%B8%EC%96%B4-%EC%A0%95%ED%95%98%EA%B8%B0/","summary":"놀랍게도 언어 정하는데도 시간이 많이 필요하다..","title":"코딩 테스트 언어 정하기"},{"content":"Vim Improve Sheet 🦅 Vim Improve Sheet 라고 작성했는데, 사실 안좋은 습관을 고치기 위한 시트라고 생각하면 더 좋을 것 같다. 뭔가 분명히 더 나은 방법이 있을 것 같은데, 당장 알아보기 귀찮아서 그냥 넘어가는 습관을 고치기 위한 시트이다.\n01. Vim으로 따옴표 씌우기 nvim-surround 플러그인을 이용한다 (\u0026ldquo;kylechui/nvim-surround\u0026rdquo;)\n별 표시된 부분이 커서의 위치를 나타낸다.\nOld text Command New text\nsurr*ound_words ysiw) (surround_words) *make strings ys$\u0026quot; \u0026quot;make strings\u0026quot; [delete ar*ound me!] ds] delete around me! remove \u0026lt;b\u0026gt;HTML t*ags\u0026lt;/b\u0026gt; dst remove HTML tags 'change quot*es' cs'\u0026quot; \u0026quot;change quotes\u0026quot; \u0026lt;b\u0026gt;or tag* types\u0026lt;/b\u0026gt; csth1\u0026lt;CR\u0026gt; \u0026lt;h1\u0026gt;or tag types\u0026lt;/h1\u0026gt; delete(functi*on calls) dsf function calls 02. [ ] 복사 붙여넣기 남들은 어떻게 편하게 하는지 확인하기 04. 주석 관련 커맨드 shift + v : 블록 선택 : + norm + i// : 블록 주석 처리 : + norm + x : 블록 주석 해제 (앞에 글자 삭제) ","permalink":"http://localhost:1313/_wiki/vim-impove-sheet/","summary":"Vim Improve Sheet 🦅 Vim Improve Sheet 라고 작성했는데, 사실 안좋은 습관을 고치기 위한 시트라고 생각하면 더 좋을 것 같다. 뭔가 분명히 더 나은 방법이 있을 것 같은데, 당장 알아보기 귀찮아서 그냥 넘어가는 습관을 고치기 위한 시트이다.\n01. Vim으로 따옴표 씌우기 nvim-surround 플러그인을 이용한다 (\u0026ldquo;kylechui/nvim-surround\u0026rdquo;)\n별 표시된 부분이 커서의 위치를 나타낸다.\nOld text Command New text\nsurr*ound_words ysiw) (surround_words) *make strings ys$\u0026quot; \u0026quot;make strings\u0026quot; [delete ar*ound me!] ds] delete around me!","title":"Vim Improve Sheet 🦅"},{"content":"추석 민숙이와 함께하는 일본 여행 ❤️ 00. 참고 링크 📌 교토 주요 관광지 [[회화-정리-링크]] 교토 여행 코스 교토 오사카 여행 코스 일본 지하철 코드 오사카 주요 관광지 01. 여행 준비 체크리스트 🇯 여권 확인 환전 필요한 의류 준비 세면도구 준비 충전기 및 어댑터 준비 여행가방 준비 로밍 선물 챙기기 02. 여행 일정 😊 09월 13일 (금) 오전 : 출국 오후 : 호텔 체크인, 아라시야마 방문 저녁 : 시간 보고 근처에서 식사 하고 마무리 숙박 : 굿 네이처 호텔 교토 전화번호: +81-75-3526730 참고 : 사가노-토롯코 열차 참고 : 대나무숲 후기 참고 : 아라시야마 관련 가이드 JR 하루카 공항 특급열차 편도티켓 (시간 제한 없음) 09월 14일 (토) 오전 : 청수사, 니넨자카, 산넨자카(교통편 확인) 오후 : 은각사, 교토타워 저녁 : 기온 거리에서 저녁 식사 숙박 : 연박 참고 : 청수사 관련 가이드/교통편 09월 15일 (일) 오전 : 후시미 이나리 신사, 나고야 이동 오후 : 오아시스 21, 나고야 성 (가능하면) 저녁 : 나고야에서 저녁 식사(맛집 찾을 예정) 숙박 : 호텔 케이한 나고야 교토역에서 나고야역 이동 (차량번호 Nozomi 94) 13:45분 출발 09월 16일 (월) 오전 : 지브리 😍 오후 : 지브리 😍 저녁 : 지브리 😍 저녁 맛집을 박아넣을 예정 숙박 : 연박 09월 17일 (화) 오전 : 오사카 이동 오후 : 도톤보리, 오사카 성 (미정) 저녁 : 도톤보리에서 저녁 식사 (맛집 찾을 예정) 숙박 : 호텔 한큐 오사카 나고야역에서 오사카역 이동 (차량번호 Nozomi 21) 11:00 출발 09월 18일 (수) 오전 : 유니버셜 스튜디오 재팬 🎢 오후 : 유니버셜 스튜디오 재팬 🎢 저녁 : 유니버셜 스튜디오 재팬 🎢 숙박 : 연박 09월 19일 (목) 오전 : 귀국 준비 오사카 - 간사이 공항 리무진 버스 이용(시간 제한 없음) ","permalink":"http://localhost:1313/_wiki/2024-%EC%B6%94%EC%84%9D-%EC%9D%BC%EB%B3%B8%EC%97%AC%ED%96%89/","summary":"추석 민숙이와 함께하는 일본 여행 ❤️ 00. 참고 링크 📌 교토 주요 관광지 [[회화-정리-링크]] 교토 여행 코스 교토 오사카 여행 코스 일본 지하철 코드 오사카 주요 관광지 01. 여행 준비 체크리스트 🇯 여권 확인 환전 필요한 의류 준비 세면도구 준비 충전기 및 어댑터 준비 여행가방 준비 로밍 선물 챙기기 02. 여행 일정 😊 09월 13일 (금) 오전 : 출국 오후 : 호텔 체크인, 아라시야마 방문 저녁 : 시간 보고 근처에서 식사 하고 마무리 숙박 : 굿 네이처 호텔 교토 전화번호: +81-75-3526730 참고 : 사가노-토롯코 열차 참고 : 대나무숲 후기 참고 : 아라시야마 관련 가이드 JR 하루카 공항 특급열차 편도티켓 (시간 제한 없음) 09월 14일 (토) 오전 : 청수사, 니넨자카, 산넨자카(교통편 확인) 오후 : 은각사, 교토타워 저녁 : 기온 거리에서 저녁 식사 숙박 : 연박 참고 : 청수사 관련 가이드/교통편 09월 15일 (일) 오전 : 후시미 이나리 신사, 나고야 이동 오후 : 오아시스 21, 나고야 성 (가능하면) 저녁 : 나고야에서 저녁 식사(맛집 찾을 예정) 숙박 : 호텔 케이한 나고야 교토역에서 나고야역 이동 (차량번호 Nozomi 94) 13:45분 출발 09월 16일 (월) 오전 : 지브리 😍 오후 : 지브리 😍 저녁 : 지브리 😍 저녁 맛집을 박아넣을 예정 숙박 : 연박 09월 17일 (화) 오전 : 오사카 이동 오후 : 도톤보리, 오사카 성 (미정) 저녁 : 도톤보리에서 저녁 식사 (맛집 찾을 예정) 숙박 : 호텔 한큐 오사카 나고야역에서 오사카역 이동 (차량번호 Nozomi 21) 11:00 출발 09월 18일 (수) 오전 : 유니버셜 스튜디오 재팬 🎢 오후 : 유니버셜 스튜디오 재팬 🎢 저녁 : 유니버셜 스튜디오 재팬 🎢 숙박 : 연박 09월 19일 (목) 오전 : 귀국 준비 오사카 - 간사이 공항 리무진 버스 이용(시간 제한 없음) ","title":"추석 일본여행"},{"content":"source code : process-run.py link : https://github.com/remzi-arpacidusseau/ostep-homework/blob/master/cpu-intro/process-run.py\n#! /usr/bin/env python from __future__ import print_function import sys from optparse import OptionParser import random # to make Python2 and Python3 act the same -- how dumb def random_seed(seed): try: random.seed(seed, version=1) except: random.seed(seed) return # process switch behavior SCHED_SWITCH_ON_IO = \u0026#39;SWITCH_ON_IO\u0026#39; SCHED_SWITCH_ON_END = \u0026#39;SWITCH_ON_END\u0026#39; # io finished behavior IO_RUN_LATER = \u0026#39;IO_RUN_LATER\u0026#39; IO_RUN_IMMEDIATE = \u0026#39;IO_RUN_IMMEDIATE\u0026#39; # process states STATE_RUNNING = \u0026#39;RUNNING\u0026#39; STATE_READY = \u0026#39;READY\u0026#39; STATE_DONE = \u0026#39;DONE\u0026#39; STATE_WAIT = \u0026#39;BLOCKED\u0026#39; # members of process structure PROC_CODE = \u0026#39;code_\u0026#39; PROC_PC = \u0026#39;pc_\u0026#39; PROC_ID = \u0026#39;pid_\u0026#39; PROC_STATE = \u0026#39;proc_state_\u0026#39; # things a process can do DO_COMPUTE = \u0026#39;cpu\u0026#39; DO_IO = \u0026#39;io\u0026#39; DO_IO_DONE = \u0026#39;io_done\u0026#39; class scheduler: def __init__(self, process_switch_behavior, io_done_behavior, io_length): # keep set of instructions for each of the processes self.proc_info = {} self.process_switch_behavior = process_switch_behavior self.io_done_behavior = io_done_behavior self.io_length = io_length return def new_process(self): proc_id = len(self.proc_info) self.proc_info[proc_id] = {} self.proc_info[proc_id][PROC_PC] = 0 self.proc_info[proc_id][PROC_ID] = proc_id self.proc_info[proc_id][PROC_CODE] = [] self.proc_info[proc_id][PROC_STATE] = STATE_READY return proc_id # program looks like this: # c7,i,c1,i # which means # compute for 7, then i/o, then compute for 1, then i/o def load_program(self, program): proc_id = self.new_process() for line in program.split(\u0026#39;,\u0026#39;): opcode = line[0] if opcode == \u0026#39;c\u0026#39;: # compute num = int(line[1:]) for i in range(num): self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE) elif opcode == \u0026#39;i\u0026#39;: self.proc_info[proc_id][PROC_CODE].append(DO_IO) # add one compute to HANDLE the I/O completion self.proc_info[proc_id][PROC_CODE].append(DO_IO_DONE) else: print(\u0026#39;bad opcode %s (should be c or i)\u0026#39; % opcode) exit(1) return def load(self, program_description): proc_id = self.new_process() tmp = program_description.split(\u0026#39;:\u0026#39;) if len(tmp) != 2: print(\u0026#39;Bad description (%s): Must be number \u0026lt;x:y\u0026gt;\u0026#39; % program_description) print(\u0026#39; where X is the number of instructions\u0026#39;) print(\u0026#39; and Y is the percent change that an instruction is CPU not IO\u0026#39;) exit(1) num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0 for i in range(num_instructions): if random.random() \u0026lt; chance_cpu: self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE) else: self.proc_info[proc_id][PROC_CODE].append(DO_IO) # add one compute to HANDLE the I/O completion self.proc_info[proc_id][PROC_CODE].append(DO_IO_DONE) return def move_to_ready(self, expected, pid=-1): if pid == -1: pid = self.curr_proc assert(self.proc_info[pid][PROC_STATE] == expected) self.proc_info[pid][PROC_STATE] = STATE_READY return def move_to_wait(self, expected): assert(self.proc_info[self.curr_proc][PROC_STATE] == expected) self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT return def move_to_running(self, expected): assert(self.proc_info[self.curr_proc][PROC_STATE] == expected) self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING return def move_to_done(self, expected): assert(self.proc_info[self.curr_proc][PROC_STATE] == expected) self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE return def next_proc(self, pid=-1): if pid != -1: self.curr_proc = pid self.move_to_running(STATE_READY) return for pid in range(self.curr_proc + 1, len(self.proc_info)): if self.proc_info[pid][PROC_STATE] == STATE_READY: self.curr_proc = pid self.move_to_running(STATE_READY) return for pid in range(0, self.curr_proc + 1): if self.proc_info[pid][PROC_STATE] == STATE_READY: self.curr_proc = pid self.move_to_running(STATE_READY) return return def get_num_processes(self): return len(self.proc_info) def get_num_instructions(self, pid): return len(self.proc_info[pid][PROC_CODE]) def get_instruction(self, pid, index): return self.proc_info[pid][PROC_CODE][index] def get_num_active(self): num_active = 0 for pid in range(len(self.proc_info)): if self.proc_info[pid][PROC_STATE] != STATE_DONE: num_active += 1 return num_active def get_num_runnable(self): num_active = 0 for pid in range(len(self.proc_info)): if self.proc_info[pid][PROC_STATE] == STATE_READY or \\ self.proc_info[pid][PROC_STATE] == STATE_RUNNING: num_active += 1 return num_active def get_ios_in_flight(self, current_time): num_in_flight = 0 for pid in range(len(self.proc_info)): for t in self.io_finish_times[pid]: if t \u0026gt; current_time: num_in_flight += 1 return num_in_flight def check_for_switch(self): return def space(self, num_columns): for i in range(num_columns): print(\u0026#39;%10s\u0026#39; % \u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) def check_if_done(self): if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0: if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING: self.move_to_done(STATE_RUNNING) self.next_proc() return def run(self): clock_tick = 0 if len(self.proc_info) == 0: return # track outstanding IOs, per process self.io_finish_times = {} for pid in range(len(self.proc_info)): self.io_finish_times[pid] = [] # make first one active self.curr_proc = 0 self.move_to_running(STATE_READY) # OUTPUT: headers for each column print(\u0026#39;%s\u0026#39; % \u0026#39;Time\u0026#39;, end=\u0026#39;\u0026#39;) for pid in range(len(self.proc_info)): print(\u0026#39;%14s\u0026#39; % (\u0026#39;PID:%2d\u0026#39; % (pid)), end=\u0026#39;\u0026#39;) print(\u0026#39;%14s\u0026#39; % \u0026#39;CPU\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;%14s\u0026#39; % \u0026#39;IOs\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) # init statistics io_busy = 0 cpu_busy = 0 while self.get_num_active() \u0026gt; 0: clock_tick += 1 # check for io finish io_done = False for pid in range(len(self.proc_info)): if clock_tick in self.io_finish_times[pid]: io_done = True self.move_to_ready(STATE_WAIT, pid) if self.io_done_behavior == IO_RUN_IMMEDIATE: # IO_RUN_IMMEDIATE if self.curr_proc != pid: if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING: self.move_to_ready(STATE_RUNNING) self.next_proc(pid) else: # IO_RUN_LATER if self.process_switch_behavior == SCHED_SWITCH_ON_END and self.get_num_runnable() \u0026gt; 1: # this means the process that issued the io should be run self.next_proc(pid) if self.get_num_runnable() == 1: # this is the only thing to run: so run it self.next_proc(pid) self.check_if_done() # if current proc is RUNNING and has an instruction, execute it instruction_to_execute = \u0026#39;\u0026#39; if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\ len(self.proc_info[self.curr_proc][PROC_CODE]) \u0026gt; 0: instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0) cpu_busy += 1 # OUTPUT: print what everyone is up to if io_done: print(\u0026#39;%3d*\u0026#39; % clock_tick, end=\u0026#39;\u0026#39;) else: print(\u0026#39;%3d \u0026#39; % clock_tick, end=\u0026#39;\u0026#39;) for pid in range(len(self.proc_info)): if pid == self.curr_proc and instruction_to_execute != \u0026#39;\u0026#39;: print(\u0026#39;%14s\u0026#39; % (\u0026#39;RUN:\u0026#39;+instruction_to_execute), end=\u0026#39;\u0026#39;) else: print(\u0026#39;%14s\u0026#39; % (self.proc_info[pid][PROC_STATE]), end=\u0026#39;\u0026#39;) # CPU output here: if no instruction executes, output a space, otherwise a 1 if instruction_to_execute == \u0026#39;\u0026#39;: print(\u0026#39;%14s\u0026#39; % \u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) else: print(\u0026#39;%14s\u0026#39; % \u0026#39;1\u0026#39;, end=\u0026#39;\u0026#39;) # IO output here: num_outstanding = self.get_ios_in_flight(clock_tick) if num_outstanding \u0026gt; 0: print(\u0026#39;%14s\u0026#39; % str(num_outstanding), end=\u0026#39;\u0026#39;) io_busy += 1 else: print(\u0026#39;%10s\u0026#39; % \u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) # if this is an IO start instruction, switch to waiting state # and add an io completion in the future if instruction_to_execute == DO_IO: self.move_to_wait(STATE_RUNNING) self.io_finish_times[self.curr_proc].append(clock_tick + self.io_length + 1) if self.process_switch_behavior == SCHED_SWITCH_ON_IO: self.next_proc() # ENDCASE: check if currently running thing is out of instructions self.check_if_done() return (cpu_busy, io_busy, clock_tick) # # PARSE ARGUMENTS # parser = OptionParser() parser.add_option(\u0026#39;-s\u0026#39;, \u0026#39;--seed\u0026#39;, default=0, help=\u0026#39;the random seed\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;int\u0026#39;, dest=\u0026#39;seed\u0026#39;) parser.add_option(\u0026#39;-P\u0026#39;, \u0026#39;--program\u0026#39;, default=\u0026#39;\u0026#39;, help=\u0026#39;more specific controls over programs\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;program\u0026#39;) parser.add_option(\u0026#39;-l\u0026#39;, \u0026#39;--processlist\u0026#39;, default=\u0026#39;\u0026#39;, help=\u0026#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an IO (i.e., if Y is 100, a process will ONLY use the CPU and issue no I/Os; if Y is 0, a process will only issue I/Os)\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;process_list\u0026#39;) parser.add_option(\u0026#39;-L\u0026#39;, \u0026#39;--iolength\u0026#39;, default=5, help=\u0026#39;how long an IO takes\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;int\u0026#39;, dest=\u0026#39;io_length\u0026#39;) parser.add_option(\u0026#39;-S\u0026#39;, \u0026#39;--switch\u0026#39;, default=\u0026#39;SWITCH_ON_IO\u0026#39;, help=\u0026#39;when to switch between processes: SWITCH_ON_IO, SWITCH_ON_END\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;process_switch_behavior\u0026#39;) parser.add_option(\u0026#39;-I\u0026#39;, \u0026#39;--iodone\u0026#39;, default=\u0026#39;IO_RUN_LATER\u0026#39;, help=\u0026#39;type of behavior when IO ends: IO_RUN_LATER, IO_RUN_IMMEDIATE\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;io_done_behavior\u0026#39;) parser.add_option(\u0026#39;-c\u0026#39;, help=\u0026#39;compute answers for me\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, dest=\u0026#39;solve\u0026#39;) parser.add_option(\u0026#39;-p\u0026#39;, \u0026#39;--printstats\u0026#39;, help=\u0026#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, dest=\u0026#39;print_stats\u0026#39;) (options, args) = parser.parse_args() random_seed(options.seed) assert(options.process_switch_behavior == SCHED_SWITCH_ON_IO or options.process_switch_behavior == SCHED_SWITCH_ON_END) assert(options.io_done_behavior == IO_RUN_IMMEDIATE or options.io_done_behavior == IO_RUN_LATER) s = scheduler(options.process_switch_behavior, options.io_done_behavior, options.io_length) if options.program != \u0026#39;\u0026#39;: for p in options.program.split(\u0026#39;:\u0026#39;): s.load_program(p) else: # example process description (10:100,10:100) for p in options.process_list.split(\u0026#39;,\u0026#39;): s.load(p) assert(options.io_length \u0026gt;= 0) if options.solve == False: print(\u0026#39;Produce a trace of what would happen when you run these processes:\u0026#39;) for pid in range(s.get_num_processes()): print(\u0026#39;Process %d\u0026#39; % pid) for inst in range(s.get_num_instructions(pid)): print(\u0026#39; %s\u0026#39; % s.get_instruction(pid, inst)) print(\u0026#39;\u0026#39;) print(\u0026#39;Important behaviors:\u0026#39;) print(\u0026#39; System will switch when \u0026#39;, end=\u0026#39;\u0026#39;) if options.process_switch_behavior == SCHED_SWITCH_ON_IO: print(\u0026#39;the current process is FINISHED or ISSUES AN IO\u0026#39;) else: print(\u0026#39;the current process is FINISHED\u0026#39;) print(\u0026#39; After IOs, the process issuing the IO will \u0026#39;, end=\u0026#39;\u0026#39;) if options.io_done_behavior == IO_RUN_IMMEDIATE: print(\u0026#39;run IMMEDIATELY\u0026#39;) else: print(\u0026#39;run LATER (when it is its turn)\u0026#39;) print(\u0026#39;\u0026#39;) exit(0) (cpu_busy, io_busy, clock_tick) = s.run() if options.print_stats: print(\u0026#39;\u0026#39;) print(\u0026#39;Stats: Total Time %d\u0026#39; % clock_tick) print(\u0026#39;Stats: CPU Busy %d (%.2f%%)\u0026#39; % (cpu_busy, 100.0 * float(cpu_busy)/clock_tick)) print(\u0026#39;Stats: IO Busy %d (%.2f%%)\u0026#39; % (io_busy, 100.0 * float(io_busy)/clock_tick)) print(\u0026#39;\u0026#39;) 소스코드 분석 # process switch behavior SCHED_SWITCH_ON_IO = \u0026#39;SWITCH_ON_IO\u0026#39; SCHED_SWITCH_ON_END = \u0026#39;SWITCH_ON_END\u0026#39; # io finished behavior IO_RUN_LATER = \u0026#39;IO_RUN_LATER\u0026#39; IO_RUN_IMMEDIATE = \u0026#39;IO_RUN_IMMEDIATE\u0026#39; # process states STATE_RUNNING = \u0026#39;RUNNING\u0026#39; STATE_READY = \u0026#39;READY\u0026#39; STATE_DONE = \u0026#39;DONE\u0026#39; STATE_WAIT = \u0026#39;BLOCKED\u0026#39; # members of process structure PROC_CODE = \u0026#39;code_\u0026#39; PROC_PC = \u0026#39;pc_\u0026#39; PROC_ID = \u0026#39;pid_\u0026#39; PROC_STATE = \u0026#39;proc_state_\u0026#39; # things a process can do DO_COMPUTE = \u0026#39;cpu\u0026#39; DO_IO = \u0026#39;io\u0026#39; DO_IO_DONE = \u0026#39;io_done\u0026#39; class scheduler: def __init__(self, process_switch_behavior, io_done_behavior, io_length): # keep set of instructions for each of the processes self.proc_info = {} self.process_switch_behavior = process_switch_behavior self.io_done_behavior = io_done_behavior self.io_length = io_length return def new_process(self): proc_id = len(self.proc_info) self.proc_info[proc_id] = {} self.proc_info[proc_id][PROC_PC] = 0 self.proc_info[proc_id][PROC_ID] = proc_id self.proc_info[proc_id][PROC_CODE] = [] self.proc_info[proc_id][PROC_STATE] = STATE_READY return proc_id def load_program(self, program): proc_id = self.new_process() for line in program.split(\u0026#39;,\u0026#39;): opcode = line[0] if opcode == \u0026#39;c\u0026#39;: # compute num = int(line[1:]) for i in range(num): self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE) elif opcode == \u0026#39;i\u0026#39;: self.proc_info[proc_id][PROC_CODE].append(DO_IO) # add one compute to HANDLE the I/O completion self.proc_info[proc_id][PROC_CODE].append(DO_IO_DONE) else: print(\u0026#39;bad opcode %s (should be c or i)\u0026#39; % opcode) exit(1) return def load(self, program_description): proc_id = self.new_process() tmp = program_description.split(\u0026#39;:\u0026#39;) if len(tmp) != 2: print(\u0026#39;Bad description (%s): Must be number \u0026lt;x:y\u0026gt;\u0026#39; % program_description) print(\u0026#39; where X is the number of instructions\u0026#39;) print(\u0026#39; and Y is the percent change that an instruction is CPU not IO\u0026#39;) exit(1) num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0 for i in range(num_instructions): if random.random() \u0026lt; chance_cpu: self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE) else: self.proc_info[proc_id][PROC_CODE].append(DO_IO) # add one compute to HANDLE the I/O completion self.proc_info[proc_id][PROC_CODE].append(DO_IO_DONE) return def new_process(self): proc_id = len(self.proc_info) self.proc_info[proc_id] = {} self.proc_info[proc_id][PROC_PC] = 0 self.proc_info[proc_id][PROC_ID] = proc_id self.proc_info[proc_id][PROC_CODE] = [] self.proc_info[proc_id][PROC_STATE] = STATE_READY return proc_id def load_program(self, program): proc_id = self.new_process() for line in program.split(\u0026#39;,\u0026#39;): opcode = line[0] if opcode == \u0026#39;c\u0026#39;: num = int(line[1:]) for i in range(num): self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE) elif opcode == \u0026#39;i\u0026#39;: self.proc_info[proc_id][PROC_CODE].append(DO_IO) self.proc_info[proc_id][PROC_CODE].append(DO_IO_DONE) else: print(\u0026#39;bad opcode %s (should be c or i)\u0026#39; % opcode) exit(1) return def run(self): clock_tick = 0 if len(self.proc_info) == 0: return self.io_finish_times = {} for pid in range(len(self.proc_info)): self.io_finish_times[pid] = [] self.curr_proc = 0 self.move_to_running(STATE_READY) print(\u0026#39;%s\u0026#39; % \u0026#39;Time\u0026#39;, end=\u0026#39;\u0026#39;) for pid in range(len(self.proc_info)): print(\u0026#39;%14s\u0026#39; % (\u0026#39;PID:%2d\u0026#39; % (pid)), end=\u0026#39;\u0026#39;) print(\u0026#39;%14s\u0026#39; % \u0026#39;CPU\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;%14s\u0026#39; % \u0026#39;IOs\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) io_busy = 0 cpu_busy = 0 while self.get_num_active() \u0026gt; 0: clock_tick += 1 io_done = False for pid in range(len(self.proc_info)): if clock_tick in self.io_finish_times[pid]: io_done = True self.move_to_ready(STATE_WAIT, pid) if self.io_done_behavior == IO_RUN_IMMEDIATE: if self.curr_proc != pid: if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING: self.move_to_ready(STATE_RUNNING) self.next_proc(pid) else: if self.process_switch_behavior == SCHED_SWITCH_ON_END and self.get_num_runnable() \u0026gt; 1: self.next_proc(pid) if self.get_num_runnable() == 1: self.next_proc(pid) self.check_if_done() instruction_to_execute = \u0026#39;\u0026#39; if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\ len(self.proc_info[self.curr_proc][PROC_CODE]) \u0026gt; 0: instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0) cpu_busy += 1 if io_done: print(\u0026#39;%3d*\u0026#39; % clock_tick, end=\u0026#39;\u0026#39;) else: print(\u0026#39;%3d \u0026#39; % clock_tick, end=\u0026#39;\u0026#39;) for pid in range(len(self.proc_info)): if pid == self.curr_proc and instruction_to_execute != \u0026#39;\u0026#39;: print(\u0026#39;%14s\u0026#39; % (\u0026#39;RUN:\u0026#39;+instruction_to_execute), end=\u0026#39;\u0026#39;) else: print(\u0026#39;%14s\u0026#39; % (self.proc_info[pid][PROC_STATE]), end=\u0026#39;\u0026#39;) if instruction_to_execute == \u0026#39;\u0026#39;: print(\u0026#39;%14s\u0026#39; % \u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) else: print(\u0026#39;%14s\u0026#39; % \u0026#39;1\u0026#39;, end=\u0026#39;\u0026#39;) num_outstanding = self.get_ios_in_flight(clock_tick) if num_outstanding \u0026gt; 0: print(\u0026#39;%14s\u0026#39; % str(num_outstanding), end=\u0026#39;\u0026#39;) io_busy += 1 else: print(\u0026#39;%10s\u0026#39; % \u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) if instruction_to_execute == DO_IO: self.move_to_wait(STATE_RUNNING) self.io_finish_times[self.curr_proc].append(clock_tick + self.io_length + 1) if self.process_switch_behavior == SCHED_SWITCH_ON_IO: self.next_proc() self.check_if_done() return (cpu_busy, io_busy, clock_tick) # # PARSE ARGUMENTS # parser = OptionParser() parser.add_option(\u0026#39;-s\u0026#39;, \u0026#39;--seed\u0026#39;, default=0, help=\u0026#39;the random seed\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;int\u0026#39;, dest=\u0026#39;seed\u0026#39;) parser.add_option(\u0026#39;-P\u0026#39;, \u0026#39;--program\u0026#39;, default=\u0026#39;\u0026#39;, help=\u0026#39;more specific controls over programs\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;program\u0026#39;) parser.add_option(\u0026#39;-l\u0026#39;, \u0026#39;--processlist\u0026#39;, default=\u0026#39;\u0026#39;, help=\u0026#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an IO (i.e., if Y is 100, a process will ONLY use the CPU and issue no I/Os; if Y is 0, a process will only issue I/Os)\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;process_list\u0026#39;) parser.add_option(\u0026#39;-L\u0026#39;, \u0026#39;--iolength\u0026#39;, default=5, help=\u0026#39;how long an IO takes\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;int\u0026#39;, dest=\u0026#39;io_length\u0026#39;) parser.add_option(\u0026#39;-S\u0026#39;, \u0026#39;--switch\u0026#39;, default=\u0026#39;SWITCH_ON_IO\u0026#39;, help=\u0026#39;when to switch between processes: SWITCH_ON_IO, SWITCH_ON_END\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;process_switch_behavior\u0026#39;) parser.add_option(\u0026#39;-I\u0026#39;, \u0026#39;--iodone\u0026#39;, default=\u0026#39;IO_RUN_LATER\u0026#39;, help=\u0026#39;type of behavior when IO ends: IO_RUN_LATER, IO_RUN_IMMEDIATE\u0026#39;, action=\u0026#39;store\u0026#39;, type=\u0026#39;string\u0026#39;, dest=\u0026#39;io_done_behavior\u0026#39;) parser.add_option(\u0026#39;-c\u0026#39;, help=\u0026#39;compute answers for me\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, dest=\u0026#39;solve\u0026#39;) parser.add_option(\u0026#39;-p\u0026#39;, \u0026#39;--printstats\u0026#39;, help=\u0026#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, dest=\u0026#39;print_stats\u0026#39;) (options, args) = parser.parse_args() random_seed(options.seed) assert(options.process_switch_behavior == SCHED_SWITCH_ON_IO or options.process_switch_behavior == SCHED_SWITCH_ON_END) assert(options.io_done_behavior == IO_RUN_IMMEDIATE or options.io_done_behavior == IO_RUN_LATER) s = scheduler(options.process_switch_behavior, options.io_done_behavior, options.io_length) if options.program != \u0026#39;\u0026#39;: for p in options.program.split(\u0026#39;:\u0026#39;): s.load_program(p) else: # example process description (10:100,10:100) for p in options.process_list.split(\u0026#39;,\u0026#39;): s.load(p) assert(options.io_length \u0026gt;= 0) if options.solve == False: print(\u0026#39;Produce a trace of what would happen when you run these processes:\u0026#39;) for pid in range(s.get_num_processes()): print(\u0026#39;Process %d\u0026#39; % pid) for inst in range(s.get_num_instructions(pid)): print(\u0026#39; %s\u0026#39; % s.get_instruction(pid, inst)) print(\u0026#39;\u0026#39;) print(\u0026#39;Important behaviors:\u0026#39;) print(\u0026#39; System will switch when \u0026#39;, end=\u0026#39;\u0026#39;) if options.process_switch_behavior == SCHED_SWITCH_ON_IO: print(\u0026#39;the current process is FINISHED or ISSUES AN IO\u0026#39;) else: print(\u0026#39;the current process is FINISHED\u0026#39;) print(\u0026#39; After IOs, the process issuing the IO will \u0026#39;, end=\u0026#39;\u0026#39;) if options.io_done_behavior == IO_RUN_IMMEDIATE: print(\u0026#39;run IMMEDIATELY\u0026#39;) else: print(\u0026#39;run LATER (when it is its turn)\u0026#39;) print(\u0026#39;\u0026#39;) exit(0) (cpu_busy, io_busy, clock_tick) = s.run() if options.print_stats: print(\u0026#39;\u0026#39;) print(\u0026#39;Stats: Total Time %d\u0026#39; % clock_tick) print(\u0026#39;Stats: CPU Busy %d (%.2f%%)\u0026#39; % (cpu_busy, 100.0 * float(cpu_busy)/clock_tick)) print(\u0026#39;Stats: IO Busy %d (%.2f%%)\u0026#39; % (io_busy, 100.0 * float(io_busy)/clock_tick)) print(\u0026#39;\u0026#39;) 문제 ","permalink":"http://localhost:1313/_wiki/chapter-04/","summary":"source code : process-run.py link : https://github.com/remzi-arpacidusseau/ostep-homework/blob/master/cpu-intro/process-run.py\n#! /usr/bin/env python from __future__ import print_function import sys from optparse import OptionParser import random # to make Python2 and Python3 act the same -- how dumb def random_seed(seed): try: random.seed(seed, version=1) except: random.seed(seed) return # process switch behavior SCHED_SWITCH_ON_IO = \u0026#39;SWITCH_ON_IO\u0026#39; SCHED_SWITCH_ON_END = \u0026#39;SWITCH_ON_END\u0026#39; # io finished behavior IO_RUN_LATER = \u0026#39;IO_RUN_LATER\u0026#39; IO_RUN_IMMEDIATE = \u0026#39;IO_RUN_IMMEDIATE\u0026#39; # process states STATE_RUNNING = \u0026#39;RUNNING\u0026#39; STATE_READY = \u0026#39;READY\u0026#39; STATE_DONE = \u0026#39;DONE\u0026#39; STATE_WAIT = \u0026#39;BLOCKED\u0026#39; # members of process structure PROC_CODE = \u0026#39;code_\u0026#39; PROC_PC = \u0026#39;pc_\u0026#39; PROC_ID = \u0026#39;pid_\u0026#39; PROC_STATE = \u0026#39;proc_state_\u0026#39; # things a process can do DO_COMPUTE = \u0026#39;cpu\u0026#39; DO_IO = \u0026#39;io\u0026#39; DO_IO_DONE = \u0026#39;io_done\u0026#39; class scheduler: def __init__(self, process_switch_behavior, io_done_behavior, io_length): # keep set of instructions for each of the processes self.","title":"프로세스 시뮬레이션 숙제 📚"},{"content":"","permalink":"http://localhost:1313/_wiki/ostep-week-01/","summary":"","title":"OSTEP-Week-01 질의 응답 📚"},{"content":"01 장 - 이 책에 대한 대화 아주 간단한 이 책에 대한 소개를 하는 챕터이다.\n두 장으로 이루어져 있고, 이 책에서 자주 나오게 되는 교수와 학생의 대화 형식으로 이루어져 있다.\n핵심적인 아이디어를 요약하면 다음과 같다.\n리처드 파인만의 물리학 아주 쉬운 6가지 이야기라는 강의 노트가 있다. 물리학이 6만큼 어려우면, 운영체제는 3만큼 어렵기 때문에, 이 책의 제목이 \u0026ldquo;운영체제 아주 쉬운 세 가지 이야기\u0026quot;이다. 이 책은 운영체제에 대한 이야기를 3가지로 나누어서 설명한다. 가상화, 병행성, 영속성 02 장 - 운영체제 개요 이 책에서 다루게 될 내용이지만 아주 간단하게 약식으로 설명하는 글이 있어 가져왔다. c/cpp를 공부할 때 이분의 블로그와 강의자료를 들었는데 상대적으로 최근에 업로드된 문서이다. 내가 c언어를 배우기 전에 알았다면 좋았을 것들\n프로그램은 명령어를 실행하는 아주 단순한 일을 한다.\n프로세서는 명렁어를 반입(fetch)하고, 디코딩(decoding)하고, 실행(execute)하는 일을 한다.\n그리고 프로그램을 쉽게 실행하고, 프로그램간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할 수 있는 소프트웨어가 운영체제이다.\n운영체제는 앞에서 언급한 일을 하기 위해서 Virtualization이라는 기법을 사용한다.\n실제 프로세서, 메모리, 디스크 같은 물리적인 자원을 이용해서 일반적이고, 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.\n그래서 운영체제를 가상머신이라고 하기도 한다.\n가상화를 이용해서 실제 사용자들이 해당 자원을 접근 할 수 있는 API를 제공하며, Application이 사용 할 수 있는 시스템콜을 제공한다.\n02.1 CPU 가상화 핵심 질문 : 자원을 어떻게 가상화 시키는가?\n운영체제가 자원을 가상화 시켜서 사용하면 편리한건 너무 당연하기 때문에, 이러한 문제는 질문이 될 수 없다.\n이것을 어떻게, 어떠한 기법과 정책으로, 어떻게 효율적으로, 어떠한 하드웨어 지원이 필요한지 와 같은 질문이 중요하다.\n#include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; void Spin(int howlong) { double t = GetTime(); while ((GetTime() - t) \u0026lt; (double)howlong) ; // do nothing in loop } int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage: CPU \u0026lt;string\u0026gt;\\n\u0026#34;); exit(-1); } char *str = argv[1]; while (1) { Spin(1); printf(\u0026#34;%s\\n\u0026#34;, str); } return 0; } 위 코드는 CPU를 사용하는 프로그램이다. 이 프로그램은 인자로 받은 문자열을 1초에 한 번 영원히 출력한다. $ gcc -o CPU CPU.c $ ./CPU A \u0026amp; ; ./CPU B \u0026amp; ; ./CPU C \u0026amp; ; 이렇게 실행시키면 마치 CPU가 세 개인 것 처럼 ABC가 번갈아가며 출력된다.\n이렇게 CPU를 가상화 시키는 것은 유용하지만, 새로운 문제가 발생한다. 예를 들어 동일한 시점에 실행되어야 하는 프로그램이 많아지면, 어떠한 프로그램이 실행되어야 하는가 와 같은 이슈가 생긴다.\n이러한 문제를 해결하기 위해서 필요한 정책 같은 것들이 있는데, 이번 장에서는 이러한 정책들을 다루게 된다.(즉 자원 관리자로서의 운영체제 역할에 대해 다룬다.)\n02.2 메모리 가상화 #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; double GetTime() { struct timeval t; int rc = gettimeofday(\u0026amp;t, NULL); assert(rc == 0); return (double)t.tv_sec + (double)t.tv_usec / 1e6; } void Spin(int howlong) { double t = GetTime(); while ((GetTime() - t) \u0026lt; (double)howlong) ; // do nothing in loop } int main(int argc, char *argv[]) { int *p = malloc(sizeof(int)); // 메모리를 한당 받는다. assert(p != NULL); printf(\u0026#34;(%d) address pointed to by p: %p\\n\u0026#34;, getpid(), p); // process의 id를 출력한다. *p = 0; // 할당받은 메모리에 0을 넣는다. while (1) { Spin(1); *p = *p + 1; printf(\u0026#34;(%d) p: %d\\n\u0026#34;, getpid(), *p); // process의 id와 p의 값을 출력한다. } } 위 코드는 메모리를 사용하는 프로그램이다. 이 프로그램은 메모리를 할당 받고, 1초에 한 번씩 메모리에 있는 값을 1씩 증가시킨다.\n그러면서 주석에 있는 내용처럼 process의 id와 메모리 주소를 출력한다.\n다수의 프로그램을 동시에 실행시킨 결과는 다음과 같다.\n$ gcc -o MEM MEM.c $ ./MEM \u0026amp; ; ./MEM \u0026amp; ; ./MEM \u0026amp; ; [1] 7890 [2] 7891 [3] 7892 (7890) memory address of p: 0x200000000 (7891) memory address of p: 0x200000000 (7892) memory address of p: 0x200000000 (7890) p: 0 (7891) p: 0 (7892) p: 0 (7890) p: 1 (7891) p: 1 (7892) p: 1 (7890) p: 2 (7891) p: 2 (7892) p: 2 (7890) p: 3 (7891) p: 3 (7892) p: 3 ... 주목해야 할 결과값은 메모리 주소이다. 프로그램이 실행되는 메모리 주소는 모두 같다.\n이 역시 메모리 가상화의 결과이다. 프로그램은 자신만의 메모리를 가지고 있다고 생각하지만, 실제로는 운영체제가 제공하는 가상 메모리를 사용하고 있다.\n이와 같은 메모리의 가상화 역시 이 책에서 다루게 된다.\n02.3 병행성 (Concurrency) 프로그램이 한 번에 많은 일을 하려 할 때 (동시에) 발생하는 문제를 다룬다.\n사실 운영체제는 한 프로세스 실행, 다음 프로세스 실행, 다음 프로세스 실행, \u0026hellip; 이런식으로 프로세스를 번갈아가며 실행하는데 이 때 발생하는 문제들이 생긴다.\n#include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; volatile int counter = 0; int loops; // loop 횟수만큼 counter를 증가시키는 함수 void *worker(void *arg) { int i; for (i = 0; i \u0026lt; loops; i++) { counter++; } return NULL; } int main(int argc, char *argv[]) { if (argc != 2) { fprintf(stderr, \u0026#34;usage: threads \u0026lt;value\u0026gt;\\n\u0026#34;); exit(1); } loops = atoi(argv[1]); // 인자로 받은 값을 loops에 저장한다. pthread_t p1, p2; printf(\u0026#34;Initial value : %d\\n\u0026#34;, counter); double t1 = GetTime(); pthread_create(\u0026amp;p1, NULL, worker, NULL); // thread p1 worker 함수 실행 pthread_create(\u0026amp;p2, NULL, worker, NULL); // thread p2 worker 함수 실행 pthread_join(p1, NULL); pthread_join(p2, NULL); double t2 = GetTime(); printf(\u0026#34;Final value : %d\\n\u0026#34;, counter); printf(\u0026#34;Time : %f\\n\u0026#34;, t2 - t1); return 0; } 이 코드는 복잡해보이지만 전혀 그렇지 않다. thread 2개를 생성하고, 각각의 thread에서 worker 함수를 실행한다.\nworker 함수는 인자로 받은 loop 횟수만큼 counter를 증가시킨다.\n실제 실행 결과는 다음과 같다.\n$ gcc -o THREAD THREAD.c -lpthread $ ./THREAD 1000 Initial value : 0 Final value : 2000 Time : 0.000000 일단 값이 2000이 나왔다. 이는 2개의 thread가 각각 1000번씩 counter를 증가시켰기 때문이다.\n더 많은 횟수로 실행한 결과는 다음과 같다.\n$ ./THREAD 100000 Initial value : 0 Final value : 143012 Time : 0.000000 이번에는 143012가 나왔다. 인자 * 스레드의 개수 만큼 counter가 증가해야 하는데 그렇지 않은 이유는 아래와 같다.\n실제 카운터를 증가시키는 코드의 로직은 다음과 같다.\ncounter를 메모리에서 레지스터로 불러온다. 레지스터에 1을 더한다. 레지스터의 값을 메모리에 저장한다. 이 세가지 작업이 원자성을 가지지 않는다. 즉, 다른 스레드가 counter를 읽어가는 동안 다른 스레드가 counter를 증가시킬 수 있다.\n이러한 문제가 Concurrency 문제이며, 이러한 문제를 해결하기 위한 방법들을 이 책에서 다룬다.\n병행성의 핵심 질문 : 올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가 같은 메모리 공간에 다수의 쓰레드가 동시에 실행단다고 할 때, 올바르게 동작하는 프로그램을 어떻게 잘성 할 수 있는가? 운영체제는 어떠한 기본 기법을 제공하는가, 하드웨어는 어떠한 지원을 제공하는가? 병행성 문제를 해결하기 위해 기본 기법들과 하드웨어 기능을을 어떻게 사용할 수 있는가?\n02.4 영속성 (Persistence) RAM은 읽고 쓰기가 레지스터, 캐시에 비해서는 느리지만, 그래도 충분히 빠르다. 작업 시간 (현실 시간으로 환산) CPU 사이클 1초 L1 캐시 접근 2초 L2 캐시 접근 7초 L3 캐시 접근 1분 RAM 접근 4분 NVMe SSD 접근 17시간 일반 SSD 접근 1.5일 ~ 4일 일반 하드디스크 접근 1 ~ 9달 서울 - 샌프란시스코 패킷 전송 시간 14년 출처 : 내가 c언어를 배우기 전에 알았다면 좋았을 것들 그러나 RAM은 전원이 꺼지면 모든 데이터가 사라진다.\n그래서 우리는 데이터를 영구적으로 저장할 수 있는 영속성을 구현하기 위해 하드웨어와 소프트웨어가 필요하다.\n많이들 알고 있겠지만, 하드웨어는 I/O 장치 형태로 제공되며, 요즘은 주로 SSD를 사용한다.\n디스크를 관리하는 운영체제 소프트웨어는 파일 시스템이라고 한다. (파일시스템은 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적으로 저장할 책임이 있다.)\n영속성과 관련한 핵심 질문은 다음과 같다.\n영속성의 핵심 질문 : 데이터를 영속적으로 저장하는 방법은 무엇인가 파일 시스템은 데이터를 여속적으로 관리하는 운영체제의 일부분인다. 올바르게 동작하기 위해서는 어떤 기법이 필요할까? 이러한 작업 성능을 높이기 위해서 어떤 기법과 정책이 필요할까? 하드웨어와 소프트웨어가 실패하더라도 올바르게 동작하려면 어떻게 해야 할까?\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;fcnt1.h\u0026gt; #include \u0026lt;sys/file.h\u0026gt; int main(int argc, char *argv[]) { int fd = open(\u0026#34;tmp/file\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); // 프로그램의 운영체제 첫 번째 호출(call) assert(fd \u0026gt; -1); int rc = write(fd, \u0026#34;hello world\\n\u0026#34;, 13); // 프로그램의 운영체제 두 번째 호출(call) close(fd); // 프로그램의 운영체제 세 번째 호출(call) assert(rc == 13); /** * 이 처럼 파일 시스템의 시스템 콜을 사용한다. */ return 0; } 이 코드는 파일 시스템을 사용하는 프로그램이다. 파일을 열고, 쓰고, 닫는 작업을 한다.\n디스크를 접근해서 파일시스템으로 관리하고 시스템콜을 통해 파일을 생성하고, 쓰고, 닫아왔었다.\n이러한 시스템콜은 표준화 되어있어서 마치 언어의 STL로 제공받는 것처럼 편리하지만,\n실제로 내부에서 일어나는 일은 매우 복잡하다.\n에를 들어 쓰기 지연시간동안 정전이 되었거나 고장이 났을 때, 기록 순서가 뒤바뀔 수 있고, 쓰려고 모였던 데이터는 이미 쓰였을 수도 있다.\n이런 것들을 해결하기 위해 운영체제는 journaling, copy-on-write, checksums 등의 기법을 사용하는데, 이러한 것들도 같이 다루게 된다.\n02.5 설계 목표 설계 목표라고 되어 있어서 흐름상 애매하지만, 위의 소주제에서 세가지를 보면서(가상화, 병행성, 영속성) 운영체제가 해야하는, 하고있는, 해야할 일을 알게 되었으니, 그것들을 어떻게 잘 수행할 수 있을지에 대한 설계 목표를 다룬다고 생각하면 될 것 같다.\n첫 번째로, 가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념들을 정의하는 것 즉 추상화이다.\n이 추상화는 컴퓨터 과학에 있어서 모든 일에 대한 근간이다. 추상화로 개념을 정의해가며 큰 프로그램을 이해하기 쉬운 작은 여러가지로 나눌 수 있다. 예를 들어 논리 게이트를 몰라도 어셈블리어로 프로그램을 작성 할 수 잇고, 어셈블리어를 몰라도 C와 같은 high level 언어로 프로그램을 작성할 수 있다. 두 번째로, 운영체제의 가장 중요한 목표는 성능이다. (minimize the overhead)\noverhead는 시스템의 성능을 떨어뜨리는 요소이며, 시간(더 많은 명령어)과 공간(더 많은 메모리)적인 요소로 나뉜다. 이 시간과 공간의 낭비를 최소화 하면서도, 절충할 부분은 절충하면서, 성능을 최대화 하는 것이 운영체제의 목표이다. 세 번째로, 보호이다.\n운영체제와 프로그램, 프로그램간의 보호를 제공하는 것이다. 한 프로그램의 악의적인 또는 의도치 않은 행동이 다른 프로그램이나 운영체제에 영향을 미치지 않도록 하는 것이 필요하다. 보호는 운영체제의 원칙 중 하나인 isolation 원칙의 핵심이다. 마지막으로 신뢰성이다.\n운영체제는 항상, 지속적으로 실행되고 있어야 한다. 운영체제가 실패하면, 그 위에서 돌아가는 프로그램들도 실패하게 된다. 이러한 종속성 때문에 운영체제는 매우 높은 신뢰성을 요구받는다. 이러한 목표들은 운영체제의 설계와 구현에 있어서 중요한 요소이며, 이 책에서는 이러한 목표들을 달성하기 위한 기법과 정책들을 다룬다.\n추가적으로 에너지 효율성과 보안, 이식성등을 언급하지만, 이 책에에서 직접적으로 다루진 않고, 실제로도 위의 네가지가 조금 더 운영체제의 핵심 목표이다.\n02.6 배경 소개 (라고 되어있지만 사실 그냥 운영체제의 역사) 초창기 운영체제: 단순 라이브러리 초창기에는 운영체제가 많은 일을 하지 않았다, 자주 사용되는 저수준의 입출력 처리 코드를 함수화 하여 모아놓은 라이브러리 정도였다.\n작업을 모아놓고 일괄적으로 처리하는 것은 batch processing이라고 하는데, 이러한 작업은 컴퓨터 관리자가 수동으로 처리했다.\n라이브러리를 넘어 : 보호 운영체제는 단순한 라이브러리를 넘어 컴퓨터 \u0026lsquo;관리\u0026rsquo; 측면에서 중요한 역할을 하기 시작했다.\n운영체제가 실행하는 코드는 일반적인 응용 프로그램의 코드와는 다르게, 실제 하드웨어 장치의 제어를 담당하고 있기에, 다르게 취급되어야 한다는 필요성이 대두되었다.\n예를들어 모든 응용 프로그램이 하드디스크에 접근하면, 응용 프로그램끼리 서로의 데이터를 읽고 쓸 수 있게 되어 보안상 문제가 발생한다.\n결론적으로 예를들 file system과 같은 것들을 일반 라이브러리처럼 제공하고 운영하면, 자료의 기록과 보호라는 원래 의도한 역할을 수행할 수 없게 된다.\n여기서 Atlas Computing System에 의해 System Call이라는 아이디어가 발명되었다.\n기본적으로 Atlas Computing System의 아이디어는 OS routine을 라이브러리 형식으로 제공하는 대신,\nOS를 더 공식적이고 제어된 프로세스로 전환하기위해 하드웨어 명령어와 하드웨어 상태라는 특별한 페어를 추가하는 아이디어이다.\nSystem Call과 Procedure Call의 차이점은 System Call에서는 OS로 제어권이 넘어가는 시점에 하드웨어 제어 권한(정확히 번역은 하드웨어 특권 수준 : Hardware Privilege level 으로 되어있다)을 격상시키는 것이다.\n일단 일반적인 응용프로그램은 user mode에서 실행되는데, 이때는 하드웨어에 대한 접근이 제한된다.\n하지만 System Call을 호출하면, OS로 제어권이 넘어가고, OS는 kernel mode에서 실행되며, 이때는 하드웨어에 대한 접근이 허용된다.\n구체적으로는 trap이라는 명령어를 사용하여 System Call을 호출하고, 이때 trap은 kernel mode로 전환하는 역할을 한다.\n또한 하드웨어는 trap으로 인해 System Call이 호출되었을 때, 미리 지정된 trap handler 함수에게 제어권을 넘긴다.\n이 상태에서는 모든 하드웨어에 대한 접근이 허용되며, 이를 통해 OS는 필요한 요청을 처리하고, 제어권을 다시 user에게 넘겨준다.\n이러한 System Call을 통해 OS는 하드웨어에 대한 접근을 제어하고, 이를 통해 보호와 다른 기능들을 수행할 수 있게 되었다.\n참고: System call과 Procedure call의 차이점\n권한 수준 (Privilege Level):\n프로시저 호출: 프로시저 호출은 일반적으로 동일한 권한 수준(예: 사용자 모드)에서 발생합니다. 호출된 프로시저는 호출한 프로그램과 동일한 권한 수준에서 실행됩니다. 시스템 호출: 시스템 호출은 권한 수준을 변경하여 실행됩니다. 시스템 호출은 일반적으로 사용자 모드에서 이루어지며, 호출된 OS 코드는 권한이 더 높은 커널 모드에서 실행됩니다. 이로써 OS는 보다 높은 권한 수준에서 하드웨어와 상호 작용하여 특권 명령을 실행할 수 있습니다. 하드웨어 접근 및 보안:\n프로시저 호출: 프로시저 호출은 호출된 프로시저가 호출한 프로그램의 메모리 공간과 동일한 접근 권한을 가집니다. 이는 호출된 프로시저가 호출한 프로그램의 데이터에 자유롭게 접근할 수 있다는 것을 의미할 수 있습니다. 시스템 호출: 시스템 호출은 권한 수준을 변경하므로, 호출된 OS 코드는 호출한 프로그램의 메모리 공간에 직접 액세스할 수 없습니다. 이는 시스템 호출을 통해 호출된 OS가 사용자 프로그램의 데이터에 무단으로 접근하는 것을 방지합니다. 운영 체제와의 상호 작용:\n프로시저 호출: 프로시저 호출은 일반적으로 동일한 응용 프로그램 내에서 다른 함수 또는 프로시저를 호출하는 데 사용됩니다. 시스템 호출: 시스템 호출은 주로 운영 체제와 상호 작용하기 위해 사용됩니다. 예를 들어, 파일 시스템 접근, 네트워크 통신, 시스템 자원 할당 등과 같은 운영 체제 서비스에 접근하기 위해 사용됩니다. 멀티 프로그래밍 시대 미니 컴퓨터 시대에 이루어 졌다고 한다.\n회사마다 하나의 컴퓨터를 사용하는 정도로 보급되었다고 한다.\n이때부터 운영체제는 multiprogramming이라는 개념을 도입하게 된다.\n왜냐하면 한대의 컴퓨터에서 여러개의 프로그램을 실행하면서, CPU가 놀지 않도록 일을 시킬 수 있기 때문이다.\n그래서 인터럽트를 통한 context switch라는 아이디어가 등장했는데, 운영체제 역사에서 혁신이라 부를 만 한 아이디어이다.\n물론 이러한 상황에서 메모리 보호, 병행성에 대한 처리도 필요해졌다.\n그 외에 역사적으로는 UNIX 운영체제가 등장했고, 이 역시 가장 중요한 사건 중 하나로 꼽힌다.\n현대 (개인용 컴퓨터 시대) 이제는 개인용 컴퓨터가 보급되었고, 이에 따라 운영체제도 변화하게 된다.\n놀랍게도 저자는 퇴보를 언급한다, 미니 컴퓨터 시대가 운영체제의 전성기였으며 초창기 pc들의 os들은 그 시대의 아이디어나 기술을 사용하지 않거나 심지어는 잘 몰랐다고 한다.\n예시로 DOS는 메모리 보호를 전혀 생각하지 않고 디자인 되었고, MacOS는 잘못된 스케줄링을 채택하여, 쓰레드 하나가 무한루프에 빠지면, 전체 시스템이 멈추는 버그가 있었다.\n이 당시가 암흑기라고 하며 1980년대가 지나가면서 다시 운영체제는 1970년대 미니컴퓨터 시대의 아이디어와 기술을 찾아가기 시작했다고 한다.\n03장 - 가상화에 대한 대화 가상화에 대한 대화를 통해 가상화에 대한 기본적인 개념을 이해한다.\n가상화를 복숭아에 비유하여 설명한다.\n복숭아를 먹고 싶은 사람이 여럿 있고 복숭아는 단 하나라고 이야기한다.\n먼저 가상 복숭아를 먹고싶은 모두에게 나눠준다.\n사실 그 사람들은 매 시간 복숭아를 먹고 있는게 아니라, 대부분의 시간을 낮잠을 자거나 휴식을 취하고 있다.\n그래서 실제로 복숭아를 사용하고 있지 않을 때, 다른 사람에게 실제 복숭아를 가져다 준다는 것이다.\n이 비유에서 복숭아는 자원이고, 사람들은 프로세스이다.\n그리고 그 복숭아를 옮기는 사람은 운영체제이다.\n복숭아를 CPU로 바꾸면 CPU 가상화가 되고, 복숭아를 메모리로 바꾸면 메모리 가상화가 된다.\n04장 - 프로세스 프로세스는 일반적으로 실행중인 프로그램이라고 정의한다.\n프로그램은 디스크 상에 존재하는 실행을 위한 명령어와 정적 데이터의 묶음이다.\n핵심 질문 : CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가?\n운영체제는 CPU를 가상화하여 여러 개의 프로세스가 동시에 실행되는 것처럼 보이게 한다.\n하나의 프로세스를 실행하고, 다른 프로세스를 실행하고, 다시 다른 프로세스를 실행하는 것을 반복한다.\n이러한 기법은 time sharing 이라고 불리는데, 원하는 수 만큼의 프로세스를 동시에 실행 할 수 있다.(물론 CPU를 공유하기 때문에 각 프로세스의 성능은 떨어진다.)\nCPU 가상화를 효율적으로 구현하기 위해서는 도구(mechanism)와 지능(policy)이 필요하다.\n여기서의 도구는 context switch와 interrupt이며, 지능은 scheduler인데 지금부터 이것들을 다룬다.\n04.1 프로세스의 개념(프로세스 추상화) 프로세스를 실행중인 프로그램으로 언급했다.\n프로세스 인스턴스를 요약하려면, 프로세스가 실행간에 접근했거나 영향을 미친 것들에 대한 목록을 통해 알아볼 수 있다.\n이러한 관점으로 프로세스를 알아보기 위해서 일단 하드웨어 상태(machine state)에 대해서 이해를 해야 한다.\nmachine state는 프로그램이 실행되는 동안 읽거나 쓸 수 있는 모든 것을 의미한다.\nmachine state의 가장 중요한 컴포넌트는 memory이다. 명령어와 읽고 쓰는 데이터 모두 메모리에 저장되어 있고, 프로세스가 접근 할 수 있는 메모리(주소공간)는 프로세스의 machine state의 일부이다.\n두 번 째 컴포넌트로 레지스터가 있는데, 레지스터는 CPU에 있는 작은 메모리 공간이다. 레지스터는 CPU가 명령어를 실행하는 동안 사용되며, 프로세스의 machine state의 일부이다.\n레지스터중 하나로 program counter가 있는데, 프로그램의 어느 명령어가 실행 중 인지를 알려주는 컴포넌트이다.(명령어 포인터 : Intruction Pointer 로도 불린다.)\n또한 stack pointer와 frame pointer가 있는데, 이것들은 프로세스의 실행 중에 사용되는 메모리 공간을 가리키는 포인터이다.\n그리고 영구 저장장소에 접근하기 위한 것들도 있다.\n요약하자면, 프로세스는 실행중인 프로그램이며, 프로세스를 이해하기 위해서는 프로세스의 machine state를 이해해야 하는데, machine state는 메모리, 레지스터, 프로그램 카운터, 스택 포인터, 프레임 포인터 등이 있다.\n04.2 프로세스 API 실제 프로세스 API는 다음장에서 나오지만, 운영체제가 반드시 API로 제공해야하는 기능들은 다음과 같다.\n생성(Create) : 운영체제는 프로세스를 생성 할 수 있는 방법을 제공해야 한다.\n제거(Destory) : 운영체제는 프로세스를 강제로 제거 할 수 있는 방법을 제공해야 한다.\n대기(Wait) : 운영체제는 프로세스가 다른 프로세스의 종료를 기다릴 수 있는 방법을 제공해야 한다.\n각종 제어(Miscellaneous Control) : 프로세스의 우선순위를 변경하거나, 프로세스의 상태를 변경하는 등의 제어를 제공해야 한다.\n상태 (Status) : 프로세스의 상태를 확인할 수 있는 방법을 제공해야 한다.\n04.3 프로세스 생성: 조금 더 자세히 프로세스의 생성의 첫 단계는 디스크에 있는 프로그램을 메모리에 로드하는 것이다. 현대의 운영체제는 이 과정에서 paging과 swapping같은 기능을 활용하여 실제 지금 필요한 부분만 메모리에 로드하는데 지금 주제와 관련이 없으므로 언급만 한다. 탑재 이후 프로세스를 실행시키기 전에 운영체제가 해야할 일이 있다. 바로 특정한 만큼의 메모리를 Stack, Heap 용도로 나눠서 할당하는 것이다. 또한 입출력과 관련된 것들도 초기화 해야 한다. 그 다음에 main() 함수를 실행시키는 것이다. 04.4 프로세스 상태 프로세스 상태를 단순화 하면 다음 세가지로 구분 할 수 있다. 실행중(Running) : 프로세스가 CPU를 사용하고 있는 상태이다.(명령어를 실행하고 있는 상태) 대기중(Ready) : 프로세스가 CPU를 사용하고 있지 않지만, 언제든지 사용할 수 있는 상태이다. 대기중(Waiting) : 프로세스가 CPU를 사용하고 있지 않고, 어떤 이벤트를 기다리고 있는 상태이다. 프로세스는 운영체제의 스케쥴링 정책에 따라 스케줄이 되면, 준비상태에서 실행상태로 바뀌게 된다.\n프로세스가 입출력등의 완료 이벤트가 필요한 경우, 대기상태로 바뀌게 된다.\n그리고 이렇게 입출력을 포함한 두 프로세스가 CPU를 사용하는 것은 아래의 표와 같이 나타낼 수 있다.\n시간 프로세스0 프로세스1 비고 1 준비 실행 2 실행 준비 3 실행 준비 Process0이 입출력을 시작 4 대기 실행 Process0 대기 상태 5 대기 실행 Process1 실행 6 대기 실행 7 준비 실행 Process0 입출력 종료 8 준비 실행 Process1 종료 9 실행 10 실행 Process0 종료 이러한 방식 (1 프로세스가 실행중이고, 0 프로세스가 대기상태일 때 1을 마무리한게 효율적이었나?) 등을 고민하는건 운영체제의 스케줄러가 담당하고 이부분은 다음장에서 다룬다. 04.5 자료 구조 운영체제도 프로그램이고 프로세스는 운영체제가 관리해야 하는 정보다. 그래서 프로세스를 관리하기 위한 자료구조가 필요하다.\n예를 들어 프로세스의 상태를 저장하는 자료구조가 필요고, 프로세스 리스트와 같은 자료구조를 사용한다.\n또한 현제 실행중인 프로세스를 저장하는 자료구조도 필요하다.\n이러한 예시로 책에서는 register context를 보여준다.\n// 프로세스를 중단하고 이후에 다시 시작할 수 있는 정보를 저장하는 구조체 struct context { int eax; int ebx; int ecx; int edx; int esi; int edi; int eip; int esp; int ebp; }; enum proc_state { UNUSED, USED, ZOMBIE, SLEEPING, RUNNABLE, RUNNING }; struct proc { char *mem; // 프로세스의 메모리 주소 struct context context; // 프로세스의 레지스터 상태 enum proc_state state; // 프로세스의 상태 char *kstack; // 커널 스택바닥주소 int pid; // 프로세스의 고유 식별자 struct proc *parent; // 부모 프로세스 struct proc *children; // 자식 프로세스 void *chan // 0이 아닌 경우, 프로세스가 대기중인 이벤트 int killed; // 0이 아닌 경우, 프로세스가 종료되었음을 나타냄 struct file *ofile[NOFILE]; // 열린 파일 struct inode *cwd; // 현재 디렉토리 }; ","permalink":"http://localhost:1313/_wiki/week-01/","summary":"01 장 - 이 책에 대한 대화 아주 간단한 이 책에 대한 소개를 하는 챕터이다.\n두 장으로 이루어져 있고, 이 책에서 자주 나오게 되는 교수와 학생의 대화 형식으로 이루어져 있다.\n핵심적인 아이디어를 요약하면 다음과 같다.\n리처드 파인만의 물리학 아주 쉬운 6가지 이야기라는 강의 노트가 있다. 물리학이 6만큼 어려우면, 운영체제는 3만큼 어렵기 때문에, 이 책의 제목이 \u0026ldquo;운영체제 아주 쉬운 세 가지 이야기\u0026quot;이다. 이 책은 운영체제에 대한 이야기를 3가지로 나누어서 설명한다. 가상화, 병행성, 영속성 02 장 - 운영체제 개요 이 책에서 다루게 될 내용이지만 아주 간단하게 약식으로 설명하는 글이 있어 가져왔다.","title":"Week-01 📚"},{"content":"00. Introduction 운영체제 아주 쉬운 세가지 이야기 (Operating Systems: Three Easy Pieces)를 회사 사람들과 함께 스터디하면서 정리한 내용입니다. 01. Appendix 강의 소스코드 : OSTEP 테스트 프로그램 : OSTEP Test Programs 역자 강의 자료 : 강의자료 02. Contents [[Week-01]] : 개인 정리 내용 링크 [[OSTEP-Week-01]] : 1주차 스터디 질의응답. 1장 이 책에 대한 대화 2장 운영체제 개요 3장 가상화에 관한 대화 4장 프로세스 의 개념 [[Week-02]] : 개인 정리 내용 링크 [[OSTEP-Week-02]] : 2주차 스터디 질의응답. 5장 막간 : 프로세스 API 6장 제한적 직접 실행 원리 7장 스케줄링 : 개요 [[Week-03]] : 개인 정리 내용 링크 8장 스케줄링 : 멀티 레벨 피드백 큐 9장 스케줄링 : 비례 배분 10장 스케줄링 : 멀티 프로세서 스케줄링 [[Week-04]] : 개인 정리 내용 링크 11장 CPU 가상화에 대한 마무리 대화 12장 메모리 가상화에 관한 대화 13장 주소 공간의 개념 [[Week-05]] : 개인 정리 내용 링크 14장 막간 : 메모리 관리 API 15장 주소 변환의 원리 [[Week-06]] : 개인 정리 내용 링크 03. Homeworks 과제-레포\n[[Chapter-04]]\n","permalink":"http://localhost:1313/_wiki/ostep/","summary":"OSTEP 스터디","title":"운영체제 아주 쉬운 세 가지 이야기 📚"},{"content":"1일 1커맨드 정리 ^ + b, f : 한 페이지씩 스크롤 zz : 현재 커서가 있는 줄을 화면 중앙으로 이동 yi( : 괄호 안에 있는 내용 복사 vap : 비주얼모드 한 문단 블록 씌우기 이동 관련 brace 관련 커맨드를 조금 더 잘쓰면 좋겠다는 생각을 한다.\n개인적으로 vim을 더 잘쓰기 위해서 정리를 잘 해둬야 할 것 같다.\n^ + b, f: 한 페이지씩 스크롤 ^ + d, u: 반 페이지씩 스크롤 e, E: 다음 단어의 끝으로, 문자 단위 이동 w, W: 다음 단어의 처음으로, 문자 단위 이동 $: 줄의 마지막으로 이동 0: 줄의 처음으로 이동 ^: 줄의 처음으로 이동 (공백이 아닌 처음 시작되는 문자) Shift + g: 문서의 마지막으로 이동 gg, 1g: 문서의 처음으로 이동 (숫자 라인으로 이동) ), (: 다음, 이전 문장의 처음으로 이동 }, {: 다음, 이전 문단의 처음으로 이동 ]], [[: 다음, 이전 구절의 처음으로 이동 안녕하세요 Vimwiki 관련 커맨드 Tab – Find next wiki link Shift + Tab – Find previous wiki link Split 관련 커맨드 \u0026lt;leader\u0026gt;sv: 창 수직 분할 \u0026lt;leader\u0026gt;sh: 창 수평 분할 \u0026lt;leader\u0026gt;se: 창 확장 \u0026lt;leader\u0026gt;sx: 창 닫기 lsp 관련 커맨드 \u0026lt;leader\u0026gt;gd: 정의로 이동 키 바인딩 \u0026lt;leader\u0026gt;gR: LSP 참조 표시 \u0026lt;leader\u0026gt;gD: 선언으로 이동 \u0026lt;leader\u0026gt;gd: LSP 정의 표시 \u0026lt;leader\u0026gt;gi: LSP 구현 표시 \u0026lt;leader\u0026gt;gt: LSP 유형 정의 표시 \u0026lt;leader\u0026gt;ca: 사용 가능한 코드 액션 표시 \u0026lt;leader\u0026gt;rn: 스마트 리네임 \u0026lt;leader\u0026gt;D: 버퍼 진단 표시 \u0026lt;leader\u0026gt;d: 줄 진단 표시 \u0026lt;leader\u0026gt;[d: 이전 진단으로 이동 \u0026lt;leader\u0026gt;]d: 다음 진단으로 이동 \u0026lt;leader\u0026gt;K: 커서 아래 항목에 대한 문서 표시 \u0026lt;leader\u0026gt;rs: LSP 재시작 nvim-surround 따옴표 추가\n비주얼 모드에서 텍스트를 선택한 후 S\u0026quot;를 누르면 선택한 텍스트가 큰따옴표로 감싸집니다. 괄호 변경\n예를 들어, ()로 감싸진 텍스트를 {}로 변경하려면 커서를 괄호 안에 두고 cs({를 누르면 됩니다. ","permalink":"http://localhost:1313/_wiki/lsp-cheat-sheet/","summary":"1일 1커맨드 정리 ^ + b, f : 한 페이지씩 스크롤 zz : 현재 커서가 있는 줄을 화면 중앙으로 이동 yi( : 괄호 안에 있는 내용 복사 vap : 비주얼모드 한 문단 블록 씌우기 이동 관련 brace 관련 커맨드를 조금 더 잘쓰면 좋겠다는 생각을 한다.\n개인적으로 vim을 더 잘쓰기 위해서 정리를 잘 해둬야 할 것 같다.\n^ + b, f: 한 페이지씩 스크롤 ^ + d, u: 반 페이지씩 스크롤 e, E: 다음 단어의 끝으로, 문자 단위 이동 w, W: 다음 단어의 처음으로, 문자 단위 이동 $: 줄의 마지막으로 이동 0: 줄의 처음으로 이동 ^: 줄의 처음으로 이동 (공백이 아닌 처음 시작되는 문자) Shift + g: 문서의 마지막으로 이동 gg, 1g: 문서의 처음으로 이동 (숫자 라인으로 이동) ), (: 다음, 이전 문장의 처음으로 이동 }, {: 다음, 이전 문단의 처음으로 이동 ]], [[: 다음, 이전 구절의 처음으로 이동 안녕하세요 Vimwiki 관련 커맨드 Tab – Find next wiki link Shift + Tab – Find previous wiki link Split 관련 커맨드 \u0026lt;leader\u0026gt;sv: 창 수직 분할 \u0026lt;leader\u0026gt;sh: 창 수평 분할 \u0026lt;leader\u0026gt;se: 창 확장 \u0026lt;leader\u0026gt;sx: 창 닫기 lsp 관련 커맨드 \u0026lt;leader\u0026gt;gd: 정의로 이동 키 바인딩 \u0026lt;leader\u0026gt;gR: LSP 참조 표시 \u0026lt;leader\u0026gt;gD: 선언으로 이동 \u0026lt;leader\u0026gt;gd: LSP 정의 표시 \u0026lt;leader\u0026gt;gi: LSP 구현 표시 \u0026lt;leader\u0026gt;gt: LSP 유형 정의 표시 \u0026lt;leader\u0026gt;ca: 사용 가능한 코드 액션 표시 \u0026lt;leader\u0026gt;rn: 스마트 리네임 \u0026lt;leader\u0026gt;D: 버퍼 진단 표시 \u0026lt;leader\u0026gt;d: 줄 진단 표시 \u0026lt;leader\u0026gt;[d: 이전 진단으로 이동 \u0026lt;leader\u0026gt;]d: 다음 진단으로 이동 \u0026lt;leader\u0026gt;K: 커서 아래 항목에 대한 문서 표시 \u0026lt;leader\u0026gt;rs: LSP 재시작 nvim-surround 따옴표 추가","title":"nvim cheat sheet"},{"content":"Cheat Sheet 📜 코틀린 Cheat Sheet : 코틀린을 배워놓고 안써먹다보니 까먹는 부분이 많아 찾아온 Cheat Sheet Coding Test 🧩 cpp-문법-정리 : 코테용 C++ 문법 정리 cpp-문자열 : 문자열 처리 팁 cpp-코테 : 코테 관련 자주 나오는 패턴들 ShortCuts 🚀 [[LSP-Cheat-Sheet]] : Neovim Language Server Cheat Sheet Vim-Cheat-Sheet : Vim Cheat Sheet [[AeroSpace-macOS]] : 윈도우 관리 툴 ","permalink":"http://localhost:1313/_wiki/cheat-sheet/","summary":"Cheat Sheet 📜 코틀린 Cheat Sheet : 코틀린을 배워놓고 안써먹다보니 까먹는 부분이 많아 찾아온 Cheat Sheet Coding Test 🧩 cpp-문법-정리 : 코테용 C++ 문법 정리 cpp-문자열 : 문자열 처리 팁 cpp-코테 : 코테 관련 자주 나오는 패턴들 ShortCuts 🚀 [[LSP-Cheat-Sheet]] : Neovim Language Server Cheat Sheet Vim-Cheat-Sheet : Vim Cheat Sheet [[AeroSpace-macOS]] : 윈도우 관리 툴 ","title":"개발 관련 Cheat Sheet"},{"content":"8.0.0 Common Collections 러스트의 std::collections 모듈은 여러 유용한 자료구조인 컬렉션을 제공한다.\nheap에 저장되는 컬렉션들은 컴파일 시점에 크기를 알 수 없고 늘어나거나 줄어들거나 한다.\n이번 장에서는 Vec\u0026lt;T\u0026gt;, String, HashMap\u0026lt;K, V\u0026gt;에 대해 알아본다.\n8.1.0 Storing Lists of Values with Vectors Vec\u0026lt;T\u0026gt;는 가변 길이의 리스트를 저장할 수 있는 컬렉션이다.\nVec\u0026lt;T\u0026gt;는 동일한 타입의 여러 값을 저장할 수 있고, 다음 자료를 메모리 옆칸에 연속적으로 저장하는 선형 자료구조이다. (배열)\n8.1.1 Creating a New Vector Vec\u0026lt;T\u0026gt;를 생성하는 방법은 두 가지가 있다.\nVec::new(): 빈 벡터를 생성한다. let v: Vec\u0026lt;i32\u0026gt; = Vec::new(); 와 같이 타입을 명시해야 한다.\nvec!: 매크로를 사용하여 초기값을 가진 벡터를 생성한다. let v = vec![1, 2, 3]; 이처럼 초기화까지 한번에 하면 타입을 명시하지 않아도 된다.\n8.1.2 Updating a Vector Vec\u0026lt;T\u0026gt;에 값을 추가하는 방법은 두 가지가 있다.\npush: push 메서드를 사용하여 값을 추가한다. let mut v = Vec::new(); v.push(5); 이처럼 사용한다.\nappend: append 메서드를 사용하여 다른 벡터를 추가한다. let mut v = vec![1, 2, 3]; v.append(\u0026amp;mut vec![4, 5, 6]); 이처럼 사용한다.\n8.1.3 Reading Elements of Vectors Vec\u0026lt;T\u0026gt;의 요소에 접근하는 방법은 두 가지가 있다.\n\u0026amp;v[i]: 인덱스를 사용하여 값을 참조한다. let v = vec![1, 2, 3]; let third: \u0026amp;i32 = \u0026amp;v[2]; 이처럼 사용한다.\nget: get 메서드를 사용하여 값을 참조한다. let v = vec![1, 2, 3]; let third: Option\u0026lt;\u0026amp;i32\u0026gt; = v.get(2); 이처럼 사용한다.\nlet v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is {third}\u0026#34;); let third: Option\u0026lt;\u0026amp;i32\u0026gt; = v.get(2); match third { Some(third) =\u0026gt; println!(\u0026#34;The third element is {third}\u0026#34;), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } 당연하지만 포인트는 get 메서드는 Option\u0026lt;T\u0026gt;를 반환한다는 것이다. 인덱스가 범위를 벗어나면 None을 반환한다.\n\u0026amp;v[i]는 인덱스가 범위를 벗어나면 패닉을 일으킨다.\n두 가지 방법 중 어떤 것을 사용할지는 상황에 따라 다르다. 인덱스가 범위를 벗어나는 경우가 없다면 \u0026amp;v[i]를 사용해서 수상한 시도를 painc으로 몰아 낼 수 있다.\n반대로 인덱스가 범위를 벗어나는 경우가 있을 수 있다면 get 메서드를 사용하여 Option\u0026lt;T\u0026gt;를 반환하게 해서 일어날 법 한 상황에 유연하게 대처하면 된다.\n일단 올바른 인덱스를 건낸다면, borrow checker는 소유권과 borrow 규칙을 따르게 해서 이 참조와 벡터 내용에 대한 다른 참조가 유효하도록 한다.\n// error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {}\u0026#34;, first); 언뜻 보기에는 컴파일 되어야 할 것 같지만, first가 v의 불변 참조를 가지고 있기 때문에 v를 변경할 수 없다.\n또 더 언뜻 보기에는 첫번째 참조와 마지막 원소의 참조와는 아무런 관계가 없어 보이지만, 벡터가 메모리에 저장되는 방식 때문에 이런 제약이 생긴다.\n벡터가 메모리에 저장되는 방식은 다음과 같다.\n벡터는 capacity와 length를 가진다.\ncapacity는 벡터가 메모리에 할당된 공간의 크기를 나타낸다.\nlength는 벡터에 실제로 저장된 요소의 개수를 나타낸다.\n벡터가 메모리에 저장되는 방식은 capacity가 늘어나면 새로운 메모리에 복사하고, length가 늘어나면 새로운 요소를 추가한다.\n여기서 새로은 메모리에 복사되면 첫 번째 참조가 있는 상태에서 새로운 메모리에 복사되면서 첫 번째 참조가 해제된 메모리를 가리키게 되기 때문에 용납하지 않는다.\n8.1.4 Iterating over the Values in a Vector 벡터의 각각의 모든 요소에 접근하려면, 한번에 하나의 인덱스 사용하는 대신, 모든 요소를 순회하면서 접근하는 방법이 있다.\ni32 값의 벡터에서 각 요소에 대한 불변 참조를 얻어 그 값을 출력하는 예제\nlet v = vec![100, 32, 57]; for i in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, i); } i32 값의 벡터에서 각 요소에 대한 가변 참조를 얻어 그 값을 변경하는 예제 let mut v = vec![100, 32, 57]; for i in \u0026amp;mut v { *i += 50; } for 루프를 사용하여 벡터의 요소에 접근할 때, \u0026amp;를 사용하여 불변 참조를 얻거나, \u0026amp;mut를 사용하여 가변 참조를 얻을 수 있다.\n가변 참조가 참조하는 값을 변경하려면 * 연산자를 사용하여 참조를 역참조해야 한다.\nborrow checker 덕에 이러한 행동은 안전하다, (위에서와 동일한 논리로, 벡터에 대한 참조는 전체 벡터의 동시 수정을 방지한다)\n8.1.5 Using an Enum to Store Multiple Types 벡터는 동일한 타입의 값만 저장할 수 있다. 하지만, 열거형을 사용하면 다른 타입의 값들을 저장할 수 있다. enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026#34;blue\u0026#34;)), SpreadsheetCell::Float(10.12), ]; 참고로 이넘의 variant를 식별해야 몇칸씩 읽어야 하는지 알 수 있기 때문에, 이넘을 사용한다면 태그 또는 디스크리미네이터를 메모리의 해당 위치에 저장한다.\n8.1.4 Dropping a Vector Drops Its Elements 벡터가 스코프를 벗어나면, 벡터와 그 안의 요소들이 모두 해제된다. ㅂㅂ 8.2.0 Storing UTF-8 Encoded Text with Strings String은 가변 길이의 텍스트를 저장할 수 있는 컬렉션이다.\nRustcean들이 String을 사용할 때, 아래의 세가지 이유로 막힌다고 한다.\nString은 가능한 에러를 노출시키는 경향이 있다. String은 생각보다 복잡한 자료구조이다. UTF-8\u0026hellip; 결론적으로 이 장에서는 문자열을 컬렉션의 맥락으로 논의한다.\n왜냐하면 실제로 String은 바이트의 컬렉션이며, 텍스트로 해설될 때 유용한 기능을 제공하는 메서드가 추가되었다고 보면 적절하기 때문이다.\nCollection의 맥락에서 CRUD를 논의한다.\n8.2.1 What is a String? 러스트의 String을 먼저 정리해야 한다. 기본적으로는 표준 라이브러리에서 제공하는 가변적이고, 소유권이 있으며, 확장 가능한, UTF-8 인코딩된 문자열 타입니다. 물론 일반적으로 String이라고 하면 해당 String과 str을 모두 포함한다.\n8.2.2 Creating a New String Vec\u0026lt;T\u0026gt;에서 가능한 많은 연산들은 String에서도 가능하다. 그 이유는 String이 Vec\u0026lt;u8\u0026gt;을 래핑하여 추가적인 구현(몇가지 guarantees, restrictions, capabilities 등)되어 있기 때문이다.\n예를들어 생성도 벡터와 똑같이 new를 이용해서 할 수 있다.\nlet mut s = String::new(); 또한 Display 트레이트를 구현한 타입에 대해서 to_string 메서드를 사용할 수 있다.\nlet data = \u0026#34;initial contents\u0026#34;; let s = data.to_string(); let s = \u0026#34;initial contents\u0026#34;.to_string(); let s = String::from(\u0026#34;initial contents\u0026#34;); 8.2.3 Updating a String 기본적으로 벡터와 같이 값을 추가/변경 할 수 있다. 심지어는 + 연산자를 사용하거나, format! 매크로를 사용하여 문자열을 결합 수정 할 수 있다.\nlet mut s = String::from(\u0026#34;foo\u0026#34;); s.push_str(\u0026#34;bar\u0026#34;); s.push(\u0026#39;l\u0026#39;); s += \u0026#34;bar\u0026#34;; s = s + \u0026#34;bar\u0026#34;; s = format!(\u0026#34;{}-{}\u0026#34;, s, \u0026#34;bar\u0026#34;); fn add(self, s: \u0026amp;str) -\u0026gt; String { 참고로 + 연산자는 add 메서드를 호출한다.\n그리고 메서드 정의는 위와 같은데, 여기서 두가지를 알아 볼 수 있다.\nlet s1 = String::from(\u0026#34;Hello, \u0026#34;); let s2 = String::from(\u0026#34;world!\u0026#34;); let s3 = s1 + \u0026amp;s2; 이렇게 사용하면 s1은 더이상 사용할 수 없다. (self를 직접 사용하며 소유권을 가져가기 때문에) 두 번째로 \u0026amp;String은 \u0026amp;str로 강제 변환이 가능하다.\n8.2.4 Indexing into Strings String은 Vec\u0026lt;u8\u0026gt;을 래핑하고 있다고 하기도 했고, 많은 다른 언어에서 문자열을 인덱스로 접근하는게 일반적이라 당연하 가능할 것 같은 아래의 코드는\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let h = s1[0]; 컴파일 에러가 발생한다.\nerror[E0277]: the type `str` cannot be indexed by `{integer}` 간단히 이유를 요약하자면, 메모리에 나열되어있는 바이트들이 UTF-8로 인코딩 되어있기 때문에, 각각의 문자가 다른 바이트 수를 가지고 있는 상황에서 정수 인덱스로 접근하는 것은 불가능하기 때문이다.\n8.2.5 Slicing Strings \u0026ldquo;문자열\u0026quot;을 슬라이싱 하는 것 자체는 나쁜 아이디어 일 수 있지만 정 필요하면 range를 주는 방식으로 사용 할수는 있다.\nlet hello = \u0026#34;안녕하세요\u0026#34;; let s = \u0026amp;hello[0..3]; 하지만 이것도 마찬가지로 UTF-8로 인코딩 되어있기 때문에, 문자열의 일부를 슬라이싱 하는 것은 위험하다.\n8.2.6 Methods for Iterating Over Strings 진짜 결론적으로 실질적으로 문자를 다루고 싶다면 chars 메서드를 사용하면 된다.\nfor c in \u0026#34;안녕하세요\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 8.3.0 Storing Keys with Associated Values in Hash Maps HashMap은 딱히 다른게 없다..\n8.3.1 Creating a New Hash Map \u0026amp; Accessing Values in a Hash Map use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); let team_name = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_name).copied().unwrap_or(0); HashMap은 Option\u0026lt;\u0026amp;T\u0026gt;를 반환하기 때문에 코드는 조금 더 예뻐질 수 있다. (copied로 Option\u0026lt;\u0026amp;T\u0026gt;를 Option\u0026lt;T\u0026gt;로 받고, unwrap_or로 기본값을 설정한다.)\n8.3.2 Hash Maps and Ownership let field_name = String::from(\u0026#34;Favorite color\u0026#34;); let field_value = String::from(\u0026#34;Blue\u0026#34;); let mut map = HashMap::new(); map.insert(field_name, field_value); Ownership 자체는 동일하게 동작한다. Copy 트레이트를 구현한 타입은 복사되어 저장되고, 그렇지 않은 타입은 소유권이 이전된다. (정확히는 insert method로 이동 후 drop)\n8.3.3 Updating a Hash Map let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); scores.entry(String::from(\u0026#34;Blue\u0026#34;)).or_insert(50); 8.3.4 Overwriting a Value let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 25); 8.3.5 Only Inserting a Value If the Key Has No Value let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.entry(String::from(\u0026#34;Yellow\u0026#34;)).or_insert(50); scores.entry(String::from(\u0026#34;Blue\u0026#34;)).or_insert(50); 8.3.6 Updating a Value Based on the Old Value let text = \u0026#34;hello world wonderful world\u0026#34;; let mut map = HashMap::new(); for word in text.split_whitespace() { let count = map.entry(word).or_insert(0); *count += 1; } ","permalink":"http://localhost:1313/_wiki/common-collections/","summary":"8.0.0 Common Collections 러스트의 std::collections 모듈은 여러 유용한 자료구조인 컬렉션을 제공한다.\nheap에 저장되는 컬렉션들은 컴파일 시점에 크기를 알 수 없고 늘어나거나 줄어들거나 한다.\n이번 장에서는 Vec\u0026lt;T\u0026gt;, String, HashMap\u0026lt;K, V\u0026gt;에 대해 알아본다.\n8.1.0 Storing Lists of Values with Vectors Vec\u0026lt;T\u0026gt;는 가변 길이의 리스트를 저장할 수 있는 컬렉션이다.\nVec\u0026lt;T\u0026gt;는 동일한 타입의 여러 값을 저장할 수 있고, 다음 자료를 메모리 옆칸에 연속적으로 저장하는 선형 자료구조이다. (배열)\n8.1.1 Creating a New Vector Vec\u0026lt;T\u0026gt;를 생성하는 방법은 두 가지가 있다.","title":"러스트의 컬렉션 모아보기"},{"content":"7.0 패키지, 크래이트, 모듈을 이용해 커지는 프로젝트를 관리하기 프로젝트가 커지면서 코드를 관리하는 것이 중요해진다, 기능을 단위로 모듈화하고 나눠야 관리하는것이 편리하다.\n이 챕터는 그러한 것들을 하는 방법을 다룬다.\n높은 레벨에서의 코드 재사용성을 위해 encaptulating, implementing등 달성하는 방법을 다룬다.\n실제 구현을 알지 못해도 사용할 수 있는 인터페이스로 추상화를 제공하는 방법을 다룬다.\nscope와 namespace를 이용해 코드를 구조화하는 방법을 다룬다.\n위에 내용들을 아우르는 러스트의 모듈화 시스템은 아래와 같다.\npackage : 크레이트를 빌드하고 공유하는 단위 crate : 라이브러리나 실행파일을 빌드하는 단위 module : 코드를 그룹화하고 namespace를 제공하는 단위 path : 모듈을 참조하는 방법 7.1 Package and Crates crate는 러스트의 컴파일러가 한번에 고려 할 수 있는 가장 최소의 코드 단위이다.\ncargo 가 아닌 rustc로 컴파일을 하는 경우에, 하나의 소스코드파일만 컴파일 하더라도, 컴파일러는 그 하나의 파일을 하나의 크레이트로 취급한다.\ncrate는 모듈을 포함 할 수 있는데, 해당 모듈은 crate로 컴파일된 다른 모듈에 정의 된 것을 사용할 수 있다.\ncrate는 두가지 형태로 나뉜다.\nbinary crate : 실행파일을 만드는 크레이트, cli 프로그램이나 서버 프로그램처럼, 또한 main함수를 꼭 ㅎ포함해야한다. library crate : 라이브러리를 만드는 크레이트, main함수를 포함하지 않으며, 실행 가능한 바이너리를 만들지 않는다. crate root는 컴파일러가 크레이트를 시작하는 파일을 가리킨다. 이 파일은 crate의 루트 모듈을 정의한다.\npackage는 하나 이상의 크레이트들을 포함하는(bundle) 단위이다.\npackage는 Cargo.toml파일을 가지며, 이 파일은 package의 메타데이터를 정의해서 package 내부의 해당 크레이트들을 어떻게 빌드 해야 하는지 알려준다.\npackage는 하나의 크레이트만 포함 할 수도 있고, 여러개의 크레이트를 포함 할 수도 있다.\n다수의 binary crate를 가질 수 있으나, 하나의 library crate만 가질 수 있다.\nsrc/main.rs와 src/lib.rs는 각각 binary crate와 library crate의 crate root이다.\n7.2 Defining Modules to Control Scope and Privacy 이 챕터에서는 모듈과 모듈 시스템에 대해 다룬다. 주요 키워드들은 다음과 같다\nmodule : 코드를 그룹화하고 namespace를 제공하는 단위 use : 모듈을 다른 스코프로 가져오는 키워드 as : 가져온 모듈을 다른 이름으로 사용하는 키워드 pub : 모듈을 공개하는 키워드 7.2.1 Modules Cheetsheet 러스트의 모듈 시스템이 따르는 규칙과 동작하는 방법은 아래와 같다.\nStart from the crate root : 크레이트를 컴파일 할 때, 컴파일러는 컴파일 할 코드를 찾기 위해 crate root를 찾는다. (src/main.rs와 src/lib.rs).\nDeclaring modules : crate root에서 새로운 모듈들을 선언 할 수 있따. 모듈은 mod 키워드와 선언한다. 예를들어 mod garden;과 같이 선언하면 컴파일러는 모듈의 코드를 아래와 같은 위치에서 찾는다\nDefining modules in other files : 모듈을 다른 파일에 정의 할 수 있다. 이때 파일의 이름은 모듈의 이름과 같아야 한다. 예를들어 mod garden;이라고 선언하면, garden.rs나 garden/mod.rs파일을 찾는다.\nInline : mod garden { ... } 와 같이 중괄호와 세미콜론으로 정의된 모듈이 있는지 인라인에서 찾는다. File : src/garden.rs나 src/garden/mod.rs파일을 찾는다. Declaring subomodules : 모듈 내부에 또 다른 모듈을 선언 할 수 있다(crate root에는 안된다). 이때도 mod 키워드를 사용한다. 이번에는 mod vegetables;를 mod garden;안에 선언하면 아래와 같은 순서로 찾는다.\nInline : mod vegetables { ... } 와 같이 중괄호와 세미콜론으로 정의된 모듈이 있는지 인라인에서 찾는다.\nFile : src/garden/vegetables.rs나 src/garden/vegetables/mod.rs파일을 찾는다.\nPaths to code in modules : 모듈이 크레이트에 일부가 된다면, 해당 모듈의 코드를 크레이트의 어디에서든 참조할 수 있다. 만약 pricacy 규칙에 어긋나지 않는다면 Asparagus모듈의 type을 호출하려면 crate::garden::vegetables::Asparagus와 같이 호출 할 수 있다.\nPrivate vs public : 모듈 내부의 코드는 기본적으로 private이다. pub 키워드를 사용해 모듈을 공개 할 수 있다. 모듈을 공개하면, 다른 크레이트에서 해당 모듈을 사용 할 수 있다.\nUse : use 키워드를 사용해 모듈을 가져올 수 있다. use 키워드는 모듈을 현재 스코프로 가져온다.\n// binary crate name backyard backyard ├── Cargo.lock ├── Cargo.toml └── src ├── garden │ └── vegetables.rs ├── garden.rs └── main.rs File : src/main.rs\nuse crate::garden::vegetables::Asparagus; pub mod garden; fn main() { let plant = Asparagus {}; println!(\u0026#34;I\u0026#39;m growing {:?}!\u0026#34;, plant); } File : src/garden.rs\npub mod vegetables; File : src/garden/vegetables.rs\npub struct Asparagus { pub name: String, } 7.2.2 Grouping Related Code in Modules 모듈은 크레이트 내부의 코드를 조직화햇해서 읽기 쉽고 재사용 가능한 코드를 만들 수 있게 해준다.\n또한 private과 public으로 코드의 접근성을 제어할 수 있다.\n기본적으로 private으로 캡슐화 하기 때문에, 다른 코드에서 해당 구현을 알거나 사용할 수 없다.\n실제로 사용하거나 의존해야 할 코드들만 public으로 만들면 된다.\n아래는 모듈을 사용해 레스토랑을 만드는 예제이다.\nFilename : src/lib.rs\nmod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } } 이런식으로 모듈을 사용하고, 그룹화해두면 왜 관련되어 있는지를 알 수 있고, 그러한 코드들을 쉽게 찾을 수 있다.\n마찬가지로 이 모듈에 코드를 추가/수정 할 때도, 그러기 위한 가이드라인을 제공해 줄 수 있다.\nmodule tree\ncrate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 참고로 src/main.rs나 src/lib.rs는 crate root인 이유는, 이 두 파일중 하나가 크레이트의 모듈구조 루트인 모듈 crate를 선언하기 때문이다.\n그리고 그 아래에 마치 파일시스템처럼 모듈이 구조화 될 수 있다.\n7.3 Paths for Referring to an Item in the Module Tree 위에 살짝 언급한 것처럼 우리가 러스트에서 모듈의 아이템을 찾기 위해서는 파일시스템처럼 path를 기반으로 찾아나가게 된다.\npath는 두가지 형태가 있다.\nabsolute path : 크레이트의 루트에서 시작하는 경로, 루트는 crate나 mod 키워드로 선언된 모듈이다. relative path : 현재 모듈에서 시작하는 경로, self, super, 혹은 아이템의 이름으로 시작한다. 두 경로 모두, 하나 이상의 식별자와 :: 로 구분된다.\n아래는 crate의 루트 모듈에서 front_of_house모듈의 hosting모듈의 add_to_waitlist함수를 호출하는 예제이다.\nmod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist(); } 첫 번째 호출은 crate의 루트 모듈에서 시작하는 absolute path이다.\n두 번째 호출은 현재 모듈에서 시작하는 relative path이다.\n가능하면 상대경로 대신 절대경로를 지정하는 것이 낫다고 이야기한다. 당연히 일장일단은 있지만, 코드 수정이나 리팩토링을 할 때, 수정이 얼마나 적어질지가 가장 주요한 기준이라고 했을 때, 코드 정의와 호출을 서로 독립적으로 이동하려는 경우가 더 많이 때문이라고 이야기한다. 호출하는 부분이 정의된 부분에 대한 상대경로를 사용하면, 정의된 부분이 다른곳으로 옮겨졌을 때, 호출하는 부분의 변경이 생기는 상황이 더 자주 발생한다.\n무튼 위의 코드는 동작하지 않는다. 왜냐하면 add_to_waitlist함수는 private이기 때문이다.\n이를 해결하기 위해서는 pub키워드를 사용해야 한다.\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } 7.4.1 Starting Relative Paths with super super 키워드를 사용해 상위 모듈로 이동할 수 있다.\nfile system에서 ..과 같은 역할을 한다.\n부모 모듈과 자식 모듈이 연관되어 있을 때, rearrange를 할 때 유용하다.\nFilename : src/lib.rs\nfn deliver_order() {} mod back_of_house { fn fix_incorrect_order() { cook_order(); super::deliver_order(); } fn cook_order() {} } 이러한 기능을 제공하는 이유는, 모듈의 구조를 변경할 때, 코드를 수정하지 않고도 모듈의 위치를 변경할 수 있게 해주기 때문이다. 7.3.2 Making Structs and Enums Public 구조체와 열거형에서도 pub키워드를 사용해 접근성을 제어 할 수 있지만, 추가적으로 알아야 할 것이 있다.\n구조체가 public이라고 해서 그 구조체의 필드가 public이 되는 것은 아니다.\n구조체의 필드를 public으로 만들려면, 구조체의 필드를 public으로 만들어야 한다.\nmod back_of_house { pub struct Breakfast { pub toast: String, seasonal_fruit: String, } impl Breakfast { pub fn summer(toast: \u0026amp;str) -\u0026gt; Breakfast { Breakfast { toast: String::from(toast), seasonal_fruit: String::from(\u0026#34;peaches\u0026#34;), } } } } pub fn eat_at_restaurant() { // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(\u0026#34;Rye\u0026#34;); // Change our mind about what bread we\u0026#39;d like meal.toast = String::from(\u0026#34;Wheat\u0026#34;); println!(\u0026#34;I\u0026#39;d like {} toast please\u0026#34;, meal.toast); // The next line won\u0026#39;t compile if we uncomment it; we\u0026#39;re not allowed // to see or modify the seasonal fruit that comes with the meal // meal.seasonal_fruit = String::from(\u0026#34;blueberries\u0026#34;); } 위의 코드는 private으로 선언된 seasonal_fruit필드가 있어 해당 필드를 접근하려고 하면 컴파일 에러가 발생한다.\n심지어 해당 struct의 인스턴스를 생성할 때도, 해당 필드를 초기화 할 수 없기 때문에, summer와 같은 생성자를 만들어서 사용해야 한다.\n패키지와 클래스의 의의가 상대적으로 불분명했던 자바와 달리, 러스트는 패키지와 크레이트의 경계가 명확하고, 어떠한 의미에서는 캡슐화에 대한 더 다양한 제어를 제공한다.\n반대로 enum은 그 자체로 public이면, 그 안에 있는 모든 variant들도 public이다.\nmod back_of_house { pub enum Appetizer { Soup, Salad, } } pub fn eat_at_restaurant() { let order1 = back_of_house::Appetizer::Soup; let order2 = back_of_house::Appetizer::Salad; } 7.4 Bringing Paths into Scope with the use Keyword use 키워드를 사용하면, 모듈의 아이템을 현재 스코프로 가져올 수 있다.\nuse 키워드는 ::를 사용해 접근해야 하는 아이템을 간단하게 사용할 수 있게 해준다.\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } use 키워드를 사용하면, symbolic link를 만드는 것과 같다.\nuse 는 use를 선언한 스코프에서만 유효하다.\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { use crate::front_of_house::hosting; hosting::add_to_waitlist(); } fn seat_at_table() { hosting::add_to_waitlist(); // 컴파일 에러 } 7.4.2 Creating Idiomatic use Paths use 키워드를 사용해서 함수를 특정해서 가져오는것이 아니라 모듈을 가져오는 것이 의아 할 수 있다. mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting::add_to_waitlist; pub fn eat_at_restaurant() { add_to_waitlist(); } 물론 결과는 같다.\n이렇게 부모 모듈까지 불러오면, 실제로 사용 할 때는 hosting::add_to_waitlist와 같이 사용해야 하고, 이렇게 하면서 이 함수가 로컬에 정의되어 있지 않다는 것을 알리면서 최소한의 경로를 사용 할 수 있게 해준다.\n반대로 use 키워드를 사용해 함수를 가져오면 해당 함수가 어디에 정의되어있는지 헷갈릴 수 있다.\n반대로 struct나 enum을 가져올 때는, 전체 경로를 명시하는것이 관용적이다.\nuse std::collections::HashMap; fn main() { let mut map = HashMap::new(); map.insert(1, 2); } 딱히 이유는 없고, 그냥 관용적인 방법이다.\n또한 use 키워드를 사용해 여러개의 아이템을 가져올 때 같은 이름을 가진 아이템을 가져올 수 없다.\nuse std::fmt; use std::io; fn function1() -\u0026gt; fmt::Result { // --snip-- } fn function2() -\u0026gt; io::Result\u0026lt;()\u0026gt; { // --snip-- } 만약 아래와 같이 사용하면 컴파일 에러가 발생한다.\nuse std::fmt::Result; use std::io::Result; fn function1() -\u0026gt; Result { // --snip-- } fn function2() -\u0026gt; Result\u0026lt;()\u0026gt; { // --snip-- } 이런 경우에는 as 키워드를 사용해 다른 이름으로 가져올 수 있다. use std::fmt::Result; use std::io::Result as IoResult; fn function1() -\u0026gt; Result { // --snip-- } fn function2() -\u0026gt; IoResult\u0026lt;()\u0026gt; { // --snip-- } 7.4.3 Re-exporting Names with pub use 기본적으로 use 키워드로 가져온 아이템은 private이다.\n만약 가져온 아이템을 public으로 만들고 싶다면, pub use 키워드를 사용하면 된다.\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } 이렇게 하면 hosting모듈은 public이 되고, add_to_waitlist함수도 public이 된다.\nrestaurant::front_of_house::hosting::add_to_waitlist와 같이 사용해야 하는 것을.\nrestaurant::hosting::add_to_waitlist와 같이 사용할 수 있다.\n이러한 기능은, 코드의 내부 구조가 이 코드를 사용하려는 프로그래머에게 노출되지 않도록 할 수 있다. (노출되지 않으므로 변경되어도 영향을 받지 않고, 도메인에 대한 생각을 하지 않을 수 있다.)\n7.4.4 Using External Packages 외부 패키지를 사용할 때는, Cargo.toml에 의존성을 추가하고, use 키워드를 사용해 가져올 수 있다.\nuse 키워드를 사용해 가져올 때는, 패키지의 이름을 사용해야 한다.\n[dependencies] rand = \u0026#34;0.8.3\u0026#34; use rand::Rng; fn main() { let secret_number = rand::thread_rng().gen_range(1..101); println!(\u0026#34;The secret number is: {}\u0026#34;, secret_number); } 이렇게 하면 rand패키지의 Rng trait을 가져올 수 있다.\nRng trait의 스코프에 있는 thread_rng함수를 호출하고, gen_range함수를 호출 할 수 있다.\n7.5 Separating Modules into Different Files 파일시스템과 이름을 조금 생각해두면 딱히 어려운건 없기에 생략~ ","permalink":"http://localhost:1313/_wiki/managing-growing-projects-with-packages-crates-and-modules/","summary":"7.0 패키지, 크래이트, 모듈을 이용해 커지는 프로젝트를 관리하기 프로젝트가 커지면서 코드를 관리하는 것이 중요해진다, 기능을 단위로 모듈화하고 나눠야 관리하는것이 편리하다.\n이 챕터는 그러한 것들을 하는 방법을 다룬다.\n높은 레벨에서의 코드 재사용성을 위해 encaptulating, implementing등 달성하는 방법을 다룬다.\n실제 구현을 알지 못해도 사용할 수 있는 인터페이스로 추상화를 제공하는 방법을 다룬다.\nscope와 namespace를 이용해 코드를 구조화하는 방법을 다룬다.\n위에 내용들을 아우르는 러스트의 모듈화 시스템은 아래와 같다.\npackage : 크레이트를 빌드하고 공유하는 단위 crate : 라이브러리나 실행파일을 빌드하는 단위 module : 코드를 그룹화하고 namespace를 제공하는 단위 path : 모듈을 참조하는 방법 7.","title":"Package, Crates, Modules"},{"content":"0. 요즘 드는 생각과 걱정은 보통 AI와 관련된 것.. 물론 피상적으로 AI가 나를 대체하지 않을까? 와 같은 걱정을 하는 것은 아니다.\n그렇게 되지 않을 자신도 있다.\n다만 나의 시장 가치를 고민 할 때, 어떠한 방식으로 발전해야 AI가 만들어갈 앞으로의 환경에서 가치가 높은 사람이 될 수 있을지에 대한 고민이 많았다.\n사람들이 이야기 하는 부분은 주로 아래와 같이 두 부류로 나뉘는 것 같다.\n특정 지점 이하의 기술적인 지식은 AI가 대체할 수 있을 것이고, 사람은 문제를 만들어가고, AI라는 도구를 이용해 문제를 해결해야 한다 라는 관점 젠슨 황이 이야기하는 관점인 것 같다. 프로그래밍을 하지 않아도 사람들이 프로그램을 만들 수 있게 된다고 말하며, 결국 그것을 잘 이용하는 능력 + 도메인의 지식등 문제를 만들고 설계하는 능력이 중요하다고 이야기하는 것 같다. 실제로 본인이 대학시절로 돌아간다면 생명공학을 전공할 것이라고 이야기한다.(그 쪽이 해결해야 할 문제가 많다고 생각하기 때문이라고 한다.) 오히려 기본적인 지식을 (1번의 관점에서는 ai가 대체해줘야 할, 블랙박스가 되어야 할 지점)을 강조하는 입장. 물론 칩 설계 분야에 대한 이야기 였지만, ai가 발생시킬 생산성을 정확히 이해하고 이용하려면 본질적인 지식이 필요하다는 것을 강조하는 것 같다. 도메인에 대한 특정성이 있지만, 적어도 논리적인 부분에서는 1번의 관점과 정확히 배치되는 이야기이다. AI가 너무 꽃밭인 관계로 이러한 관점에서 이야기 하는 사람이 반가워서 아래의 인터뷰 내용을 정리하려고 한다. 1.짐 켈러의 인터뷰 이 인터뷰는 AI 뿐 아니라 요즘 내가 가장 많이 하고 있는 고민들과 많이 맞닿아 있었다.\n주로 시간을 어디에 써야 하는지에 대해서 내가 가장 많이 고민하는 부분은 아래와 같다.\n해결해야 할 문제를 해결하는데만 집중해서 흘러가는 방식. 더 많은 문제해결이 더 많은 성장을 야기한다는 관점이다. 조금 더 시간을 쓰더라도, 정확한 내용을 이해하고, 본질을 파악하는데 집중하는 방식. 이렇게 되면 문제해결에는 돌아가게 된다. 단적으로 예를 들면, 극단적인 이야기지만, 스프링 웹 백엔드 서버를 만들어야 한다고 할 때,\n1번의 관점에서는, 일단 가장 빠른 설정을 진행하고, 컨트롤러쪽에 로직을 작성하려고 할 것이다. 아마도 서비스 로직이 복잡해질 때, 영속성 데이터가 필요해질 때, 필요한 부분을 추가하게 될 것이며\n필요에 의해 도입한 새로운 기술이기에 빠르게 공부가 되고, 빠르게 적용이 될 수 있을 것이다.\n2번의 관점이라면, 먼저 톰캣이 어쩌고, 서블릿이 어쩌고, 스레드가 어쩌고, bean과 의존성 주입등이 어쩌고 저쩌고를 먼저 이해하려고 할 것이며, 코드 한 줄 짜지 않은 상태에서 이러한 부분을\n이해하려고 하는 것, 심지어는 해당 기술 등장 이전의 불편함을 인지하는등의 컨텍스트 없이 기술을 이해하려면 시간이 많이 걸리고 비효율적일 것이다,\n묘하게 내 글을 내가 읽어도 후자를 더 진중하고 우호적으로 생각하는 느낌이 들지만, 실제로는 매우 첨예할 정도로 엄대엄인 문제라고 생각한다.\n이러한 관점에서 짐 켈러의 이야기는 매우 흥미로웠다. (모두에게 첨예할 문제일 것이라 생각했고, 사회자도 그렇게 생각했기에 질문을 던졌을 것이지만, 짐켈러는 명확한 입장을 가지고 있었다)\n결론적으로 짐 켈러는 2번의 관점을 강조했다.\n사실 2번을 강조하기만 했다면 포스팅을 하지는 않았을 것이다. 하지만, 사회자의 질문에 응대하면서 나온 이야기들은 어떻게 균형을 찾아가야 하는지에 대한 매우 좋은 답변이었다.\n먼저 짐켈러는 레시피에 대한 이야기를 한다. 사람들은 레시피를 따라서 요리를 한다고 한다. 그러나, 요리를 이해하고 요리를 한다는 것은 다르다고 한다.\n레시피를 따라서 빵을 만드는 방법\n밀가루를 넣는다. 물을 넣는다. 이스트를 넣어 반죽과 섞는다. 부풀도록 놔둔다. 접시에 넣고 오븐에 넣는다. 빵 한덩이를 이해한다는 것\n발효의 생물학적 원리를 이해한다. 재료 유통 방식을 이해한다. 물리학, 열역학, 화학적 원리를 이해한다. 이런 관점으로 나누면 레시피에는 한계가 존재한다.\n레시피를 통해 빵을 만든 사람은 오믈렛을 만들 수 없다는 것이다.\n레시피를 이해하는 사람은 다른 요리도 만들 수 있다.\n더 자세히 나눠서 보면, 레시피는 수많은 블랙박스와 그로인한 가설로 이루어져 있다.\n이스트를 넣어 반죽과 섞을 때, 이스트가 물과 밀가루를 어떻게 변화시키는지를 알지 못하고 그 부분을 블랙박스로 둔다면, 뭔가 맛있게 만들어준다는 가설을 믿고 행동하는 것이다.\n여기까지는 명확한 입장 표명이고, 근거가 필요한데 사회자가 그런 부분을 잘 짚어주었다.\n2. 사회자의 질문 Q. \u0026lsquo;그럼 좋은 제품을 개발하려면 모든 지식을 100% 이해 해야 하나요?\u0026rsquo;\nA. 그 사이의 균형을 잘 유지해야죠. 예술가인 동시에 과학자가 되어야 합니다. 이미 정해진 레시피를 따르지 않고, 모든 것을 이해하려고만 한다면 아무것도 만들지 못할 겁니다.\nA. 그러나, 레시피를 따르기만 한다면, 언젠가는 잘못된 제품을 만들 겁니다.\nQ. 그렇다면 대체 얼마나 깊게 이해해야 하나요? 컴퓨터를 만드는 기술자라면 컴퓨터의 정확한 정의부터 시작해서 기술자로서 어떤 목적을 가져야 하는지, 어떤 태도를 갖고 컴퓨터를 만들어야 하는지, 복잡ㅂ한 컴퓨터 공학과 물리학 이론 등등.. 이런 것들을 전부 알아야 할까요?\nA. 아니요, 쉽게 생각해보죠, 만약 여러분에게 일을 맡긴 의뢰인이 컴퓨터 성능을 10% 높이고 싶다면, 메모리 용량을 늘리거나 부품을 추가하겠죠,\n아니면 컴퓨터 설정을 만져서 효율을 최대치로 끌어올릴 겁니다. 하지만 부품을 추가하고 설정을 바꿀 수록 구조도 복잡해지고 관리도 어렵죠,\n언젠가는 벽에 부딪힐 겁니다. 아무리 부품을 덕지덕지 붙여도 성능이 높아지지 않을 겁니다. 그럴 때 누군가는 \u0026lsquo;어쩔 수 없어요. 이게 한계입니다\u0026rsquo; 라고 말할 겁니다.\n하지만, 누군가는 \u0026lsquo;지금의 구조는 더이상 한계야 뭘 새롭게 추가한다고 바뀔건 없어 새로운 구조를 다시 짜보자.\u0026rsquo; 라고 말할 겁니다. 그렇게 기존 구조를 뜯어보고 난 후에\n사람들은 비로소 알게 됩니다. 아예 처음부터 새로운 구조를 만드는 것이 훨씬 빠르고 간단한 방법이에요.\n이 부분에 대해서는 좋은 가이드라인을 제시해 줬다고 생각한다. 처음부터 모든 것을 이해하려고 하지 않고, 처음부터 모든 것들을 이해하는 것을 상정하지 않았기 때문이다. 인용한 비유에서는, 레시피를 따르다 한계에 부딪히면, 구조를 뜯어보고 새로운 구조를 만들어내야 한다는 이야기를 한다. 즉 우리에게는 레시피를 통해 한계에 도달할 시간이 있고, 심지어 그 이후에도 구조를 뜯어볼 시간이 있다는 것이다. 다만 그 시간 이후에는 본질에대한 이해만이 다음 스텝으로 나아갈 수 있는 힘을 줄 것이다.\n3. 내가 느낀 점 다시 돌아와 1번의 관점에서 지향해야 할 것 은, 수많은 블랙박스와 기술부채를 남기더라도 앞으로 나아가는 것이다.\nAI도구들은 훨씬 더 많은 문제를 해결해주는 댓가로 정말 수많은 블랙박스와 가설 기술부채를 남길 것이다.\n더 많은 레시피를 통해 훨씬 빠르고 효율적으로 많은 문제를 해결해주는 도구라고 생각한다.\n내가 얻은 것은, 지향해야 할 것에 대한 관점이다.\n단순히 더 많은 요구와 더 많은 해결을 통해 나아가는 것만이 유리하다고 말하는 상황에서, 더 많은 이해와 본질을 통해 나아가는 것이 더 중요하다고 이야기 하는 사람을 만나게 되었다.\n애초에 이분법적이고 한쪽을 배제한 관점과 그에대한 이야기가 아니라, 지향점에 대해서 이해나 본질을 덮어두지 않아도 된다고 이야기 하는 사람을 만나서 반가웠다\n","permalink":"http://localhost:1313/_wiki/interview-from-jim-keller/","summary":"0. 요즘 드는 생각과 걱정은 보통 AI와 관련된 것.. 물론 피상적으로 AI가 나를 대체하지 않을까? 와 같은 걱정을 하는 것은 아니다.\n그렇게 되지 않을 자신도 있다.\n다만 나의 시장 가치를 고민 할 때, 어떠한 방식으로 발전해야 AI가 만들어갈 앞으로의 환경에서 가치가 높은 사람이 될 수 있을지에 대한 고민이 많았다.\n사람들이 이야기 하는 부분은 주로 아래와 같이 두 부류로 나뉘는 것 같다.\n특정 지점 이하의 기술적인 지식은 AI가 대체할 수 있을 것이고, 사람은 문제를 만들어가고, AI라는 도구를 이용해 문제를 해결해야 한다 라는 관점 젠슨 황이 이야기하는 관점인 것 같다.","title":"짐켈러의 인터뷰를 보고 든 생각"},{"content":"블로그를 만드는데 시간을 쏟고, 글을 쓰면서 들던 생각들 3월과 4월간 가장 많은 시간을 쏟은건 블로그와 neovim인 것 같다. 원하는 만큼의 공부 진도가 아니라 아쉬운 와중에, 블로그등에 뭔가 개인 시간을 지나치게 많이 썼나 싶어서 드는 생각을 써보려고 한다.\n블로그를 만들게 된 계기 시작은 당연히 이직과 관련된 이유였다. 생각보다 회사 일에 대한 개발 내용을 이력서에 정리하기는 쉽지 않았고, 포트폴리오를 내기에도, 금전적으로 엮인게 많아 올릴 수 없어 블로그를 만들게 되었다.\n적어도 내 취향에 보기 좋게 블로그를 만들고, 기계적으로 정리를 하다 보면 내가 무엇을 했는지, 어떤 공부를 했는지, 어떤 프로젝트를 했는지 정리가 되어 경력기술서의 역할을 대신할 수 있을 것이라 생각했다.\n블로그를 만들고 나서 느낀 점 사실 이 부분 때문에 해당 포스팅을 작성하고 있다. 좋은 인사이트를 얻고, 삶에 유의미한 변화가 있게 된 것 같다.\nAS-IS 원래도 private wiki를 vimwiki를 이용해서 작성하고 있지만, 사실상은 cmd + f 용도로만 사용하고 있었다. (내가 기계적으로 암기해야하는 것들을 대충 때려넣고 필요할때 검색하는 정도)\n내 생활에 무의미한 루틴이 많았었다. 예를들어 아침에 일어나서 비몽사몽 한 채로 처음 하는 일이 변기에 앉아 주로 방문하는 커뮤니티 사이트나, 유튜브 리스트를 보는 것이었다.\n물론 무의미하다는 것은 지나치게 비관적인 표현일 수 있는게, 생각보다 커뮤니티 사이트들이나 유튜브에서도 많은 것들을 배우거나 알게되고 심지어 좋은 인사이트를 얻은 적도 많다.\n문제는 그러한 생각과 알게된 것들, 인사이트들이 매우 휘발성이 높다는 것이다. 그리고 그것들을 나중에 다시 찾아보거나, 다시 생각해보기가 어렵다.\n그렇게 얻은 것들을 아이폰의 Reminder에 적어놓기는 하지만, 그것들이 장기적인 생각이나 지식으로 가는 경우는 극히 일부였다.\n그나마도 그러한 인사이트로 발전되는 경우는 일부였고, 금새 다른 소모적인 것들 (축구, 게임)과 같이 쉽고 생각을 안하게 되는 쪽으로 빠지는 경우가 많았다.\nTO-BE TO-BE로 옮겨 적기에 아래의 일들이 전부 실제로 일어난 것은 아니다.\n블로그를 작성하면서, 생각보다 비몽사몽 한 채로 변기에 앉아서 키는 사이트의 비중이 블로그로 많이 옮겨졌다.\n개인 위키쪽에 기록해둔 영상들도 보게 되는 것 같다. 내 생각으로 다시 정리를 한 글에서는 더 많은 인사이트를 얻거나 더 많은 것을 얻을 수 있도록 노력하는 시간이 조금 더 길어지는 것 같다.\n사실 이러한 일들은 극히 일부에서만 일어났는데, 러스트 기본 문법을 정리한 페이지들을 다시금 열어보면서 뭔가 들었던 생각을 되짚는 일이 많아진 것 같았고, 실제로 블로그의 수정도 많이 했다.\n그러던 과정 중에 진짜 인사이트를 얻었는데, 블로그를 작성하면서 기록을 이어가두면 좋은 인사이트들을 이어갈 수 있다는 생각이 들었다.\n원래는 공개된 공간에 글을 쓰는게 두려워서, 내가 정확히 알고 있는 것들에 대한 것들만 작성을 하려고 하고, 애매하게 아는 것들에 대한 검증을 하느라 글을 쓰는게 매우 demanding한 일이었는데,\n앞으로는 조금 더 그냥 내가 보겠다는 생각으로, 적어도 private쪽 공간에는 글을 편하게 쓰기로 했다.\n결론은 내 생각이나 인사이트를 연속성, 지속성 있게 가져가기 위한 도구로 활용해보려고 한다.\n그래서 누가 볼지 몰라서 utterance라도 달아야 하나 하는 생각을 하고 있다. 적어도 너무 잘못된 글은 댓글로 알려주면 수정하겠다는 마음으로.\n","permalink":"http://localhost:1313/_wiki/blog%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81/","summary":"블로그를 만드는데 시간을 쏟고, 글을 쓰면서 들던 생각들 3월과 4월간 가장 많은 시간을 쏟은건 블로그와 neovim인 것 같다. 원하는 만큼의 공부 진도가 아니라 아쉬운 와중에, 블로그등에 뭔가 개인 시간을 지나치게 많이 썼나 싶어서 드는 생각을 써보려고 한다.\n블로그를 만들게 된 계기 시작은 당연히 이직과 관련된 이유였다. 생각보다 회사 일에 대한 개발 내용을 이력서에 정리하기는 쉽지 않았고, 포트폴리오를 내기에도, 금전적으로 엮인게 많아 올릴 수 없어 블로그를 만들게 되었다.\n적어도 내 취향에 보기 좋게 블로그를 만들고, 기계적으로 정리를 하다 보면 내가 무엇을 했는지, 어떤 공부를 했는지, 어떤 프로젝트를 했는지 정리가 되어 경력기술서의 역할을 대신할 수 있을 것이라 생각했다.","title":"Blog에 대한 생각 정리 글"},{"content":"6 Enum and Pattern Matching In this chapter, we’ll look at enumerations, also referred to as enums. Enums allow you to define a type by enumerating its possible variants 가능한 상태의 목록을 열거하여 타입을 정의한다는 정의가 마음에 든다. 보통 상대적으로 새로운 언어들이 명시적이면서 경제적이면서 예쁜 문법을 제공하는데 러스트의 enum이 특히 그런 느낌이다.\n6.1 Defining an Enum 구조체가 데이터를 그룹화 하는 방법을 제공한다면, enum은 특정한 값이 가질수 있는 모든 가능한 값을 정의한다. 이런 류의 정의가 좋은 것 같다. 처음 Generic을 배울 때 처음에 복잡하고 읽기 어려운 문법과 사용 방법에 포커스를 하고 공부하니 이해가 안됐었는데, 똑같은 로직을 여러번 작성하지 않기 위해 사용하는 문법이라고 c++ primer plus 책에서 설명을 해줘서 해당 관점으로 이해하려 하니 이해가 잘 되었었던 기억이 난다.\n공식 가이드에서는 IP 주소를 다루는 예제를 들고 있다. IP주소라는 개념을 코드로 \u0026lsquo;표현\u0026rsquo;한다면\n4개의 8비트 숫자로 구성된 IPv4 주소를 다루는 경우 8개의 16비트 숫자로 구성된 IPv6 주소를 다루는 경우 이렇게 두가지 상태만 존재하고, 모든 IP의 버전은 두가지 중 하나에 속하게 된다.\nIP 주소이면서 저 두가지의 상태가 아닌 다른 상태에 속할 수 없고, 둘 다에 속할 수 없으며, 이런 경우에 enum을 이용해서 표현할 수 있다.\n버전 4와 버전 6 주소 모두 근본적으로는 IP 주소이므로, 코드가 어떤 종류의 IP 주소에도 적용되는 상황을 처리할 때 동일한 타입으로 취급되어야 한다.\n즉 모든, 고유한, 가능한 상태의 열거이므로 일정 정도의 추상화의 역할을 한다.\nenum IpAddrKind { V4, V6, } let four = IpAddrKind::V4; let six = IpAddrKind::V6; fn route(ip_kind: IpAddrKind) {} route(IpAddrKind::V4); route(IpAddrKind::V6); 문법은 enum 키워드로 시작하고, 각 상태는 중괄호로 묶인 목록으로 정의된다.\n각 상태는 그 자체로 유효한 값이다. 이 값은 enum의 이름을 통해 접근할 수 있다.\nenum의 이름과 상태의 이름은 같은 이름 공간에 있으므로, enum의 이름을 통해 상태를 참조할 수 있다.\nenum에 값을 저장할 수도 있다.\nenum IpAddr { V4(String), V6(String), } let home = IpAddr::V4(String::from(\u0026#34;127.0.0.1\u0026#34;)); let loopback = IpAddr::V6(String::from(\u0026#34;::1\u0026#34;)); 이렇게 하면 각 상태가 다른 타입의 데이터를 가질 수 있다. 단순히 열거형에 String을 매핑하는 정도가 아니라 아래와 같은 것들도 가능하다. enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\u0026#34;::1\u0026#34;)); 이렇게 하면 각 상태가 다른 타입의 데이터를 가질 수 있다. struct Ipv4Addr { // --snip-- } struct Ipv6Addr { // --snip-- } enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), } 이렇게 하면 각 상태가 다른 구조체를 가질 수 있다. enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } 다양한 것들을 매핑하되, 하나의 enumerate variants에 같은 타입이 아닌 것들을 매핑할 수 있다. struct QuitMessage; // unit struct struct MoveMessage { x: i32, y: i32, } struct WriteMessage(String); // tuple struct struct ChangeColorMessage(i32, i32, i32); // tuple struct impl Message { fn call(\u0026amp;self) { // method body would be defined here } } let m = Message::Write(String::from(\u0026#34;hello\u0026#34;)); m.call(); impl로 메소드를 정의할 수 있다. 6.1.1 The Option Enum and Its Advantages Over Null Values Option\u0026lt;T\u0026gt;는 표준 라이브러리에 정의된 enum이다.\nOption\u0026lt;T\u0026gt;는 Some(T)와 None 두가지 상태를 가진다.\nOption\u0026lt;T\u0026gt;는 null 값의 대안으로 사용할 수 있다.\nJava의 Optional과 비슷한 개념이다.\n값이 있는 경우, 그렇지 않은 경우(그 모든 variant) 가 있고, 그 모든케이스를 다뤄야하는데, Option을 사용하면 정확히 모든 케이스를 핸들링 했는지, 컴파일러가 체크해준다.\n우리는 언어를 배울때, 해당 언어가 어떠한 기능을 포함(include)하고 있는지에는 충분히 주목하면서, 어떠한 기능을 배제(exclude)하고 있는지에는 충분히 주목하지 않는다.\n기능의 배제 또한 언어의 특징이라는 점을 서적에서 강조하고 있다.\n결론적으로 Rust는 null을 제공하지 않는다. null이라는 기능을 제공하는 언어의 모든 값은 두가지 variant를 가진다. (null, not null)\nTony Hoare가 null을 발명했는데, 후에 이것이 \u0026lsquo;my billion dollar mistake\u0026rsquo;라고 말했다.\n공식 가이드 문서에서 해당 내용과 관련한 인터뷰 기사를 인용하고 있는데, 이게 대충 60년만의 사과라고 한다. 해당 기사의 배스트 댓글에는, \u0026ldquo;Bjarne Stroustrup의 사과까지는 14년이 더 남았네\u0026rdquo; 라는 댓글이 달려 있어 검색해봤는데, 1979년은 cpp의 탄생년 이었다.\n무튼 실제 구현은 아래와 같다. enum Option\u0026lt;T\u0026gt; { None, Some(T), } prelude에는 Option이 포함되어 있어서(그만큼 유용하고 자주 사용해야 하기에) 따로 include할 필요가 없고, Option을 사용할 때는 Option::을 사용하지 않아도 된다.\nSome\u0026lt;T\u0026gt; 는 제네릭으로 특정 타입을 가질 수 있다.\nlet some_number = Some(5); let some_string = Some(\u0026#34;a string\u0026#34;); let absent_number: Option\u0026lt;i32\u0026gt; = None; some_number의 타입은 Option\u0026lt;i32\u0026gt;이다.\nsome_string의 타입은 Option\u0026lt;\u0026amp;str\u0026gt;이다.\nabsent_number의 타입은 Option\u0026lt;i32\u0026gt;이다.\n무튼 결론적으로 Some value는 값이 있는 경우를 나타내고, None value는 값이 없는 경우를 나타낸다.\nNone variant는 사실상 null과 같은 의미를 지니는데, 굳이 이렇게 하는 이유는 뭘까? (왜 null보다 None을 사용하는가?)\n짧게 요약하면, Option\u0026lt;T\u0026gt;와 T는 다른 타입이기 때문에 컴파일러는 Option\u0026lt;T\u0026gt;를 사용 할 때, 무조건적으로 valid value라고 상정하지 않기 때문이다.\nlet x: i8 = 5; let y: Option\u0026lt;i8\u0026gt; = Some(5); let sum = x + y; 위 코드는 컴파일 되지 않는다. Option\u0026lt;i8\u0026gt;와 i8은 다른 타입이기 때문이다.\n당연하게도 i8과 i8이 아닌 무엇인가의 값을 더하는 방법을 알지 못한다.\n컴파일러가 이해 할 수 있는 코드를 작성하기 위해서는, Option\u0026lt;i8\u0026gt;를 그냥 사용하는것이 아닌 무엇인가의 처리를 해야한다.\n여기서 무엇인가의 처리란 바로 Option의 variants를 다뤄야 하는 것이고, 그러한 과정 이후에 null(None) 에 대한 대응을 진행하게된다.\n6.2 The match Control Flow Construct match는 다른 언어의 switch와 비슷한 역할을 한다.\nPattern은 literal value, variable, wild card, tuple, destructured structure, enum 등을 포함할 수 있다.\nmatch는 컴파일러로 하여금 모든 케이스를 다루는지 확인하게 한다.\n동전 자판기처럼 처음으로 일치하는 패턴을 만나면 해당 블록을 실행하고, 나머지는 무시한다.\nenum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, } } if 문과 다른 점은 굳이 boolean을 사용하지 않아도 된다는 점이다.\nmatch의 arm이란 =\u0026gt;과 ,로 구분된 패턴과 실행 코드 블록이다. 패턴과 코드 블록으로 이루어져 있다.\n각각의 arm에 연관되어있는 코드 블록은 표현식이며, 이 표현식의 결과는 match 표현식의 결과가 된다.\n한 줄을 넘는 코드를 작성할 때는 {}를 사용해야 한다.\n6.2.1 Patterns That Bind to Values match의 또 다른 유용한 기능은 패턴에 매칭되는 값을 바인딩 할 수 있다는 것이고, enumd variants 의 값을 추출할 수 있다. #[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } Quarter variant는 UsState를 가지고 있다. fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter(state) =\u0026gt; { println!(\u0026#34;State quarter from {:?}!\u0026#34;, state); 25 }, } } Coin::Quarter(state)에서 state는 UsState 타입이 된다.\\\n이렇게 하면 UsState를 추출할 수 있다.\n6.2.2 Matching with Option Option\u0026lt;T\u0026gt;를 사용할 때도 match를 사용하는 예제. fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { None =\u0026gt; None, Some(i) =\u0026gt; Some(i + 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None); match rust의 유연한 enum과 함께 사용할 때 매우 강력한 도구가 된다.\nmatch 의 variable binding 기능 덕에 코드가 깔끔하게 떨어지는 경우가 많고, 실제로 코드를 작성하면서도 이점을 느낄 수 있다.\n6.3.3 Mathches Are Exhaustive match는 모든 경우를 다루지 않으면 컴파일 되지 않는다. fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { Some(i) =\u0026gt; Some(i + 1), } } 위 코드는 컴파일 되지 않는다. None에 대한 처리가 없기 때문이다.\n이처럼 러스트의 match는 철저하기 때문에 일어날 수 있는 실수를 방지해준다.\nbillion dollor mistake는 애초에 러스트에서 가능하지 않다고 한 번 더 비꼰다 ㅋㅋ\n6.3.4 Catch-all Patterns and The _ Placeholder enum과 match를 사용할 때, 특정 값에 대해서만 특별한 처리를 하고, 나머지에 대해서는 아예 처리를 하지 않을 때가 있다. let dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), other =\u0026gt; move_player(other), } fn add_fancy_hat() {} fn remove_fancy_hat() {} fn move_player(num_spaces: u8) {} 이러한 경우 3,7이 아닌 모든 경우는 other에 매칭되어 처리된다.\n참고로 다른 언어의 switch에서와 같이 other을 위에 쓰면 그 아래 arm들은 비교조차 안하기 때문에 주의가 필요하다.\n비슷하게 catch-all 하면서도, 해당 값에 대해서는 아무것도 하지 않을 때는 _를 사용한다.\nlet dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), _ =\u0026gt; (), // or another actions for now do nothing } fn add_fancy_hat() {} fn remove_fancy_hat() {} 6.4 Concise Control Flow with if let if let을 사용하면, 하나의 값ㅂ에 대해서만 매칭을 하고, 나머지를 무시하는 경우에 match를 사용하는 것보다 간결하게 코드를 작성할 수 있다. let some_u8_value = Some(0u8); match some_u8_value { Some(3) =\u0026gt; println!(\u0026#34;three\u0026#34;), _ =\u0026gt; (), } if let Some(3) = some_u8_value { println!(\u0026#34;three\u0026#34;); } 두 코드 모두 정확히 같은 동작을 한다.\nif let은 보일러 플레이트도, verbose한 코드도, 굳이 필요없는 들여쓰기도 없애주지만, match의 exhaustive checking을 제공하지 않는다.\n결론적으로 syntax sugar이다.\nelse를 사용할 수도 있다.\nlet mut count = 0; if let Coin::Quarter(state) = coin { println!(\u0026#34;State quarter from {:?}!\u0026#34;, state); } else { count += 1; } 6.5 Summary 다양한 match 사용 예제\n// 1. 트래픽 라이트 시뮬레이터 enum TrafficLight { Red, Yellow, Green, } fn simulate_traffic_light(light: TrafficLight) { match light { TrafficLight::Red =\u0026gt; println!(\u0026#34;Stop\u0026#34;), TrafficLight::Yellow =\u0026gt; println!(\u0026#34;Caution\u0026#34;), TrafficLight::Green =\u0026gt; println!(\u0026#34;Go\u0026#34;), } } // 2. 파일 읽기 함수 use std::fs; fn read_file(file_path: \u0026amp;str) -\u0026gt; Result\u0026lt;String, String\u0026gt; { match fs::read_to_string(file_path) { Ok(contents) =\u0026gt; Ok(contents), Err(_) =\u0026gt; Err(String::from(\u0026#34;Failed to read the file.\u0026#34;)), } } // 3. 동물의 소리 출력 enum Animal { Dog, Cat, Bird, } fn make_sound(animal: Animal) { match animal { Animal::Dog =\u0026gt; println!(\u0026#34;Woof!\u0026#34;), Animal::Cat =\u0026gt; println!(\u0026#34;Meow!\u0026#34;), Animal::Bird =\u0026gt; println!(\u0026#34;Tweet!\u0026#34;), } } // 4. 모양의 면적 계산 enum Shape { Circle(f64), Triangle(f64, f64), Rectangle(f64, f64), } fn calculate_area(shape: Shape) -\u0026gt; f64 { match shape { Shape::Circle(radius) =\u0026gt; std::f64::consts::PI * radius * radius, Shape::Triangle(base, height) =\u0026gt; 0.5 * base * height, Shape::Rectangle(width, height) =\u0026gt; width * height, } } // 5. 주소 정보 출력 enum Address { City(String), State(String), Country(String), } struct Location { city: String, state: String, country: String, } fn print_city_address(address: Address) { match address { Address::City(city) =\u0026gt; println!(\u0026#34;City: {}\u0026#34;, city), _ =\u0026gt; (), } } // 6. 두 옵션 처리 enum OptionEnum\u0026lt;T\u0026gt; { Some(T), None, } fn process_option(option1: OptionEnum\u0026lt;i32\u0026gt;, option2: OptionEnum\u0026lt;i32\u0026gt;) { match (option1, option2) { (OptionEnum::Some(val1), OptionEnum::Some(val2)) =\u0026gt; println!(\u0026#34;Both options have values: {}, {}\u0026#34;, val1, val2), _ =\u0026gt; println!(\u0026#34;At least one option is None.\u0026#34;), } } // 7. 사칙연산 함수 fn calculate_operation(op: \u0026amp;str, num1: f64, num2: f64) -\u0026gt; Result\u0026lt;f64, String\u0026gt; { match op { \u0026#34;+\u0026#34; =\u0026gt; Ok(num1 + num2), \u0026#34;-\u0026#34; =\u0026gt; Ok(num1 - num2), \u0026#34;*\u0026#34; =\u0026gt; Ok(num1 * num2), \u0026#34;/\u0026#34; =\u0026gt; { if num2 == 0.0 { Err(String::from(\u0026#34;Division by zero is not allowed.\u0026#34;)) } else { Ok(num1 / num2) } }, _ =\u0026gt; Err(String::from(\u0026#34;Invalid operation.\u0026#34;)), } } // 8. 계절 출력 enum Season { Spring, Summer, Autumn, Winter, } fn print_season_message(season: Season) { match season { Season::Spring =\u0026gt; println!(\u0026#34;It\u0026#39;s spring!\u0026#34;), Season::Summer =\u0026gt; println!(\u0026#34;It\u0026#39;s summer!\u0026#34;), Season::Autumn =\u0026gt; println!(\u0026#34;It\u0026#39;s autumn!\u0026#34;), Season::Winter =\u0026gt; println!(\u0026#34;It\u0026#39;s winter!\u0026#34;), } } // 9. 로그인 함수 fn login(username: \u0026amp;str, password: \u0026amp;str) -\u0026gt; Result\u0026lt;(), String\u0026gt; { if password == \u0026#34;correctpassword\u0026#34; { Ok(()) } else { Err(String::from(\u0026#34;Incorrect password.\u0026#34;)) } } // 10. 주문 상태 출력 enum OrderStatus { Pending, Completed, } fn print_order_status(status: OrderStatus) { match status { OrderStatus::Pending =\u0026gt; println!(\u0026#34;Your order is pending.\u0026#34;), OrderStatus::Completed =\u0026gt; println!(\u0026#34;Your order is completed.\u0026#34;), } } ","permalink":"http://localhost:1313/_wiki/enums-and-pattern-matching/","summary":"6 Enum and Pattern Matching In this chapter, we’ll look at enumerations, also referred to as enums. Enums allow you to define a type by enumerating its possible variants 가능한 상태의 목록을 열거하여 타입을 정의한다는 정의가 마음에 든다. 보통 상대적으로 새로운 언어들이 명시적이면서 경제적이면서 예쁜 문법을 제공하는데 러스트의 enum이 특히 그런 느낌이다.\n6.1 Defining an Enum 구조체가 데이터를 그룹화 하는 방법을 제공한다면, enum은 특정한 값이 가질수 있는 모든 가능한 값을 정의한다.","title":"Enums and Pattern Matching in Rust"},{"content":"5.0 Defining and Instantiating Structs struct User { username: String, email: String, sign_in_count: u64, active: bool, } 기본적으로 튜플과 비슷하게 데이터를 묶어주는 역할을 한다. 튜플보다 더 많은 유연성을 제공한다. cpp의 구조체와 거의 동일하다. ts의 인터페이스와 유사하다. struct 키워드를 사용하여 정의한다. fn main() { let user1 = User { email: String::from(\u0026#34;some@example.com\u0026#34;), username: String::from(\u0026#34;someusername\u0026#34;), active: true, sign_in_count: 1, } .을 사용하여 필드에 접근할 수 있다. 만약 instance가 mutable하다면 필드의 값을 변경할 수 있다. 필드의 일부는 mutable이고 일부는 immutable일 수 없다. fn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } fn build_user2(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 표현식 형태로 함수의 반환값으로 사용할 수 있다. 필드의 이름과 변수의 이름이 같다면 email: email을 email로 축약할 수 있다. 5.1.1 Creating Instances From Other Instances With Struct Update Syntax fn main() { // --snip-- let user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), active: user1.active, sign_in_count: user1.sign_in_count, username: user1.username, }; let user3 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), ..user1 }; } ..을 사용하여 다른 인스턴스를 복사할 수 있다. 디스럭쳐링과 비슷한 문법이지만, 구조체가 기본적으로 iterable trait를 구현하고 있지는 않는다고 한다. 어떻게 구현되어있는지 궁금하다. (알아보기) 소유권 이전은 동일한 논리로 일어나기 때문에, 만약 stack only data가 아닌 필드를 가지고 있다면, 업데이트 이후 기존 인스턴스를 사용할 수 없게 된다. 5.1.2 Using Tuple Structs without Named Fields to Create Different Types struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); } 필드의 이름이 없는 튜플 구조체를 사용할 수 있다.\n필드의 이름을 붙이지 않는 구조체라고 생각하면 된다.\n한번 타입을 정의하면, 그 필드들이 같아도 다른 타입으로 인식한다.\nblack과 origin은 서로 다른 타입이기에, 함수 파라미터등으로 반대를 넣어주면 컴파일 에러가 발생한다.\n5.1.3 Unit-Like Structs Without Any Fields struct UnitLikeStruct; fn main() { let unit_like_struct = UnitLikeStruct; } 필드가 없는 구조체를 사용할 수 있다. 이런 구조체는 유닛 타입과 비슷하다. 데이터필드가 없는 trait를 구현할 때 유용하게 사용할 수 있다. 타입 파라미터나 테스트용 mock 객체를 만들 때 유용하게 사용할 수 있다. 5.2 An Example Program Using Structs 구조체를 사용하지 않고 작성한 코드를 구조체를 사용하여 리팩토링하는 간단한 예제.\nfn main() { let width1 = 30; let height1 = 50; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, area(width1, height1) ); } 파라미터가 두개이며, 해당 값들이 어떤 값인지에 대한 인지가 필요해서 별로라고 한다. 5.2.1 Refactoring with Tuples fn main() { let rect1 = (30, 50); println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, area(rect1) ); } fn area(dimensions: (u32, u32)) -\u0026gt; u32 { dimensions.0 * dimensions.1 } 조금 더 낫긴 하지만, 의미적으로 dimensions.0과 dimensions.1이 width와 height라는 것을 알 수 없다. 5.2.2 Refactoring with Structs: Adding More Meaning fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, area(\u0026amp;rect1) ); } fn area(rectangle: \u0026amp;Rectangle) -\u0026gt; u32 { rectangle.width * rectangle.height } 구조체를 사용하여 가독성을 높일 수 있다. ownership을 넘기지 않고 참조를 넘기는 것이 좋다. 5.2.3 Adding Useful Functionality with Derived Traits struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(\u0026#34;rect1 is {}\u0026#34;, rect1); } println! 매크로는 Display trait를 구현한 타입만 사용할 수 있다, 관련된 컴파일 에러를 확인 할 수 있다. = help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead 친절한 컴파일러의 조언을 따라 {:?}를 사용해서 출력하는 예제. fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(\u0026#34;rect1 is {:?}\u0026#34;, rect1); } 또 다른 에러가 발생한다. = note: `Rectangle` cannot be formatted using `{:?}` because it doesn\u0026#39;t implement `std::fmt::Debug` Debug trait를 구현해야 한다는 에러이다. #[derive(Debug)]를 사용하여 Debug trait를 구현할 수 있다. 이는 #[derive(Debug)]를 사용하여 컴파일러가 자동으로 구현하도록 할 수 있다. #[derive(Debug)] struct Rectangle { width: u32, height: u32, } 이제 {:?}를 사용하여 출력할 수 있다. {:?}는 Debug trait를 구현한 타입을 출력할 수 있다. fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(\u0026#34;rect1 is {:?}\u0026#34;, rect1); } Debug format을 사용해서 출력하는 다른 방법은 dbg! 매크로를 사용하는 것이다. dbg! 매크로는 println! 매크로와 비슷하지만, dbg! 매크로는 값을 반환하고, ownership을 가져갔다 반환해준다 (println!은 참조만 가져간다.) #[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let scale = 2; let rect1 = Rectangle { width: dbg!(30 * scale), height: 50, }; dbg!(\u0026amp;rect1); } $ cargo run Compiling rectangles v0.1.0 (file:///projects/rectangles) Finished dev [unoptimized + debuginfo] target(s) in 0.61s Running `target/debug/rectangles` [src/main.rs:10] 30 * scale = 60 [src/main.rs:14] \u0026amp;rect1 = Rectangle { width: 60, height: 50, } 5.3 Method Syntax 구조체에 메서드를 추가할 수 있다. 메서드는 함수와 비슷하지만, 구조체의 인스턴스에 대해 호출된다는 점이 다르다. 메서드는 self 파라미터를 가지고 있어야 한다. self 파라미터는 메서드를 호출한 인스턴스를 가리킨다. 5.3.1 Defining Methods #[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, rect1.area() ); } impl 블록을 사용하여 메서드를 정의할 수 있다.\nimpl 블록은 구조체의 이름과 메서드를 구현할 구조체의 이름을 가지고 있다.\nself 파라미터를 사용하여 메서드를 호출한 인스턴스를 가리킬 수 있다.\nself 파라미터는 self: \u0026amp;self의 약어이다.\nSelf 타입은 impl 블록이 적용되는 타입의 별칭이다. (alias)\nrectangle: \u0026amp;Rectangle 에서처럼, 이 메소드가 Self 인스턴스를 빌린다는 것을 나타내기 위해 self 약어 앞에 \u0026amp;를 사용해야 한다.\n메소드는 다른 매개변수처럼 self의 소유권을 가질 수도 있고, 여기처럼 self를 불변으로 빌릴 수도 있으며, 혹은 self를 가변으로 빌릴 수도 있다.\n반대로 \u0026amp;mut self로 선언하면, 해당 인스턴스를 가변으로 빌릴 수 있다.\n특정한 인스턴스를 변화시키고, 기존의 인스턴스를 사용할 수 없게 하고 싶다면, \u0026amp;mut self를 사용하면 된다.\nstruct Circle { radius: f64, } impl Circle { // Circle의 면적을 계산하는 메서드 fn area(\u0026amp;self) -\u0026gt; f64 { 3.14159 * self.radius * self.radius } // Circle의 반지름을 주어진 배율로 조정하는 메서드 fn scale(\u0026amp;mut self, factor: f64) { self.radius *= factor; } } fn main() { let mut circle = Circle { radius: 5.0 }; println!(\u0026#34;원래 면적: {}\u0026#34;, circle.area()); // circle의 반지름을 2배로 조정 circle.scale(2.0); println!(\u0026#34;조정된 면적: {}\u0026#34;, circle.area()); } impl Circle { // Circle을 Square로 변환하는 메서드 fn into_square(self) -\u0026gt; Square { Square { side: self.radius * 2.0 } } } struct Square { side: f64, } fn main() { let circle = Circle { radius: 5.0 }; let square = circle.into_square(); // 여기서 circle의 소유권이 이동됨 // println!(\u0026#34;원의 반지름: {}\u0026#34;, circle.radius); // 오류: `circle`은 더 이상 유효하지 않음 println!(\u0026#34;정사각형의 변 길이: {}\u0026#34;, square.side); } fn main() { let circle = Circle { radius: 5.0 }; // circle.scale(2.0); // 오류: `circle`은 불변 참조이며, `scale`은 가변 참조를 요구함 } 함수 대신 메서드를 사용하는 이유는 단지 구조체에서 타입을 매번 쓰지 않기 위해서가 아니라, 해당 타입에 대한 method를 조직화 하기 때문이다. (organization)\n메서드를 사용하면, 해당 타입에 대한 모든 기능을 한 곳에 모아둘 수 있다.\n필드의 이름과 메서드의 이름이 같게 할 수 있다.\ngetter와 같은것들도 구현하는데, 이건 나중에..\n5.3.2 Where\u0026rsquo;s the -\u0026gt; Operator? (c/cpp 에서) -\u0026gt; 연산자는 포인터의 메서드를 호출할 때 사용한다. 객체에서 직접 호출하는 경우는 . 역참조를 해서 호출할 필요가 있기 때문인데, object 가 포인터라면, object-\u0026gt;method()는 (*object).method()와 비슷하다. 러스트에서는 이러한 과정이 자동화 되어있다 (automatic referencing and dereferencing). object.method() 와 같이 메서드를 호출하면, 러스트는 자동으로 \u0026amp;, \u0026amp;mut, *를 추가하여 호출한다. // same p1.distance(\u0026amp;p2); (\u0026amp;p1).distance(\u0026amp;p2); 짐작할수 있듯이 self라는 명확한 수신자를 사용하기 때문에 가능하다\n리시버가 \u0026amp;self, \u0026amp;mut self, self로 정의되어 있기 때문에, 읽기 수정 소비에 대한 부분을 명확하게 파악 할 수 있다.\n예를 들어, 어떤 객체 obj가 있고 이 객체에 대한 메서드 method()가 정의되어 있을 때,\nRust는 obj.method() 호출을 적절하게 처리한다.\n이 메서드가 \u0026amp;self를 요구한다면, Rust는 자동으로 \u0026amp;obj.method()를 호출한다.\n만약 메서드가 \u0026amp;mut self를 요구한다면, Rust는 \u0026amp;mut obj.method()로 처리한다.\n객체가 값으로 메서드를 호출해야 한다면, Rust는 필요에 따라 (*obj).method()처럼 역참조를 자동으로 처리한다.\n5.3.3 Methods with More Parameters 메서드는 추가적인 파라미터를 가질 수 있다. fn main() { let rect1 = Rectangle { width: 30, height: 50, }; let rect2 = Rectangle { width: 10, height: 40, }; let rect3 = Rectangle { width: 60, height: 45, }; println!(\u0026#34;Can rect1 hold rect2? {}\u0026#34;, rect1.can_hold(\u0026amp;rect2)); println!(\u0026#34;Can rect1 hold rect3? {}\u0026#34;, rect1.can_hold(\u0026amp;rect3)); } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } self reciever 이후는 그냥 일반적인 함수와 동일하다. 5.3.4 Associated Functions self 파라미터를 가지지 않는 함수를 impl 블록 내에 정의할 수 있다.\nself 파라미터가 없기 때문에, 메서드는 아니고 associated function이라고 한다.\nassociated function은 주로 구조체의 인스턴스를 생성하는데 사용된다.\nimpl Rectangle { fn square(size: u32) -\u0026gt; Self { Self { width: size, height: size, } } } 마지막으로 impl블록을 여러개 둘 수 있는데, 큰 의미는 없는 것 같다 ","permalink":"http://localhost:1313/_wiki/using-structs-to-structure-related-data/","summary":"5.0 Defining and Instantiating Structs struct User { username: String, email: String, sign_in_count: u64, active: bool, } 기본적으로 튜플과 비슷하게 데이터를 묶어주는 역할을 한다. 튜플보다 더 많은 유연성을 제공한다. cpp의 구조체와 거의 동일하다. ts의 인터페이스와 유사하다. struct 키워드를 사용하여 정의한다. fn main() { let user1 = User { email: String::from(\u0026#34;some@example.com\u0026#34;), username: String::from(\u0026#34;someusername\u0026#34;), active: true, sign_in_count: 1, } .을 사용하여 필드에 접근할 수 있다. 만약 instance가 mutable하다면 필드의 값을 변경할 수 있다.","title":"Using Structs to Structure Related Data"},{"content":"4.0 Ownership 소유권은 러스트의 가장 특징적인 개념이다, 러스트를 이해하기 위해서, 또는 러스트가 왜 다른 언어들보다 주목받는지 이해하기 위해서 가장 중요한 장이라고 생각한다.\n4.1.1 What is Ownership? Ownership은 러스트가 메모리를 관리하는 규칙이다.\n모든 프로그래밍 언어는 메모리를 관리하는 방법이 있다.\n가장 대표적인 두 갈래는 GC(Garbage Collection)와 수동 메모리 관리로 볼 수있다.\nGC는 프로그램이 실행되는동안, 더 이상 사용하지 않는 메모리를 찾아내고 해체하는 방법이다.\n수동 메모리 관리는 프로그래머가 메모리를 직접 관리하는 방법이다.\n당연히 GC가 편리하고 안전하지만, 성능이 떨어진다는 단점이 있다.\n러스트는 세번째 방법인 Ownership을 사용한다.\n개인적으로 Ownership에서 가장 중요한 포인트는 \u0026lsquo;규칙\u0026rsquo;이라고 생각한다.\n소유권이 적용되는 규칙을 요약하면 다음과 같다.\n각각의 값은 소유자(owner)가 있다.\n한번에 하나의 소유자만 존재할 수 있다.\n소유자가 스코프를 벗어나면, 값은 해제된다.\n사실 완전히 새로운 방식은 아니다. C++의 RAII(Resource Acquisition Is Initialization)와 비슷한 개념이다.\nRAII는 객체가 생성될 때, 자원을 할당하고, 소멸될 때 자원을 해제하는 방식이다.\n객체의 생성과 소멸을 자원의 할당과 해제로 연결짓는다. 참조가 없으면(스코프를 나가면) 자동으로 해제된다는 점에서는 GC와 비슷하다.\nGC를 아주 무식하게 요약하면 참조가 없어진 매모리를 체크하고 회수한다고 할 수 있다. Rust는\u0026rsquo;규칙\u0026rsquo;에 기반한 소유권을 사용하여 메모리를 관리한다, 반대로 생각하면, 메모리를 낭비하거나 위험에 빠뜨리지 않는 \u0026lsquo;규칙을\u0026rsquo; 구현한 것에 더 큰 의의가 있다.\n그에 대한 댓가로 Rust는 컴파일타임에 메모리 안정성을 검증 할 수 있고, GC와 같이 런타임에 추가적인 비용이 발생하지 않는다.\n결론적으로 프로그래머는 Rust의 Ownership이라는 규칙을 따르며 프로그래밍을 하는 것은 어렵지만, 그 댓가로 안전하면서도 빠른 프로그램을 만들 수 있다.\n4.1.2 Stack and Heap Stack과 Heap은 우리의 코드가 런타임에 사용 할 수 있는 메모리이다. 스택은 자료구조 스택의 개념을 따른다. LIFO는 굳이 설명 안해도 괜찮지만, 특정한 메모리 공간에 일렬로 늘어서 있는 선형 자료구조임은 인지해야 한다. 왜냐면 힙은 스택과 다르게 메모리의 어느 곳에든 할당하고, 첫칸의 포인터를 반환받기 때문인다. 보통 스택은 빠르고, 힙은 느리다고 알려져 있다. 그 이유는 스택은 LIFO로 데이터를 저장하고, 힙은 데이터를 저장하고 찾기 위해 추가적인 작업이 필요하기 때문이다. 실제로는 주로 혼용해서 사용하는데, 스택에 힙의 포인터를 저장하고, 실제 참조가 필요할 때 힙을 참조하는 방식으로 사용한다.\n이 레퍼런스가 의미있는 이유를 잘 생각해 봐야 한다.\nRust는 Stack과 Heap을 사용하여 메모리를 관리한다.\n예를들어 함수가 호출 될 때 마다, 함수의 지역변수와 매개변수가 스택에 저장된다(힙 데이터 포함). 그리고 사용이 끝나면 스택에서 제거된다.\n결론적으로 우리가 관리해야하는 데이터는 사실상 힙에 할당된 데이터이다.\nStack은 스코프 또는 사용 시점에 따라 자동으로 관리되지만, 힙은 프로그래머가 직접 관리해야 한다.\n책에서는 Stack과 Heap을 생각하면서 프로그래밍 해야 할 필요는 없지만, Ownership 시스템이 뭘 어떻게 하는지, 그리고 왜 그렇게 하는지 이해하는데 도움이 된다고 한다.\n4.1.3 Ownership Rules 다시 Ownership의 규칙을 살펴보면, 다음과 같다.\n각각의 값은 소유자(owner)가 있다. 한번에 하나의 소유자만 존재할 수 있다. 소유자가 스코프를 벗어나면, 값은 해제된다. 이부분을 이해하기 위해서는 러스트의 변수 바인딩방식, 스코프를 이해해야 한다.\n4.1.4 Variable Scope ** 문자열 리터럴 에서**\nfn main() { // s is not valid here, it\u0026#39;s not yet declared let s = \u0026#34;hello\u0026#34;; // s is valid from this point forward } // this scope is now over, and s is no longer valid 위의 코드에 가장 중요한 포인트 변수 s는 선언된 블록 내에서만 유효하다. 블록이 끝나면 변수 s는 소멸된다. 아직까지 다른 언어와 크게 다르지 않다. 4.1.5 The String Type String 타입에서\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // do stuff with s } // this scope is now over, and s is no longer valid String 타입도 별반 다르지 않은 것 같은데..? 4.1.6 Memory and Allocation 문자 리터럴의 경우, 컴파일 타임에 컨텐츠를 알 수 있기 때문에, 해당 컨텐츠가 하드코딩되어 바이너리에 포함된다. 그래서 빠르고 효율적이지만, 변경이 불가능하다.\n반면 String 타입은 컴파일 타임에 크기를 알 수 없고, 런타임에 크기가 결정되어 할당될 공간을 찾아 힙에 저장되어야 한다.\n이 시점에 가장 중요한 포인트는 다음과 같다.\n런타임에 메모리 할당을 요청해서 할당해야한다.\n그로인해 이 메모리를 해제하고 반환해하는 방법이 필요하다.\n첫 번째는 String::from 함수를 통해 이루어졌다 (쉽다 쉬워).\n그런데 두 번째는 프로그래머들의 아주 오래된 고민중에 하나이다. (GC가 없는 언어에서는)\n메모리를 할당하고 해제하는 것은 프로그래머의 몫이다. 근데 그게 잘 되겠냐고, 사람은 실수를 하기 마련인데\u0026hellip; 일단 해제를 안하면 메모리 누수가 발생해서 프로그램이 느려지고, 더 심하면 프로그램이 죽을 수 있다. 해제를 두번하면, 프로그램이 죽을 수 있다. 해제를 너무 일찍하면, 프로그램이 죽을 수 있다. 결론적으로 메모리 관리는 어렵다. Rust는 Ownership 규칙을 통해 이 문제를 해결한다.\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // do stuff with s } // this scope is now over, and s is no longer valid 위의 코드에서 s는 스코프를 벗어나면 해제된다. (쉽고 편리하고 안전해보이지!, 안전한건 맞는데 쉽고 편할까?)\n무튼 이것이 Ownership의 규칙이다.\n참고로 실제 구현은 drop이라는 함수를 통해 이루어진다.\n스코프의 기준이 되는 닫힌 중괄호가 실행되면, 내부적으로는 drop 함수가 호출되어 메모리가 해제된다.\n4.1.7 Ways Variables and Data Interact : Move let x = 5; let y = x; 여기서는 x의 값을 복사해서 y에 넣고 실제로 x와 y인 5는 스택에 각각 푸시된다. let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; 여기는 다르다! String의 데이터는 세 부분으로 나뉘어져 있다 (포인터, 길이, 용량)\n포인터는 힙에 저장된 데이터를 가리키는 주소 길이는 데이터의 길이 용량은 할당된 메모리의 크기 일단 이 데이터 (참조와 뭐 대충 메타데이터)는 스택에 저장된다.\n출처 : The Rust Programming Language\n그리고 s1을 s2에 할당하면 어떻게 될까?\n결론은 s1의 데이터중 스택에 저장된 데이터는 s2로 복사되고, 힙에 저장된 데이터는 복사되지 않는다.\n그런데 문제는 여기서 발생한다. s1과 s2가 모두 힙의 데이터를 가리키고 있으면, 두 변수가 스코프를 벗어나면 두 변수가 동시에 메모리를 해제하려고 할 것이다.\n메모리를 두번 해제해\u0026hellip;? \u0026ldquo;죽을게\u0026rdquo;\n가 아니고 Rust는 이런 상황을 방지하기 위해 장치를 마련해뒀다.\n내용을 먼저 보면\nlet s2 = s1 코드 이후의 시점에, s1을 더이상 유효하지 않다고 간주한다.\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0382]: borrow of moved value: `s1` --\u0026gt; src/main.rs:5:28 | 2 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 3 | let s2 = s1; | -- value moved here 4 | 5 | println!(\u0026#34;{}, world!\u0026#34;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 3 | let s2 = s1.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `ownership` due to previous error 실제로 이런 에러가 발생한다.\n얕은 복사 나도 알아 라고 입이 근질근질하셨던분들은 고려해야 할 게 하나 더 늘은 샘이다.\nRust는 얕은 복사를 하지 않고, move라는 개념을 사용한다.\n출처 : The Rust Programming Language\n결론적으로 스코프를 나갈때마다 메모리를 해제하면 되는데 왜 그렇게 안했지? 와 같은 생각에는 다음과 같은 이유가 있었고(중복 해제) 러스트는 이러한 부분들에 대한 규칙을 지정하며 해결하고 있는 것이다.\n참고로 깊은 복사를 하고 싶다면 clone 함수를 사용하면 된다.\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;{}, world!\u0026#34;, s1); 이렇게 하면 s1과 s2는 서로 다른 데이터를 가리키게 된다. 4.1.8 Copy Trait 앞에서 분류한 Stack only 타입들은 굳이 move를 하지 않아도 된다.\n이런 타입들은 Copy 트레이트를 구현하고 있다.\nCopy 트레이트는 다음과 같은 특징을 가진다.\n스택에 저장되는 타입들은 Copy 트레이트를 구현하고 있다.\nCopy 트레이트를 구현하고 있는 타입들은 move 대신 복사가 이루어진다.\nCopy 트레이트를 구현하고 있는 타입들은 스코프를 벗어나도 메모리가 해제되지 않는다.\nCopy 트레이트를 구현하고 있는 타입들은 다음과 같다.\n- i32 - bool - f64 - char - Tuple (단, 모든 요소가 Copy 트레이트를 구현하고 있어야 한다.) 이외에는 drop trait를 구현하고 있어 Copy 트레이트를 구현할 수 없다.\n4.1.9 Ownership and Functions 함수의 인자로 값을 넘기는 것은 변수를 할당하는 것과 의미론적으로 비슷하다.\n함수의 인자로 값을 넘기면, 해당 값은 함수의 스코프로 이동한다.\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s comes into scope takes_ownership(s); // s\u0026#39;s value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it\u0026#39;s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s\u0026#39;s value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026#34;{}\u0026#34;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026#34;{}\u0026#34;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. 함수의 반환값 역시 마찬가지로 move가 이루어진다. fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026#34;yours\u0026#34;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 납득이 안가는 예제는 없는 것 같다.\n다만 모든 함수가 소유권을 가져갔다가 반환하는것은 지루하기 때문에 러스트는 참조를 사용한다.\n4.2 References and Borrowing fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { // s is a reference to a String s.len() } 러스트에서 참조는 변수를 빌려오는 것이다. 참고로 reference의 반대는 dereference이며 * 연산자를 사용한다.\n참조를 사용하면 소유권을 넘기지 않으므로, drop 함수가 호출되지 않는다.\n참조는 기본적으로 immutable하다.\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 위의 코드는 에러가 발생한다. $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `\u0026amp;` reference --\u0026gt; src/main.rs:8:5 | 7 | fn change(some_string: \u0026amp;String) { | ------- help: consider changing this to be a mutable reference: `\u0026amp;mut String` 8 | some_string.push_str(\u0026#34;, world\u0026#34;); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `\u0026amp;` reference, so the data it refers to cannot be borrowed as mutable For more information about this error, try `rustc --explain E0596`. error: could not compile `ownership` due to previous error 참조를 mutable로 사용하려면 \u0026amp;mut을 사용해야 한다. fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 참조를 사용하면 소유권을 넘기지 않으므로, 여러 참조를 사용할 수 있다. fn main() { let mut s = String:: from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); } $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:17 | 4 | let r1 = \u0026amp;mut s; 5 | let r2 = \u0026amp;mut s; | ^^^^ mutable borrow starts here in previous iteration of loop 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- borrow later used here | = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info) error: aborting due to previous error For more information about this error, try `rustc --explain E0499`. error: could not compile `ownership` due to previous error 실제 코드를 작성하는데 가장 힘들게 느껴지는 제약사항 중 하나이다.\n러스트는 이러한 제약사항을 통해 메모리 안정성을 보장한다.\n정확히는 러스트는 데이터 레이스를 방지하기 위해 이러한 제약사항을 두고 있다.\n데이터 레이스는 두개 이상의 스레드가 동시에 같은 데이터에 접근할 때 발생하는 문제이다.\n동시에 같은 데이터에 접근하면서, 적어도 하나의 접근이 쓰기일 때, 동시성 로직이 없는 경우에 발생한다. 러스트는 이러한 문제를 방지하기 위해 컴파일 타임에 이러한 문제를 방지한다.\nfn main() { let mut s = String::(\u0026#34;hello\u0026#34;); { let r1 = \u0026amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = \u0026amp;mut s; 다수의 참조가 필요 할 때, 위와 같이 블록을 사용하여 스코프를 나누어 사용하면 된다.\n참조의 범위를 제한함으로써, 데이터 레이스를 방지할 수 있다.\n또 하나의 제약사항은 불변 참조와 가변 참조를 동시에 사용할 수 없다는 것이다.\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; let r2 = \u0026amp;s; let r3 = \u0026amp;mut s; // error } 불변 참조값이 있는 동안에는 가변 참조로 인해서 데이터가 변경되는것을 원하지 않기 때문에 막아둔 것이다.\n추가적으로 러스트는 컴파일 시점에 불변 참조의 마지막 사용 위치 이후에는 가변 참조를 사용할 수 있도록 해준다.\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; let r2 = \u0026amp;s; println!(\u0026#34;{} and {}\u0026#34;, r1, r2); // r1 and r2 are no longer used after this point let r3 = \u0026amp;mut s; } 4.2.1 Dangling References Dangling References는 참조가 가리키는 메모리가 해제된 경우를 말한다.\n메모리 해제 후에도 참조가 존재하는 경우, 범위 밖 참조가 일어나는 경우, 복사된 포인터가 일으키는 경우 등이 있다. 러스트는 참조가 유효한 동안에는 반드시 데이터가 스코프 내에 있도록 보장한다.\n즉, 데이터가 참조보다 먼저 스코프 밖으로 벗어나서는 안 되며, 이를 통해 댕글링 참조가 생성되는 것을 컴파일 시점에 방지한다.\n예를들어 함수가 로컬 변수의 참조를 반환하는 경우, 러스트는 컴파일 에러를 발생시킨다.\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } 4.3 The Slice Type 슬라이드는 참조의 일종으로, 오너쉽을 가지지 않는다.\n예시 : 문자열에서 첫 단어를 찾는 함수 만들어보기 (공백을 기준으로)\nfn first_word(s: \u0026amp;String) -\u0026gt; ? 이 함수는 문자열의 참조를 받는데, 무엇을 반환해야 할까? fn first_word(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return i; } } s.len() } let bytes = s.as_bytes(); // as_bytes() 메소드는 문자열을 바이트 배열로 변환한다. for (i, \u0026amp;item) in bytes.iter().enumerate() // iter() 메소드는 컬렉션을 반복하는 반복자를 생성한다, enumerate() 메소드는 반복자를 튜플로 변환한다. 문자열의 인덱스를 반환하는 방식으로 구현했다, fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // word will get the value 5 s.clear(); // this empties the String, making it equal to \u0026#34;\u0026#34; // word still has the value 5 here, but there\u0026#39;s no more string that // we could meaningfully use the value 5 with. word is now totally invalid! } 4.3.1 String Slices\n슬라이스는 문자열의 일부분을 참조하는 방법이고 이렇게 생겼다. let s = String::from(\u0026#34;hello world\u0026#34;); let hello = \u0026amp;s[0..5]; let world = \u0026amp;s[6..11]; Rather than a reference to the entire String, hello is a reference to a portion of the String, specified in the extra [0..5] bit. We create slices using a range within brackets by specifying [starting_index..ending_index], where starting_index is the first position in the slice and ending_index is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to ending_index minus starting_index. So, in the case of let world = \u0026amp;s[6..11];, world would be a slice that contains a pointer to the byte at index 6 of s with a length value of 5.\nlet s = String::from(\u0026#34;hello\u0026#34;); let slice = \u0026amp;s[0..2]; let slice = \u0026amp;s[..2]; let len = s.len(); let slice = \u0026amp;s[3..len]; let slice = \u0026amp;s[3..]; let slice = \u0026amp;s[0..len]; let slice = \u0026amp;s[..]; fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 똑같이 개념적으로는 인덱스를 통해 문자열을 찾는 방식이지만, 참조를 엮어두면 훨씬 더 안전하게 사용 할 수 있다.\n스트링이 유효한 동안에 슬라이스도 유효하다.\nfn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); s.clear(); // error! println!(\u0026#34;the first word is: {}\u0026#34;, word); } $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --\u0026gt; src/main.rs:18:5 | 16 | let word = first_word(\u0026amp;s); | -- immutable borrow occurs here 17 | 18 | s.clear(); // error! | ^^^^^^^^^ mutable borrow occurs here 19 | 20 | println!(\u0026#34;the first word is: {}\u0026#34;, word); | ---- immutable borrow later used here For more information about this error, try `rustc --explain E0502`. error: could not compile `ownership` due to previous error String의 내용을 지우기 위해서는 해당 String에 대한 가변 참조가 필요한데, 만약 이미 불변 참조가 존재한다면\nclear 메소드를 호출하여 String의 내용을 변경하려고 할 때 컴파일 오류가 발생한다.\n이는 println! 매크로가 word에서 불변 참조를 사용하려고 하기 때문에 발생한다.\n따라서, clear 함수가 가변 참조를 요구하는 동안 word의 불변 참조가 여전히 활성화되어 있어야 한다.\n러스트는 가변 참조와 불변 참조가 동시에 존재하는 것을 허용하지 않기 때문에 컴파일이 실패한다.\n결론적으로 String Literal은 바이너리를 참조하는 것이다.\n위 코드에서 s의 타입은 \u0026amp;str입니다. 이는 특정 이진 파일 내의 위치를 가리키는 슬라이스로, 문자열 리터럴이 어떻게 처리되는지를 명확히 이해할 수 있게 해줍니다. 문자열 리터럴이 불변인 이유도 여기에 있습니다 \u0026amp;str은 불변 참조이기 때문입니다.따라서, 문자열 리터럴은 프로그램의 이진 파일 내에 직접 저장되며, 이를 통해 생성된 \u0026amp;str 타입의 변수는 이진 파일 내 해당 문자열의 위치를 가리키는 불변의 슬라이스가 됩니다. 이러한 특성은 문자열 리터럴이 왜 변경할 수 없는지(immutable)를 설명해 줍니다.\nlet s = \u0026#34;Hello, world!\u0026#34;; 참고로 경험 많은 개발자들은 다음과 같이 시그니처를 유연하게 만들어서 사용한다고 한다. fn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str 위처럼 s 매개변수의 타입으로 문자열 슬라이스를 사용하게 만든다.\n이를 통해 문자열 슬라이스를 직접 전달할 수 있고, String이 있을 경우 String의 슬라이스나 String에 대한 참조를 전달할 수 있게 된다.\n이러한 유연성은 역참조 강제 변환(deref coercions)이라는 기능을 활용하는 것으로 나중에\u0026hellip;\nfn main() { let my_string = String::from(\u0026#34;hello world\u0026#34;); // `first_word` works on slices of `String`s, whether partial or whole let word = first_word(\u0026amp;my_string[0..6]); let word = first_word(\u0026amp;my_string[..]); // `first_word` also works on references to `String`s, which are equivalent // to whole slices of `String`s let word = first_word(\u0026amp;my_string); let my_string_literal = \u0026#34;hello world\u0026#34;; // `first_word` works on slices of string literals, whether partial or whole let word = first_word(\u0026amp;my_string_literal[0..6]); let word = first_word(\u0026amp;my_string_literal[..]); // Because string literals *are* string slices already, // this works too, without the slice syntax! let word = first_word(my_string_literal); } ","permalink":"http://localhost:1313/_wiki/understanding-ownership/","summary":"4.0 Ownership 소유권은 러스트의 가장 특징적인 개념이다, 러스트를 이해하기 위해서, 또는 러스트가 왜 다른 언어들보다 주목받는지 이해하기 위해서 가장 중요한 장이라고 생각한다.\n4.1.1 What is Ownership? Ownership은 러스트가 메모리를 관리하는 규칙이다.\n모든 프로그래밍 언어는 메모리를 관리하는 방법이 있다.\n가장 대표적인 두 갈래는 GC(Garbage Collection)와 수동 메모리 관리로 볼 수있다.\nGC는 프로그램이 실행되는동안, 더 이상 사용하지 않는 메모리를 찾아내고 해체하는 방법이다.\n수동 메모리 관리는 프로그래머가 메모리를 직접 관리하는 방법이다.\n당연히 GC가 편리하고 안전하지만, 성능이 떨어진다는 단점이 있다.","title":"Understanding the Ownership of the Rust Programming Language"},{"content":" 01. 왜 마이그레이션을 하게 되었을까? 사실 마이그레이션을 하려고 하지는 않았고, 기존 Neovim 설정에서 마음에 안드는 부분들이 조금 있어서 그부분만 수정하려고 했다. 그러다 지난번 설정을 따라했었던 유튜버가 2024년 설정이라는 영상으로 기존 Neovim 설정 가이드 영상을 리뉴얼했다. packer나 lsp-saga와 같이 기존에 불편하던 부분들을 귀신같이 뺀 영상임을 확인하고 바로 마이그레이션을 하게 되었다.\n마이그레이션이라고 하기는 사실 애매하고 완전 새롭게 설정을 하고, 기존 설정을 새로운 설정에 덧붙였다고 보는게 맞을 것 같다. 해당 설정을 다시 하면서 추가된 내용에 대한 약간의 내용정리와, 간단한 설명을 덧붙여 포스팅을 해보려고 한다. 02. 기존에 불편했던 것들 packer, lsp-saga packer는 아주 약간 아쉬운점이 있었다.\n콘솔이 훨씬 덜 직관적이다. 상대적으로 무거운 플러그인들도 사실상 무조건 로드되어야 한다.(Lazy Loading이 안되는 것으로 알고 있다) 플러그인을 추가하거나 삭제할때마다 :PackerSync를 해줘야 하는데, Lazy처럼 접근성 좋은 대시보드를 제공하지는 않아서 불편했다. 사실 Mason과 비슷하게 믓찌게 생긴 Lazy.vim 대시보드를 사용하고 싶었다. lsp-saga는 아주 약간 많이 아쉬운점이 있었다.\n업데이트나 플러그인을 추가 할 때 마다 에러가 발생했다. Neovim이 버전업되면, 혹은 아주 오래 쉬다가 새로운 lsp-saga release가 나오면, 에러에 시달려서 내려놨던 경우가 많았다. 현실적으로 lsp와 그 친구들이 neovim으로 넘어와서 애매한 프로젝트가 되어있는게 보였다. 03. Josean의 2024 Neovim 설정 기본적으로 위의 블로그와 유튜브 영상을 참고하면 누구나 쉽게 설정을 할 수 있다. 유튜브와 포스팅의 코드들을 보면서 설정을 하면 거의 영상의 러닝타임 내로 설정을 마칠 수 있다.\n다만 포스팅만 보거나 해당 소스코드를 그냥 pull 받는 것 보다는 영상을 시청하면서 따라하는것을 추천한다.\n플러그인을 설정하는 것에 더해서, 플러그인들의 기본적인 사용법과 꿀팁들을 설명하고 보여주기 때문이다.\n개인적으로는 lazyvim이나 lunarvim같은 distro를 사용하는 것 보다 위의 영상을 보고 직접 설정하는게 훨씬 재미있으면서도, 실제 사용법을 알 수 있어 좋다고 생각한다.\n무엇보다 매우 재미있다.\n04. 위 영상을 보기 전에 알면 좋은 내용들. lua 언어에 대한 기본적인 지식이 필요하다. lua는 neovim의 설정파일을 작성할 때 사용되는 스크립트 언어이다. lua의 기본적인 문법과, neovim에서 사용되는 lua의 특수한 문법들을 알면 좋다.(간단한 스크립트 언어로 lua cheet sheet 정도만 찾아봐도 위의 영상을 따라하는데는 충분하다.) neovim의 기본적인 설정파일에 대한 이해가 필요하다. 먼저 init.lua는 모든 설정파일의 시작점이자 끝점이다.\n기본적으로 init.lua에 모든 설정을 작성해도 되지만 lua의 특성상 모듈화를 해서 init.lua에 init하는 방식으로 설정한다.\n-- 실제 내 설정파일의 init.lua 의 예시 require(\u0026#34;smallzooDev.core\u0026#34;) require(\u0026#34;smallzooDev.lazy\u0026#34;) 위와 같이 require를 사용해서 모듈화를 하고, init.lua에서 require를 통해 모듈을 불러온다.\n실제 프로젝트의 구조는 아래와 같다. packer, lazy.vim들과 같은 플러그인들로, 외부 레포에서 플러그인들을 가져오고, 모듈화를 해서 init.lua에서 불러오는 방식이다.\n즉 나의 프로젝트를 기준으로 설명하면, smallzooDev.core(모듈화 한 코어설정)와 smallzooDev.lazy(외부 플러그인 모듈화 해둔 설정)을 불러오는 방식이다.\nlazy.vim은 플러그인 매니저이고, 외부 저장소에서 플러그인을 가져오고 관리해준다. 위와 같이 플러그인들을 불러오고 관리해주는 플러그인 매니저이다.\nvim이라고는 믿기지않은 멋진 대시보드를 제공해준다.\n실제 플러그인 설정은 아래와 같은 방식으로 작성된다. \u0026ldquo;gooloard/alpha-vim\u0026quot;과 같이 레포명을 적고 그와 관련된 설정을 작성한다. 플러그인에 대한 참조를 변수에 저장해서 위와 같이 프로퍼티등을 수정할수 있고 해당 스크립트에는 vim의 전역변수를 사용할 수 있어서, g:alpha_scroll과 같이 전역변수를 사용해서 설정을 할 수 있다. 05. 내가 추가한 플러그인, 설정들 Vimwiki Vimwiki는 마크다운 문법을 사용해서 간단한 노트를 작성할 수 있는 플러그인이며 이 블로그도 Vimwiki로 작성하고 있다. 아래는 간단한 설정 참고 copilot 설명은 딱히.. color-schemes, key-mappings등 개인화된 설정들 이정도만 해도 나는 충분했던 것 같다 (설정 유튜브에 충분히 많은 플러그인들을 init한다)\n06. 마무리 마이그레이션을 하면서, 기존 설정에서 불편했던 부분들을 해결하고, 새로운 플러그인들을 추가하면서 더욱 편리하게 사용할 수 있게 되었다. 결론적으로 파일탐색, 플러그인관리, 언어서버, 린팅, 포맷팅, 자동완성, 인덴트, 검색 등 ide의 기능에 하나도 빠지지 않는 neovim을 만들게 되었다. 마지막으로 나처럼 초보자일수록 꼭 distro를 사용하지 않고, 직접 설정을 해보는 것을 추천한다. 그것이 더욱 더 재미있고, 실제 사용법을 알 수 있기 때문이다. ","permalink":"http://localhost:1313/_wiki/neovim-migration-%ED%95%98%EA%B8%B0/","summary":"01. 왜 마이그레이션을 하게 되었을까? 사실 마이그레이션을 하려고 하지는 않았고, 기존 Neovim 설정에서 마음에 안드는 부분들이 조금 있어서 그부분만 수정하려고 했다. 그러다 지난번 설정을 따라했었던 유튜버가 2024년 설정이라는 영상으로 기존 Neovim 설정 가이드 영상을 리뉴얼했다. packer나 lsp-saga와 같이 기존에 불편하던 부분들을 귀신같이 뺀 영상임을 확인하고 바로 마이그레이션을 하게 되었다.\n마이그레이션이라고 하기는 사실 애매하고 완전 새롭게 설정을 하고, 기존 설정을 새로운 설정에 덧붙였다고 보는게 맞을 것 같다. 해당 설정을 다시 하면서 추가된 내용에 대한 약간의 내용정리와, 간단한 설명을 덧붙여 포스팅을 해보려고 한다.","title":"Neovim 마이그레이션(?) 하기"},{"content":"Hello, World! this is my new vimwiki page\n","permalink":"http://localhost:1313/_wiki/new-vimwiki-test/","summary":"Hello, World! this is my new vimwiki page","title":""},{"content":" 기본적으로 이직이다\n4월 중순 내일배움캠프 튜터링이 시작되어 그 전까지 좀 공부를 당겨놓고 싶다.\n지금은 굵직하게 4가지 목표를 잡고 있다.\nDB 공부 - Real MySql 8.0 두 권 다 읽기 Network 공부 - 정말 필요한 만큼만, 항상 네트워크는 지루해\u0026hellip; 운영체제등의 공부 - 원래는 운영체제 아주 쉬운 세가지 이야기를 읽으려고 했는데, 그래도 약간의 보상이 필요 할 것 같아서, 상대적으로 재미있는 러스트를 공부하면서 마주하는 개념들을 조금 더 자세하게 정리하는 것으로 하려고 한다. 코테 공부 - 아무래도 만 3년차이다보니 코테를 요구하는 회사들이 더 많아서 눈여겨본 유데미 강의를 볼까 한다. 이중에서 4월 내로 러스트 기본 문법 빠르게 훑고, 러스트인액션과같이 구현에 들어가는것, 그리고 Mysql 8.0 2권 (2권부터 읽으려 한다) 읽기를 목표로 잡았다.\n월간 회고를 결국 쓸거니까 이번달에는 꼭 범위를 타이트하게 지켜봐야지\n아 그리고 이번달 쓰고 싶은 포스팅 주제는 비동기 프로그래밍이다, Nest.js, Webflux, Armereia 같이 요즘은 비동기 프로그래밍과 같은 키워드가 많이 나와 조사해보려고 한다.\n또 두번째 주제는 지금 하고 있는 업무에 대한 회고이다. 이렇게 두개는 꼭 써야지\n0407 ~ 0414\nmysql remind 완료 rust 기본 문법 ~14장까지 완료 0415 ~ 0421\nrust 15장 ~ 20장까지 완료 os lecture part 1 0422 ~ 0428\nrust in action 시작 os lecture part 2 코테 공부 시작 0429 ~ 0505\nos lecture part 3 rust in action 코테 공부 0506 ~ 0512\nos lecture part 4 rust in action 코테 공부 0513 ~ 0519\nrust in action 완료 코테 공부 현실적으로 이 이후부터 mySql 8.0 시작 (이직 일정에 따라 필요하면 중간부터 읽고 크게는 5월까지 끝내는 것으로) ","permalink":"http://localhost:1313/_wiki/2024-04/","summary":"기본적으로 이직이다\n4월 중순 내일배움캠프 튜터링이 시작되어 그 전까지 좀 공부를 당겨놓고 싶다.\n지금은 굵직하게 4가지 목표를 잡고 있다.\nDB 공부 - Real MySql 8.0 두 권 다 읽기 Network 공부 - 정말 필요한 만큼만, 항상 네트워크는 지루해\u0026hellip; 운영체제등의 공부 - 원래는 운영체제 아주 쉬운 세가지 이야기를 읽으려고 했는데, 그래도 약간의 보상이 필요 할 것 같아서, 상대적으로 재미있는 러스트를 공부하면서 마주하는 개념들을 조금 더 자세하게 정리하는 것으로 하려고 한다. 코테 공부 - 아무래도 만 3년차이다보니 코테를 요구하는 회사들이 더 많아서 눈여겨본 유데미 강의를 볼까 한다.","title":"2024년 4월의 목표"},{"content":"3 Common Programming Concepts 이번 장에서는 러스트의 기본적인 프로그래밍 개념들을 다룬다, 가장 특징적인 부분이라면 다른 언어를 대비해서 러스트가 어떤 부분이 다른지 위주로 설명하는 가장 크게 두드러진다는 것이다.\nmz한 언어답게 예약어가 예약되어 있다고 한다 ㅋㅋ(아직 예약어로써 기능하지는 않지만, 미래의 예약어가 될 수 있어 예약해둔 keword)\n3.1 Variables and Mutability 변수는 기본적으로 불변이며, 이렇게 된게 러스트의 nudge라고 한다. src/main.rs\nfn main() { let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); } $ cargo run Compiling variables v0.1.0 (file:///projects/variables) error[E0384]: cannot assign twice to immutable variable `x` --\u0026gt; src/main.rs:4:5 | 2 | let x = 5; | - | | | first assignment to `x` | help: consider making this binding mutable: `mut x` 3 | println!(\u0026#34;The value of x is: {x}\u0026#34;); 4 | x = 6; | ^^^^^ cannot assign twice to immutable variable For more information about this error, try `rustc --explain E0384`. error: could not compile `variables` due to previous error 친절한 컴파일에러.. 무튼 변수를 변경하려면 mut 키워드를 사용해야 한다, 이렇게 하면 일단 변수를 선언하고, 고심한 이후에 mut 키워드를 붙이는 습관이 들 수 있다.\nConstants 상수는 const 키워드를 사용하며, 타입을 명시해야 한다.\n전역을 포함한 어느 스코프에서도 선언이 가능하다.\n런타임에 계산되는 값은 상수로 선언할 수 없고, 오직 상수 표현식(컴파일 타임에 계산되는 값)만 가능하다.\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; Shadowing 변수를 재선언하는 것을 shadowing이라고 한다. fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\u0026#34;The value of x in the inner scope is: {x}\u0026#34;); } println!(\u0026#34;The value of x is: {x}\u0026#34;); } 결과는\nThe value of x in the inner scope is: 12 The value of x is: 6 변수 재 선언과는 다르고, 특히 스코프를 벗어나면 이전 변수가 다시 보이게 된다는게 특징이다.\n그리고 타입을 변경하여도 shadowing이 가능하다.\nlet spaces = \u0026#34; \u0026#34;; let spaces = spaces.len(); 이렇게 하면 spaces는 문자열이었다가 숫자로 바뀌게 된다, space_len 같은 변수를 만들 필요가 없다.\n실제로 저장하고 싶은 데이터는 공백의 갯수이기 때문에 특정한 상황에서 효율적일 수 있다.\n뭔가 스코프에 따라 Shadowing이 영향을 받기도 해서 위험해 보이고, 처음에는 표현식.타입의메셔드() 이런 방법보다 더 나은가 싶긴 했는데, 러스트의 문법적 특징과 잘 어울리게 쓰면 멋진 코드가 나오는 것 같다.\n3.2 Data Types 러스트는 정적 타입 언어이다.\n컴파일 타임에 모든 타입이 알려져야 한다.\nlet guess: u32 = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); 컴파일 시점에 다양한 가능성이 있는 경우라면 타입을 명시해야 컴파일 에러가 나지 않는다.\n그리고 러스트에는 스칼라 타입과 컴파운드 타입이 있다.\nScalar Types 기본적으로 하나로 표현되는 값이다. (다른 언어의원시 타입)\n러스트의 스칼라 타입은 정수형, 부동소수점, 불리언, 문자로 구성된다.\nInteger Types 정수형은 unsigned인지만 구분하고, 크기에 따라 8, 16, 32, 64, 128비트로 나뉜다.\ni8 -\u0026gt; 8비트 signed integer\nu64 -\u0026gt; 64비트 unsigned integer\nisize, usize는 운영체제에 따라 32, 64비트로 결정된다. (64비트 운영체제에서는 64비트) (포인터 사이즈)\n디폴트값은 i32이다.\n추가적으로 정수 오버플로우는 검사하지 않고, 2의 보수 래핑을 한다. 11111 -\u0026gt; 00000\n이를 방지하기 위해서 보통은 충분히 큰 타입을 사용하라고,,,,할수는 없으니 (BigDecimal.java)\nstd의 Wrapping을 사용하면 된다.\nuse std::num::Wrapping; fn main() { let x = Wrapping(0u8); let y = Wrapping(1u8); let z = x - y; println!(\u0026#34;{:?}\u0026#34;, z); } Floating-Point Types 부동소수점은 f32, f64로 나뉜다.\nf64가 디폴트이다.\nIEEE-754 표준을 따른다고 한다\nNumeric Operations 산술연산자는 간단하게..\nfn main() { let sum = 5 + 10; let difference = 95.5 - 4.3; let product = 4 * 30; let quotient = 56.7 / 32.2; let remainder = 43 % 5; } The Boolean Type 생략 The Character Type 러스트의 char는 유니코드 스칼라 값이다. 크기는 4바이트이다. 유니코드 스칼라 값은 0x0000과 0xD7FF, 0xE000과 0x10FFFF 사이의 값을 가진다. 0부터 55295까지의 범위는 기본 다국어 평면, 57344부터 1114111까지의 범위는 보조 다국어 평면이다. fn main() { let heart_eyed_cat = \u0026#39;😻\u0026#39;; // 가능! } Compound Types 여러 값을 하나로 묶어서 저장하는 타입이다. 튜플과 배열이 있다. 튜플은 고정된 길이를 가지고 각 요소의 타입은 달라도 된다. 러스트는 배열의 길이를 컴파일 시점에 알아야 한다. fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; // 디스트럭처링 가능 println!(\u0026#34;The value of y is: {y}\u0026#34;); } fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; // 인덱스로 접근가능 let six_point_four = x.1; let one = x.2; } Array\nfn main() { let a = [1, 2, 3, 4, 5]; } 배열은 고정된 길이를 가지고, 모든 요소의 타입은 같아야 한다. 배열의 길이는 타입의 일부이다. 배열의 요소에 접근할 때는 인덱스를 사용한다. 배열은 데이터를 힙(heap) 대신 스택(stack)에 할당하려는 경우에 유용하다. 스택에 할당하면 데이터를 빠르게 할당하고 접근할 수 있지만, 데이터가 컴파일 시점에 정해진 크기만큼만 스택에 할당될 수 있기 때문에 유연하지 않다. 힙에 할당하면 컴파일 시점에 크기가 정해지지 않아서 런타임에 크기를 늘릴 수 있지만, 느리다.\n보통 공식 가이드에서는 명확한 이유가 없다면 벡터를 사용하라고 권한다. 벡터는 힙에 할당되고, 컴파일 시점에 크기가 정해지지 않아서 런타임에 크기를 늘릴 수 있다.\n나중에 훨씬 더 자세하게 거론된다 fn main() { let a = [1, 2, 3, 4, 5]; let a = [3; 5]; // [3, 3, 3, 3, 3] let first = a[0]; let second = a[1]; } 저수준의 언어임에도 OOI 에러를 패닉으로 잡아내준다. 3.3 Functions fn main() { println!(\u0026#34;Hello, world!\u0026#34;); another_function(); } fn another_function() { println!(\u0026#34;Another function.\u0026#34;); } ```rust fn main() { another_function(5, 6); } fn another_function(x: i32, y: i32) { println!(\u0026#34;The value of x is: {x}\u0026#34;); println!(\u0026#34;The value of y is: {y}\u0026#34;); } 함수 선언의 위치는 중요하지 않다. 파라미터는 타입을 명시해야 한다. Statements and Expressions Function bodies are made up of a series of statements optionally ending in an expression. So far, the functions we’ve covered haven’t included an ending expression, but you have seen an expression as part of a statement. Because Rust is an expression-based language, this is an important distinction to understand. Other languages don’t have the same distinctions, so let’s look at what statements and expressions are and how their differences affect the bodies of functions\n이 장에서 가장 중요한 부분이라고 생각한다.\n먼저 함수를 일련의 \u0026lsquo;문(statement)\u0026lsquo;로 구성되어 있고, 이 문들은 선택적으로 \u0026lsquo;표현식(expression)\u0026lsquo;으로 끝난다 고 정의하고있다.\n또한 러스트는 표현식 기반 언어라고 정의한다.\n문(statement)는 어떤 작업을 수행하고 값을 반환하지 않는다.\n표현식(expression)은 값을 반환한다.\n예를 들어, let x = 5; 는 문이고, 5 + 6;은 표현식이다.\nlet x = 5; 는 변수에 값을 할당하고, 그 자체로 평가될 값이 없다.\n반면 5 + 6;은 두 값을 더한 결과를 반환하고, 반환한 값으로 평가된다.\n참고로 {} 블록은 표현식이며, 블록 내부의 마지막 표현식이 블록 전체의 값이 된다.\n함수를 호출하는 것, 매크로를 호출하는것 것은 표현식이다.\n표현식의 끝에는 세미콜론을 붙이지 않는다.\n결론적으로 return 키워드는 함수를 일찍 종료시킬 때 사용되며, 일반적으로는 문들의 나열 이후에 마지막 표현식으로 값을 반환한다!\n3.4 Comments 생략..?\n3.5 Control Flow 러스트의 if문은 특징적인 내용은 별로 없다.\n조건식은 반드시 bool 타입이어야 한다. (거의 대부분의 강타입 언어가 그렇듯이)\n분기가 많은 경우 match 키워드를 사용하는 것이 좋다.\n러스트의 if는 표현식이기 때문에 다음과 같이 3항 연산자를 대체할 수 있다.\nfn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026#34;condition was true\u0026#34;); } else { println!(\u0026#34;condition was false\u0026#34;); } let condition = true; let number = if condition { 5 } else { 6 }; println!(\u0026#34;The value of number is: {number}\u0026#34;); } 반복문은 loop, while, for가 있다.\nloop는 조건 검사를 전적으로 프로그래머에게 맡기는 반복문이다.\n내가 배운 언어에서는 없었던 것 같다.\n종료 조건을 잘 생각하고 코드를 작성해야 한다.\n종료 keyword인 break 뒤에 값을 반환할 수 있다 (표현식으로 사용 가능)\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;The result is {result}\u0026#34;); } 루프에 레이블을 붙일 수 있다. \u0026#39;outer: loop { println!(\u0026#34;Entered the outer loop\u0026#34;); \u0026#39;inner: loop { println!(\u0026#34;Entered the inner loop\u0026#34;); break \u0026#39;outer; } println!(\u0026#34;This point will never be reached\u0026#34;); } 독특한 기능인 것 같다. 당연히 레이블을 붙이지 않아도 되고, 그런 경우 loop 제어 키워드들은 가장 가까운 루프를 기준으로 동작한다.\n루프 레이블과 루프의 값 반환을 함께 사용하는 예제\nfn main() { let mut counter = 0; let result = \u0026#39;outer: loop { println!(\u0026#34;Entered the outer loop\u0026#34;); \u0026#39;inner: loop { println!(\u0026#34;Entered the inner loop\u0026#34;); counter += 1; if counter == 10 { break \u0026#39;outer counter * 2; } } }; println!(\u0026#34;The result is {result}\u0026#34;); } while은 조건이 참인 동안 반복한다 (특징적이지 않다) fn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{number}\u0026#34;); number -= 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } for는 컬렉션을 순회한다.\n먼저 while 기반의 인덱스 순회 방법을 소개한다.\nfn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index \u0026lt; 5 { println!(\u0026#34;{a[index]}\u0026#34;); index += 1; } } 이런 방법은 러스트의 인덱스 오버플로우를 방지하기 위해 좋지 않으며, 느리다고 언급한다.\n느린 이유는 루프의 매 반복마다 OOI를 체크하기위한 런타임 코드를 추가하기 때문이라고 한다.\n일단 for문은 이렇게 생겼다.\nfn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026#34;{element}\u0026#34;); } } 지정한 횟수만큼의 반복을 원한다면, range()를 사용하면 된다. fn main() { for number in (1..4).rev() { // .rev()는 역순으로 순회한다. println!(\u0026#34;{number}\u0026#34;); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } 러스트의 순회는 어떻게 구현되어있을까? 먼저Java와 같은 언어에서는 Iterable 인터페이스를 구현하고, Iterator를 반환하는 메서드를 구현한다.\n그리고 Iterator는 대충 아래와 같이 생겼다.\npublic interface Iterator\u0026lt;T\u0026gt; { boolean hasNext(); T next(); } 그래서 Iterator를 구현한 클래스는 hasNext()와 next()를 구현해야 한다.\n이러한 경우 인덱스를 카운트 하지 않고 Iterator의 구현체를 순회 할 수 있다.\nIterator의 구현체와 사용 예시 (for 문)\npublic class MyIterator\u0026lt;T\u0026gt; implements Iterator\u0026lt;T\u0026gt;, Iterable\u0026lt;T\u0026gt; { private T[] elements; private int index = 0; public MyIterator(T[] elements) { this.elements = elements; } @Override public boolean hasNext() { return index \u0026lt; elements.length; } @Override public T next() { return elements[index++]; } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return this; } } public class Main { public static void main(String[] args) { Integer[] elements = {1, 2, 3, 4, 5}; MyIterator\u0026lt;Integer\u0026gt; iterator = new MyIterator\u0026lt;\u0026gt;(elements); for (Integer element : iterator) { System.out.println(element); } } } 이런경우 축약된 for문은 Iterator를 구현한 클래스에 대해서만 사용할 수 있다.\n축약된 for문에서는 Iterator의 hasNext()와 next()를 호출하며, hasNext()가 false를 반환할 때까지 next()를 호출한다.\n즉 길이와 인덱스를 몰라도 순회가 가능하다.\nJavascript에서는 이터러블과 이터레이터를 사용한다. (이터러블 프로토콜과 이터레이터 프로토콜)\n이터러블 프로토콜은 Symbol.iterator 메서드를 구현하고, 이터레이터를 반환하는 것이다.\n이터레이터 프로토콜은 next() 메서드를 구현하고, value와 done을 반환하는 것이다.\n마찬가지로 예시는 아래와 같다\n생긴건 자바와 조금 다르지만 원리는 같다 (다음원소가 있는지 확인하고, 다음 원소를 반환한다)\nfunction MyIterator(elements) { this.elements = elements; this.index = 0; } MyIterator.prototype.next = function() { return this.elements[this.index++]; } MyIterator.prototype.hasNext = function() { return this.index \u0026lt; this.elements.length; } MyIterator.prototype[Symbol.iterator] = function() { return this; } const elements = [1, 2, 3, 4, 5]; const iterator = new MyIterator(elements); for (const element of iterator) { console.log(element); } 프로토타입 기반 언어라서 그렇다고 한다. 이 객체가 특정한 추상화의 구현체인지를 따지는것 (자바, c++)과, 이 객체와 다른 언어의 유사점(프로토콜 구현 등)을 기반으로 따지는것 (자바스크립트)의 차이라고 한다.\n무튼 마지막으로 러스트는 트레이트를 사용한다.\n트레이트를 배우고 Iterator를 다뤄야지!\nSummary \u0026amp; Impression 러스트는 표현식 기반 언어이다. ","permalink":"http://localhost:1313/_wiki/common-programming-concepts/","summary":"3 Common Programming Concepts 이번 장에서는 러스트의 기본적인 프로그래밍 개념들을 다룬다, 가장 특징적인 부분이라면 다른 언어를 대비해서 러스트가 어떤 부분이 다른지 위주로 설명하는 가장 크게 두드러진다는 것이다.\nmz한 언어답게 예약어가 예약되어 있다고 한다 ㅋㅋ(아직 예약어로써 기능하지는 않지만, 미래의 예약어가 될 수 있어 예약해둔 keword)\n3.1 Variables and Mutability 변수는 기본적으로 불변이며, 이렇게 된게 러스트의 nudge라고 한다. src/main.rs\nfn main() { let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; println!","title":"러스트 공식 가이드 3장 정리"},{"content":" :profile start profile.log :profile func * :profile file * \u0026#34; At this point do slow actions :profile pause :noautocmd qall! 출처 : stackoverflow\n이렇게 하면 profile.log 파일이 생성된다.\n나의 경우는 copilot 관련 로그가 많아 회사 컴퓨터에서는 브랜치를 새로 파서,\n회사에서는 copilot을 disable 시켜서 해결했다.\n집가서 로그를 자세히 봐야겠다\n","permalink":"http://localhost:1313/_wiki/vim%EC%9D%B4-%EB%8A%90%EB%A6%AC%EB%8B%A4%EB%A9%B4-%ED%95%B4%EB%B3%BC-%EA%B2%83%EB%93%A4/","summary":":profile start profile.log :profile func * :profile file * \u0026#34; At this point do slow actions :profile pause :noautocmd qall! 출처 : stackoverflow\n이렇게 하면 profile.log 파일이 생성된다.\n나의 경우는 copilot 관련 로그가 많아 회사 컴퓨터에서는 브랜치를 새로 파서,\n회사에서는 copilot을 disable 시켜서 해결했다.\n집가서 로그를 자세히 봐야겠다","title":"Vim이 느린 경우 Trouble Shootings"},{"content":"Hello World!\n","permalink":"http://localhost:1313/_wiki/%ED%9A%8C%EC%82%AC%EC%BB%B4-%EC%84%B8%ED%8C%85/","summary":"Hello World!","title":"회사 컴퓨터 세팅 관련"},{"content":"2. Programming a Guessing Game 간단한 숫자 맞추는 게임을 통해 러스트의 기본적인 문법과 기능을 익히는 예제, 처음 문법을 배우는 입장에서 생각보다 다룰 내용이 많았었던 기억이 난다.\nSetting Up a New Project 프로젝트 생성\n$ cargo new guessing_game $ cd guessing_game Processing a Guess src/main.rs\nuse std::io; // io 라이브러리를 가져온다. fn main() { println!(\u0026#34;Guess the number!\u0026#34;); println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); // 빈 문자열을 생성한다. io::stdin().read_line(\u0026amp;mut guess) // 사용자 입력을 받아 guess 변수에 저장한다. .expect(\u0026#34;Failed to read line\u0026#34;); println!(\u0026#34;You guessed: {}\u0026#34;, guess); // 사용자 입력을 출력한다. } Storing Values with Variables let mut guess = String::new(); // 빈 문자열을 생성한다. let : 변수를 생성하는 키워드. mut : mutable한 변수를 생성한다. (변경 가능한 변수, 기본적으로는 immutable) 개인적인 소감이지만 이러한 부분에서 러스트의 언어 디자인이 마음에 들었다, 다른 언어는 기본적으로 가변 변수를 선언하거나 키워드를 다르게 두는데 러스트는 let 키워드로 변수를 선언하고 mut 키워드로 가변 변수를 선언해서 가변 변수를 선언하는 부분을 사용자가 명시적으로 표현하게끔 했다.\n결론적으로 가변으로 선언한 guess라는 변수에, String::new() 표현식의 \u0026lsquo;값\u0026rsquo;을 할당한다. 참고로 러스트의 String은 표준 라이브러리의 String 타입이며, 힙에 할당된 UTF-8 인코딩된 텍스트를 가리키는 포인터이다(growable : 크기가 가변적이다).\n:: : 연산자는 특정 타입의 연관 함수를 호출한다. Receives User Input io::stdin().read_line(\u0026amp;mut guess) // 사용자 입력을 받아 guess 변수에 저장한다. io::stdin() : io 모듈의 stdin 함수를 호출한다. read_line(\u0026amp;mut guess) : Stdin 타입의 read_line 메서드를 호출한다. 이 메서드는 사용자 입력을 받아들이고, 그 값을 문자열에 저장한다(정확히는 추가한다). \u0026amp; : 참조 연산자, 정확히는 이 값이 참조를 가리킨다는 의미이다, 참고로 \u0026amp;은 immutable 하기에 \u0026amp;mut을 사용해서 가변 참조를 만들어야 한다. Handling Potential Failure with the Result .expect(\u0026#34;Failed to read line\u0026#34;); read_line 메서드는 input으로 받은 String에 유저로부터 받은 값을 추가해주고, 그 결과로 Result 타입을 반환한다. Result : 러스트의 표준 라이브러리에 정의된 열거형이다. 이 열거형은 Ok와 Err 두 가지의 variant를 가지고 있다. 이 가이드에서 enum에 대한 좋은 정의를 제공한다. \u0026ldquo;열거형은 여러 가능한 상태 중 하나로 존재할 수 있는 타입을 나타내는데, 이때 각각의 가능한 상태를 variant라고 부릅니다.\u0026rdquo;\nResult의 variant는 다음과 같다.\nOk : 연산이 성공적으로 완료되었음을 나타낸다.\nErr : 연산이 실패했음을 나타낸다.\nResult 타입의 값은 (다른 타입들처럼) method를 가질 수 있다. (뭔가 객체지향 프로그래밍의 인스턴스와 메서드를 연상시킨다. 러스트는 객체지향이 아니지만..)\n무튼 Result 타입의 expect 메서드를 요약하면, Result 값이 Err variant를 가지고 있다면, 프로그램을 강제 종료하고, 인자로 받은 메시지를 출력한다.\n뭔가 파라미터로 받아서 처리해야 하는 것 같은데, 체이닝을 통해 이어지는 것 같다! 이러면 어디에 구현을 해뒀을까 생각해보면 나중에 trait를 배울 때 더 이해가 잘 될 것 같다.\n반대로 Result 값이 Ok variant를 가지고 있다면, expect 메서드는 Ok variant가 가지고 있는 값을 반환한다. Optional\n참고로 Result 타입의 값에 expect 메서드를 호출하지 않으면 컴파일러는 경고를 발생시킨다(컴파일은 된다).\nexpect 메서드는 프로그램을 강제 종료시키기 때문에, 이 메서드를 사용할 때는 주의해야 한다.\nPrinting Values with println! println!(\u0026#34;You guessed: {}\u0026#34;, guess); // 사용자 입력을 출력한다. 난 모든언어에서 포매팅이 항상 지루하더라..\n러스트의 포매팅은 중괄호 {}를 사용한다. 중괄호는 문자열에 포매팅할 값의 위치를 나타낸다. 중괄호 안에는 값을 넣을 수 있다. 여러 개의 중괄호를 사용할 수도 있다.\n예시 :\nlet x = 5; let y = 10; println!(\u0026#34;x = {} and y = {}\u0026#34;, x, y); Generating a Secret Number 러스트에는 랜덤 숫자를 생성하는 기능이 내장되어 있지 않다. 따라서 외부 라이브러리(by Rust team)를 사용해야 한다. rand 라이브러리를 사용한다. Cargo.toml 파일에 의존성을 추가한다. [dependencies] rand = \u0026#34;0.8.4\u0026#34; Generating a Random Number use rand::Rng; use std::io; fn main() { println!(\u0026#34;Guess the number!\u0026#34;); let secret_number = rand::thread_rng().gen_range(1..101); println!(\u0026#34;The secret number is: {}\u0026#34;, secret_number); println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); println!(\u0026#34;You guessed: {}\u0026#34;, guess); } Rng 는 랜덤 숫자를 제공하는 메서드를 정의한 트레이트이다. 이 트레이트는 rand 라이브러리에 정의되어 있다. trait란 뒤에서 아주 자세히 다루겠지만, 간단히 말하면 트레이트는 메서드의 집합을 정의한다. 스레드 로컬한 랜덤 숫자 생성기를 생성하고, 1부터 100까지의 랜덤 숫자를 생성한다.\n정리하자면 rand::thread_rng().gen_range(1..101) 는 rand 라이브러리의 thread_rng 함수를 호출하고, 이 함수는 Rng 트레이트를 구현한 객체를 반환한다. 이 객체는 gen_range 메서드를 호출할 수 있고, 이 메서드는 1부터 100까지의 랜덤 숫자를 반환한다. gen_range 메서드는 range를 인자로 받는다. range는 .. 연산자로 표현되며, 이 연산자는 첫 번째 숫자부터 두 번째 숫자까지의 범위를 나타낸다. 이때 두 번째 숫자는 범위에 포함되지 않는다.\nComparing the Guess to the Secret Number use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026#34;Guess the number!\u0026#34;); let secret_number = rand::thread_rng().gen_range(1..101); println!(\u0026#34;The secret number is: {}\u0026#34;, secret_number); println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); let guess: u32 = guess.trim().parse() .expect(\u0026#34;Please type a number!\u0026#34;); println!(\u0026#34;You guessed: {}\u0026#34;, guess); // cmp 메서드는 Ordering 열거형을 반환한다. match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; println!(\u0026#34;You win!\u0026#34;), } } 위 코드에서는 Ordering 열거형을 스코프에 가져와서 사용한다. 이 열거형은 Less, Greater, Equal 세 가지 variant를 가지고 있다. match 표현식은 guess.cmp(\u0026amp;secret_number)의 결과를 패턴 매칭한다. 이 결과는 Ordering 열거형의 variant 중 하나이다.\n열거형으로 타입의 값을 매칭하는 방식과, 그 타입 내부의 메서드를 호출하는 방식이 러스트의 특징 중 하나라고 생각한다. 이러한 방식은 러스트의 타입 시스템을 이해하는데 도움이 된다. 러스트의 타입 시스템은 다른 언어와는 다르게, 타입의 값과 타입의 메서드를 분리해서 생각하게끔 한다. 표현식과 문의 차이점을 잘 생각하면서 코드를 보면 이해가 조금 더 쉬운 것 같다.\nrust arm 이라는 표현이 나왔는데, arm은 패턴 매칭을 위한 키워드인 것 같다. 이 키워드는 match 표현식에서 사용된다. 참고로 위의 코드는 아래의 컴파일 에러를 발생시킨다.\n$ cargo build Compiling libc v0.2.86 Compiling getrandom v0.2.2 Compiling cfg-if v1.0.0 Compiling ppv-lite86 v0.2.10 Compiling rand_core v0.6.2 Compiling rand_chacha v0.3.0 Compiling rand v0.8.5 Compiling guessing_game v0.1.0 (file:///projects/guessing_game) error[E0308]: mismatched types --\u0026gt; src/main.rs:22:21 | 22 | match guess.cmp(\u0026amp;secret_number) { | --- ^^^^^^^^^^^^^^ expected struct `String`, found integer | | | arguments to this function are incorrect | = note: expected reference `\u0026amp;String` found reference `\u0026amp;{integer}` note: associated function defined here --\u0026gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/cmp.rs:783:8 For more information about this error, try `rustc --explain E0308`. error: could not compile `guessing_game` due to previous error 이 컴파일 에러는 guess 변수의 타입이 String인데, cmp 메서드의 인자로 \u0026amp;secret_number를 넘겨주고 있기 때문에 발생한다. 모두가 알고 있듯이 러스트는 강타입 언어이고 아래와 같이 수정을 해야한다.\nlet guess: u32 = guess.trim().parse() .expect(\u0026#34;Please type a number!\u0026#34;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); let guess: u32 = guess.trim().parse().expect(\u0026#34;Please type a number!\u0026#34;); println!(\u0026#34;You guessed: {guess}\u0026#34;); match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; println!(\u0026#34;You win!\u0026#34;), } guess를 재선언했네\u0026hellip;?\nrust에는 Shadowing이라는 개념이 있다. 이는 같은 이름의 변수를 여러 번 선언할 수 있다는 것이다. 이때, 이전에 선언한 변수는 가려진다.\n나중에 더 보겠지만, 이전에 선언한 변수는 더 이상 사용할 수 없다. 이는 변수의 타입을 변경할 때 유용하다.\n나머지는 이전에 다룬 내용과 동일하다.\nAllowing Multiple Guesses with Looping use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026#34;Guess the number!\u0026#34;); let secret_number = rand::thread_rng().gen_range(1..101); println!(\u0026#34;The secret number is: {}\u0026#34;, secret_number); loop { println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; println!(\u0026#34;You guessed: {}\u0026#34;, guess); match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } } } 크 깔끔..\n개인적으로 변화도 많고 슈가신택스로 떡칠된 부분이 반복문이라고 생각한다. 타입 매칭과 break, continue같은 반복문 키워드만으로 깔끔한 코드를 작성할 수 있다. 왜 굳이 처음부터 이렇게 하지 않았는지 궁금하지만, 게임 종료하기 use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026#34;Guess the number!\u0026#34;); let secret_number = rand::thread_rng().gen_range(1..=100); loop { println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; println!(\u0026#34;You guessed: {guess}\u0026#34;); match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } } } Conclusion \u0026amp; Impression 러스트의 기본 문법과 기능을 익히기에 좋은 예제였다. 러스트의 타입 시스템과 패턴 매칭을 이해하는데 도움이 되었다. 러스트의 표준 라이브러리에 대한 이해를 높일 수 있었다. 러스트의 문법이나 기능을 배울 때, 러스트의 특징을 잘 드러내는 예제라고 생각한다. 뭔가 아쉬운점은 공식 문서의 내용 그대로를 가져온 느낌인데 앞으로는 내생각을 조금 더 작성해야지! ","permalink":"http://localhost:1313/_wiki/programming-a-guessing-game/","summary":"2. Programming a Guessing Game 간단한 숫자 맞추는 게임을 통해 러스트의 기본적인 문법과 기능을 익히는 예제, 처음 문법을 배우는 입장에서 생각보다 다룰 내용이 많았었던 기억이 난다.\nSetting Up a New Project 프로젝트 생성\n$ cargo new guessing_game $ cd guessing_game Processing a Guess src/main.rs\nuse std::io; // io 라이브러리를 가져온다. fn main() { println!(\u0026#34;Guess the number!\u0026#34;); println!(\u0026#34;Please input your guess.\u0026#34;); let mut guess = String::new(); // 빈 문자열을 생성한다. io::stdin().read_line(\u0026amp;mut guess) // 사용자 입력을 받아 guess 변수에 저장한다.","title":"러스트 공식 가이드 2장 정리"},{"content":"1.1. Installation 러스트 설치에 대한 아주 간단한 가이드.\n간단한 내용이라 딱히 정리할 내용은 없다. 1.2. Hello, World! 러스트로 Hello, World! 출력하기.\n특징적인 내용은 아래와 같다.\n공식 가이드의 Helloworld 섹션 첫줄에 다른 언어에 대한 이해도를 전제하고 있다. 실제로 공식 가이드 문서 내내 러스트의 특징을 다른 언어의 특징과 거울처럼 대비하며 설명한다. 파일명 컨벤션은 스네이크 케이스를 사용한다. (그리고 그걸 첫장에 설명한다.) rustc와 같은 컴파일 커맨드도 첫장에 알려준다. fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 다양한 언어를 배워오면서 느끼는건, Hello, World!를 출력하려고 할 때 언어의 특징을 알 수 있다는 것이다. Public static void main(String[] args) \u0026hellip;. 러스트는 println! 매크로를 사용한다. (매크로는 러스트의 특징 중 하나이다, 나중에 자세히 정리가 나온지만 간단하게 설명하면 러스트의 매크로는 러스트의 문법을 확장할 수 있는 기능이다.) Hello World Anatomy fn : 함수를 선언할 때 사용하는 키워드. 러스트의에서 main함수의 의미 : 프로그램의 시작점을 나타낸다.(The main function is special: it is always the first code that runs in every executable Rust program.) {} : 블록을 나타낸다. 블록은 코드의 범위를 나타낸다. (블록은 러스트의 다른 부분과 마찬가지로 중괄호로 둘러싸여 있다.) println! : 매크로를 호출하는 방법. (매크로는 러스트의 문법을 확장할 수 있는 기능이다.) ; : 문장의 끝을 나타낸다. (러스트는 문장의 끝에 세미콜론을 붙여야 한다, 식의 끝에 세미콜론을 붙이는 것은 문장의 끝을 나타낸다. 이 가이드에서도 문과 식을 구분하는 것이 중요하다.) 러스트의 들여쓰기는 4칸을 권장한다. (공식 가이드에서는 4칸을 권장하는데.. 왜..?) 그 외에는 간단한 컴파일 관련 설명이다.\n1.3. Hello, Cargo! MZ한 언어답게 트랜디한 공식 빌드 시스템이자 패키지 매니저인 Cargo에 대한 간단한 가이드.\nCargo는 러스트의 빌드 시스템이자 패키지 매니저이다. [package] name = \u0026#34;hello_cargo\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] 보통은 이렇게 생겼다. (Cargo.toml 파일) cargo new hello_cargo : 새로운 프로젝트를 생성한다. cargo build : 프로젝트를 빌드한다. 기본적으로 러스트는 디버그 모드로 빌드한다. 그래서 빌드된 실행 파일(바이너리)은 target/debug/${my_project_name}에 위치한다. cargo run : 프로젝트를 실행한다. cargo check : 프로젝트를 빌드하지 않고 컴파일을 실행한다. cargo build --release : 프로젝트를 릴리즈 모드로 빌드한다. cargo update : 프로젝트의 의존성을 업데이트한다. 의존성을 체크하는 lock 파일이 있다. (Cargo.lock) 빌드할 때 알아서 변경을 감지하고 빌드한다. (즉, 변경사항이 없으면 빌드하지 않는다.) cargo check으로 컴파일만 하는 이휴는 빠르기 때문이다, 프로젝트 중간중간 컴파일체크만 하고 싶을 때 사용한다고 한다. --release 플래그로 릴리즈 모드로 빌드할 수 있다. (릴리즈 모드는 최적화가 적용된다.) 컨벤션은 아래와 같다.\n$ git clone example.org/someproject $ cd someproject $ cargo build Conculusion \u0026amp; Impression 패키지매니저를 공식적으로 가지고 있고, 빌드 시스템이 강력하다. 기본적으로 간단한 문법의 언어이다. 매크로가 있다. ","permalink":"http://localhost:1313/_wiki/getting-started/","summary":"1.1. Installation 러스트 설치에 대한 아주 간단한 가이드.\n간단한 내용이라 딱히 정리할 내용은 없다. 1.2. Hello, World! 러스트로 Hello, World! 출력하기.\n특징적인 내용은 아래와 같다.\n공식 가이드의 Helloworld 섹션 첫줄에 다른 언어에 대한 이해도를 전제하고 있다. 실제로 공식 가이드 문서 내내 러스트의 특징을 다른 언어의 특징과 거울처럼 대비하며 설명한다. 파일명 컨벤션은 스네이크 케이스를 사용한다. (그리고 그걸 첫장에 설명한다.) rustc와 같은 컴파일 커맨드도 첫장에 알려준다. fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 다양한 언어를 배워오면서 느끼는건, Hello, World!","title":"러스트 공식 가이드 1장 정리"},{"content":"러스트 공식 가이드 문서 정리 The Rust Programming Language 위의 러스트 공식 가이드 문서를 보고 정리한 내용입니다, 복습을 위해 공식 가이드를 한 번 다시 정리하고 시작하려고 합니다. 집합인가 [[Getting-Started]] : 러스트 설치 및 프로젝트 생성에 대한 가이드 [[Programming-a-Guessing-Game]] : 간단한 숫자 맞추기 게임을 만들어보며 러스트 프로그래밍 기초 문법 및 개념 익히기 [[Common-Programming-Concepts]] : 러스트 프로그래밍 기초 문법 및 개념 [[Understanding-Ownership]] : 러스트의 소유권 시스템에 대한 이해 [[burrow-checker]] : rust-in-action 내용 [[Using-Structs-to-Structure-Related-Data]] : 구조체를 사용하여 관련 데이터 구조화하기 [[Enums-and-Pattern-Matching]] : 열거형과 패턴 매칭 [[Managing-Growing-Projects-with-Packages-Crates-and-Modules]] : 패키지, 크레이트, 모듈을 사용하여 프로젝트 확장하기 [[Common-Collections]] : 컬렉션 사용하기 [[Error-Handling]] : 에러 처리하기 [[Funcional-Langauges-Features]] : Iterators and Closures ","permalink":"http://localhost:1313/_wiki/the-rust-programming-language/","summary":"러스트 공식 가이드 문서 정리 The Rust Programming Language 위의 러스트 공식 가이드 문서를 보고 정리한 내용입니다, 복습을 위해 공식 가이드를 한 번 다시 정리하고 시작하려고 합니다. 집합인가 [[Getting-Started]] : 러스트 설치 및 프로젝트 생성에 대한 가이드 [[Programming-a-Guessing-Game]] : 간단한 숫자 맞추기 게임을 만들어보며 러스트 프로그래밍 기초 문법 및 개념 익히기 [[Common-Programming-Concepts]] : 러스트 프로그래밍 기초 문법 및 개념 [[Understanding-Ownership]] : 러스트의 소유권 시스템에 대한 이해 [[burrow-checker]] : rust-in-action 내용 [[Using-Structs-to-Structure-Related-Data]] : 구조체를 사용하여 관련 데이터 구조화하기 [[Enums-and-Pattern-Matching]] : 열거형과 패턴 매칭 [[Managing-Growing-Projects-with-Packages-Crates-and-Modules]] : 패키지, 크레이트, 모듈을 사용하여 프로젝트 확장하기 [[Common-Collections]] : 컬렉션 사용하기 [[Error-Handling]] : 에러 처리하기 [[Funcional-Langauges-Features]] : Iterators and Closures ","title":"The Rust Programming Language"},{"content":"Neovim Copilot 관련 설정 이슈 Copilot을 import하고 잘 쓰고 있는데, Vimwiki와 Tab키 충돌이 발생한다. Tab키를 누르면, Copilot이 자동완성을 제공하는데, Vimwiki에서는 Tab키를 사용하여 들여쓰기를 한다. 뭔가 Vimwiki의 탭이 Copilot의 탭보다 우선순위가 높은 것 같다. 처음에는 Copilot의 설정을 변경하여 해결하려고 했지만 Vimwiki의 설정을 변경하는 것이 더 편할 것 같다. 해결 다행히도 Vimwiki Repository에 이슈가 올라와 있었다. Vimwiki Issue return { \u0026#39;vimwiki/vimwiki\u0026#39;, init = function() -- .. end, config = function() vim.g.vimwiki_key_mappings = { table_mappings = 0, } vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;nl\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;VimwikiNextLink\u0026#39;, { silent = true }) -- For Tab vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;pl\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;VimwikiPrevLink\u0026#39;, { silent = true }) -- For STab end } 위와 같이 설정을 변경하면, Tab키를 누르면 들여쓰기가 되고, \u0026lt;leader\u0026gt;nl을 누르면 다음 링크로 이동한다. 내 생각으로는 vimwiki_key_mappings 설정만 변경해도 괜찮았어야 하는데, 저부분만 변경시 제대로 동작하지 않았다. 물론 Tab으로 페이지 내의 링크를 이동하는걸 잘 쓰고 있었지만, \u0026lt;leader\u0026gt;nl을 쓰는 것도 나쁘지 않아서 적용해봤는데 제대로 동작한다. 실제 코드 변경 nvimConfig repo commit hash - 921de26 use({ \u0026#34;vimwiki/vimwiki\u0026#34;, config = function() vim.g.vimwiki_conceallevel = 0 vim.g.vimwiki_global_ext = 0 vim.g.vimwiki_key_mappings = { table_mappings = 0, } vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;nl\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;VimwikiNextLink\u0026#39;, { silent = true }) -- For Tab vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;pl\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;VimwikiPrevLink\u0026#39;, { silent = true }) -- For STab vim.g.vimwiki_list = { { path = \u0026#39;/Users/joonkyu_kang/wiki/SmallzooDevWiki/content/_wiki\u0026#39;, ext = \u0026#39;.md\u0026#39;, styntax = \u0026#39;markdown\u0026#39;, index = \u0026#39;home\u0026#39; }, { path = \u0026#39;/Users/joonkyu_kang/wiki/private_wiki\u0026#39;, ext = \u0026#39;.md\u0026#39;, }, } end }) 위와 같이 변경하였다, vimwiki 설정도 plugin 파일로 빼야하는데 귀찮\u0026hellip; ","permalink":"http://localhost:1313/_wiki/neovim-copilot-config/","summary":"Neovim Copilot 관련 설정 이슈 Copilot을 import하고 잘 쓰고 있는데, Vimwiki와 Tab키 충돌이 발생한다. Tab키를 누르면, Copilot이 자동완성을 제공하는데, Vimwiki에서는 Tab키를 사용하여 들여쓰기를 한다. 뭔가 Vimwiki의 탭이 Copilot의 탭보다 우선순위가 높은 것 같다. 처음에는 Copilot의 설정을 변경하여 해결하려고 했지만 Vimwiki의 설정을 변경하는 것이 더 편할 것 같다. 해결 다행히도 Vimwiki Repository에 이슈가 올라와 있었다. Vimwiki Issue return { \u0026#39;vimwiki/vimwiki\u0026#39;, init = function() -- .. end, config = function() vim.g.vimwiki_key_mappings = { table_mappings = 0, } vim.","title":"Neovim Copilot 관련 설정 이슈"},{"content":" 이미지 호스팅 알아보기 구글 검색 노출 관련 검색, 테스팅 징행하기 [v] 빔을 통해서 괄호를 편하게 작성하는 방법에 대한 포스팅 작성하기 회고 문서 작성하기 ","permalink":"http://localhost:1313/_wiki/todolist/","summary":" 이미지 호스팅 알아보기 구글 검색 노출 관련 검색, 테스팅 징행하기 [v] 빔을 통해서 괄호를 편하게 작성하는 방법에 대한 포스팅 작성하기 회고 문서 작성하기 ","title":"ToDoList✅"},{"content":"모니터🖥️ Lg 듀얼업 모니터 : 꼭 사고싶은 모니터, 최종적인 조합은 이것과 피벗용 27인치 모니터로 마무리 하고 싶다. 키보드⌨️ HHKB 키보드 : 미니배열이 좋으면서도 백틱이 걱정되긴한다. 키 커스텀이 어느정도인지 확인하고 구매할 것 같다 ","permalink":"http://localhost:1313/_wiki/%EC%82%AC%EA%B3%A0-%EC%8B%B6%EC%9D%80-%EC%9E%A5%EB%B9%84/","summary":"모니터🖥️ Lg 듀얼업 모니터 : 꼭 사고싶은 모니터, 최종적인 조합은 이것과 피벗용 27인치 모니터로 마무리 하고 싶다. 키보드⌨️ HHKB 키보드 : 미니배열이 좋으면서도 백틱이 걱정되긴한다. 키 커스텀이 어느정도인지 확인하고 구매할 것 같다 ","title":"사고싶은 장비 List"},{"content":"Inbox 💭 [[Blog에-대한-생각]] [[Interview-From-Jim-Keller]] Monthly goal 🚀 [[2024-04]] [[2024-05]] ToDoList ✅ [[ToDoList]] Travel 🌍 About Machines 🧊 [[사고-싶은-장비]] About Settings 🧊 [[회사컴-세팅]] [[New-Vimwiki-Test]] Chore 🧹 [[이사]] ","permalink":"http://localhost:1313/_wiki/private-wiki/","summary":"Inbox 💭 [[Blog에-대한-생각]] [[Interview-From-Jim-Keller]] Monthly goal 🚀 [[2024-04]] [[2024-05]] ToDoList ✅ [[ToDoList]] Travel 🌍 About Machines 🧊 [[사고-싶은-장비]] About Settings 🧊 [[회사컴-세팅]] [[New-Vimwiki-Test]] Chore 🧹 [[이사]] ","title":"개인적인 이야기를 작성할 예정입니다."},{"content":"1일 1커맨드 정리 ^ + b, f : 한 페이지씩 스크롤 zz : 현재 커서가 있는 줄을 화면 중앙으로 이동 yi( : 괄호 안에 있는 내용 복사 vap : 비주얼모드 한 문단 블록 씌우기 이동 관련 brace 관련 커맨드를 조금 더 잘쓰면 좋겠다는 생각을 한다.\n개인적으로 vim을 더 잘쓰기 위해서 정리를 잘 해둬야 할 것 같다.\n^ + b, f: 한 페이지씩 스크롤 ^ + d, u: 반 페이지씩 스크롤 e, E: 다음 단어의 끝으로, 문자 단위 이동 w, W: 다음 단어의 처음으로, 문자 단위 이동 $: 줄의 마지막으로 이동 0: 줄의 처음으로 이동 ^: 줄의 처음으로 이동 (공백이 아닌 처음 시작되는 문자) Shift + g: 문서의 마지막으로 이동 gg, 1g: 문서의 처음으로 이동 (숫자 라인으로 이동) ), (: 다음, 이전 문장의 처음으로 이동 }, {: 다음, 이전 문단의 처음으로 이동 ]], [[: 다음, 이전 구절의 처음으로 이동 안녕하세요 Vimwiki 관련 커맨드 Tab – Find next wiki link Shift + Tab – Find previous wiki link Split 관련 커맨드 \u0026lt;leader\u0026gt;sv: 창 수직 분할 \u0026lt;leader\u0026gt;sh: 창 수평 분할 \u0026lt;leader\u0026gt;se: 창 확장 \u0026lt;leader\u0026gt;sx: 창 닫기 lsp 관련 커맨드 \u0026lt;leader\u0026gt;gd: 정의로 이동 ","permalink":"http://localhost:1313/_wiki/%EC%9E%90%EC%A3%BC-%EA%B9%8C%EB%A8%B9%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%A0%95%EB%A6%AC/","summary":"1일 1커맨드 정리 ^ + b, f : 한 페이지씩 스크롤 zz : 현재 커서가 있는 줄을 화면 중앙으로 이동 yi( : 괄호 안에 있는 내용 복사 vap : 비주얼모드 한 문단 블록 씌우기 이동 관련 brace 관련 커맨드를 조금 더 잘쓰면 좋겠다는 생각을 한다.\n개인적으로 vim을 더 잘쓰기 위해서 정리를 잘 해둬야 할 것 같다.\n^ + b, f: 한 페이지씩 스크롤 ^ + d, u: 반 페이지씩 스크롤 e, E: 다음 단어의 끝으로, 문자 단위 이동 w, W: 다음 단어의 처음으로, 문자 단위 이동 $: 줄의 마지막으로 이동 0: 줄의 처음으로 이동 ^: 줄의 처음으로 이동 (공백이 아닌 처음 시작되는 문자) Shift + g: 문서의 마지막으로 이동 gg, 1g: 문서의 처음으로 이동 (숫자 라인으로 이동) ), (: 다음, 이전 문장의 처음으로 이동 }, {: 다음, 이전 문단의 처음으로 이동 ]], [[: 다음, 이전 구절의 처음으로 이동 안녕하세요 Vimwiki 관련 커맨드 Tab – Find next wiki link Shift + Tab – Find previous wiki link Split 관련 커맨드 \u0026lt;leader\u0026gt;sv: 창 수직 분할 \u0026lt;leader\u0026gt;sh: 창 수평 분할 \u0026lt;leader\u0026gt;se: 창 확장 \u0026lt;leader\u0026gt;sx: 창 닫기 lsp 관련 커맨드 \u0026lt;leader\u0026gt;gd: 정의로 이동 ","title":"Vim 자주 깜빡하는 커맨드"},{"content":"생활 관련 링크 Archive 목 디스크 스트레칭 : 언젠가는 하겠지\u0026hellip;?\n게임음악 모음\n지브리 오케스트라\n","permalink":"http://localhost:1313/_wiki/life-archive/","summary":"생활 관련 링크 Archive 목 디스크 스트레칭 : 언젠가는 하겠지\u0026hellip;?\n게임음악 모음\n지브리 오케스트라","title":"생활 관련 링크 Archive"},{"content":"개발 관련 링크 Archive ","permalink":"http://localhost:1313/_wiki/dev-archive/","summary":"개발 관련 링크 Archive ","title":"개발 관련 링크 Archive"},{"content":"01. Intro - 블로그를 다시 시작하려고 보니.. 👋🏼 올해 초 이직에 대한 열망이 매우 차오를 때 부터 블로그를 다시 시작해야지 하는 생각이 계속 들어왔다. 누구나 그렇겠지만, 회사와 퇴근 후에 진행하는 멘토링/튜터링이 바빴기 때문에.. 튜터링 혹은 멘토링을 하는 내내 블로그와 TIL을 권해놓고 나는 정작 이력서를 쓰면서 나에 대한소개나 포트 폴리오를 쓰기도 참 애매하구나 싶었다. 그래서 내가 일하면서 해왔던 트러블슈팅들이나, 자라났던 생각들을 잘 기록해 놓고 싶어졌다. 지금까지의 기록은 계획을 가지지 않고 해왔기 때문에살리는건 시작도 전에 포기했다! Vimwiki Private 디렉토리에 우후죽순으로 작성되어 있고. 아마 해당 기록을 올리면 높은 확률로 고소를 당할 것 같다 구상권 무튼 늦었지만 다시 시작해보려고 마음을 먹었다, 지나간일은 회고가 되고 하고있는 것들이나 배우는 것들은 TIL 비슷한 뭔가가 되겠지 그래서 블로그를 시작하기로 마음먹고 최근 2주동안 겪은 시행착오에 대해서 이야기 해보려고 한다. 02. Wannabe - Johngrib과 수많은 위키형 블로그🚀 앞서 이야기 한 것처럼 원래 Johngrib님의 블로그를 보고 나의 NeoVim config에 나름 적당히 잘 세팅해놓은 Vimwiki를 사용하고 있었다.\n그리고Johngrib님의 레포를 fork해서 jekyll로 깃허브 블로그도 띄웠었다.\n사실 그러고 나서는 거의 private 위키만을 이용해 왔었다. 왜냐하면 퇴근하고 하는 일도 있다보니 개인컴을 사용하지 않기도 하고, 회사맥에는 주로 업무를 위한 메모가 많았어서 분류할 겨를이 없었다.\n그리고 다시 블로그를 띄우려고 하다보니.. 여러가지 설정들도 까먹고, 다시 시작하기 손에 안잡혔다.\n그렇지만 위키의 형식을 갖추지 않고 글을 써갈 자신은 없고, 포스팅을 위해 추가적인 시간을 쓰기는 여전히 싫었다.\n결론적으로는 새로 블로그를 파면서 위키를 세팅하는 시간을 가져기로 했고 나름의 대장정이 시작됐다\n03. 블로그를 시작하며 영감을 줬던 것들 당연히 Johngrib님의 블로그 저런 윈도우 98같은 감성부터 세세한 기능들과 pre-hook까지 내가 했던 해왔던 고민들이랑 많이 일치한다는 생각을 했다. 다양한 TIL 레포들 이렇게 죽어라 긴 TIL을 보며 참 부러웠던 것 같다. 04. Hugo, Gatsby, Jekyll - 뭐가 더 좋고 적합할까🤔 사실 제목은 위와 같이 작성했지만, Jekyll은 딱히 고민하지 않았다, Jekyll을 사용해서는 Johngrib님의 위키보다 좋은 위키를 만들 자신이 없었다.\n결론적으로는 Hugo, Gatsby 였는데 이 고민을 해결하는데 가장 시간이 오래 걸렸던 것 같다.\n대표적인 특징이라기 보다는 내가 느낀 장단점은 아래와 같다\nGatsby 장점 너무 좋은 예시가 있었다. 바로 PadosumWiki 딱 저렇게 만들고 싶었었다. 심지어 해당 위키를 실행시키는 starter도 찾았었다. 싫다 싫다 하면서 개발해온 React와 Graphql 짬밥이 있어 커스텀에 자신이 있었다. 사실 커스텀보다 디버깅에 자신이 있었다. Gatsby 단점 npm 싫다\u0026hellip; yarn 도 그냥 그렇다.. pnpm은 왜 안되는지 모르겠지만 굳이 공부하기는 싫었다. 마찬가지로 퇴근하고 React도 싫었다.. 회사에서와 달리 내가 뷰를 만지는게 불가능한 시점부터 유의미한 커스텀이 가능할까 싶어지기도 했다 핑계 Hugo 장점 Go를 사용해서 만들어 졌다. (커스텀 하기 위해 공부를 해야 한다면 차라리 이쪽을\u0026hellip;) 빠르다 (대표적인 장점이지만, 실제로 Netlify에 호스팅을 시작하고 뭔가 크게 다가왔다) 나름 Jekyll을 써본 적이 있다고 익숙한 정적 사이트 생성기의 문법 (이생각은 큰 후회를 불러온다) 가볍고 미니멀해서 마음에 드는 테마가 있었다. 영어라면 레퍼런스는 충분히 많고, 포럼도 나름 활발하다. 너무 많이 든든한 레퍼런스를 찾았다, 이친구의 가이드 만 있으면 걱정이 없을 정도.. Hugo 단점 Jekyll을 쓸 때 기억이 안났나 보다, 사실상 Go로 뭔가를 할 일은 극히 드물다, 아무래도 블로그 영업글? 등에서 Go로 되어있는 부분을 지나치게 강조하시는 것 같다. (물론 이부분은 생각이 많이 달라질 수 있다.) 특유의 SSR 템플릿 문법 (이건 위와 같은 맥락인데 쓰고 수정하는 내내 Thymeleaf, Handlebars 와 같은 문법에 시달렸다) 테마의 편집이 생각보다 신경 쓸 부분이 있긴하다. (서브모듈로 관리해야하는게 또 하나의 관리포인트가 될 것 같다, 심지어 조금 찝찝해서 테마 서브모듈을 포크를 따서 수정중이다) 05. Hugo Blog - 세팅기💭 기본 설정 기본 세팅 : 너무 쉽고 간편한 편이다. Hugo 공식 가이드도 잘 되어있고, 이 친구의 가이드와 함께면 더 간단하게 세팅 할 수 있다. 추가 커스텀 세팅 : 공식 가이드와 위 친구의 가이드를 참고해서 따라하다보면 눈치껏 커스텀이 가능하다. toc와 코드블럭과 같은 세팅들을 주로 했다. Nord Theme으로 무드잡기🧊 : Papermod는css관리가 잘되어 있어서 GPT에게 부탁하면 Nord처럼 유명한 Color Scheme은 바로 해준다. Theme/${테마명} 의 asset에 보면 보통 잘되어 있는 테마들은 주요 색상값에 대한 관리가 되어 있다. 테마 관리 : 결국 이런식의 커스텀은 테마쪽에서 이루어 질 수 밖에 없어서 결국 테마를 포크딴 레포를 서브모듈로 지정했다. (아마 테마 커스텀에 생각이 없거나, 더 정확하게 커스텀할 실력이 있다면 원본 레포를 서브모듈로 추가해 사후관리를 받는게 더 좋은 선택지 일 것 같다) Vimwiki 관련 설정 Vimwiki의 링크를 html 링크로 수정하기\n\u0026lt;script\u0026gt; ;(function() { var content = document.querySelector(\u0026#39;article.post-single\u0026#39;); content.innerHTML = content.innerHTML.replace(/\\[\\[(.+?)\\]\\]\\{(.+?)\\}/g, \u0026#39;\u0026lt;a href=\u0026#34;../$1\u0026#34;\u0026gt;$2\u0026lt;/a\u0026gt;\u0026#39;); content.innerHTML = content.innerHTML.replace(/\\[\\[(.+?)\\]\\]/g, \u0026#39;\u0026lt;a href=\u0026#34;../$1\u0026#34;\u0026gt;$1\u0026lt;/a\u0026gt;\u0026#39;); })(); \u0026lt;/script\u0026gt; vimwiki는 [[Link]]와 같은 형식의 링크를 생성하고, 마크다운은 [link](pathToLinkResource)와 같은 형식의 링크를 작성해줘야 한다 \u0026ldquo;./theme/Papermod/layouts/_default/single.html\u0026rdquo; (마크다운 렌더 탬플릿) Johngrib님의 스크립트와 거의 같다.\nnvim config의 vimwiki관련 lua 스크립트 수정하기\nuse({ \u0026#34;vimwiki/vimwiki\u0026#34;, config = function() vim.g.vimwiki_conceallevel = 0 vim.g.vimwiki_list = { { path = \u0026#39;/Users/joonkyu_kang/wiki/SmallzooDevWiki/content/_wiki\u0026#39;, -- hugo 블로그 위치로 수정한다. ext = \u0026#39;.md\u0026#39;, styntax = \u0026#39;markdown\u0026#39;, index = \u0026#39;home\u0026#39; -- 인덱스파일의 이름을 바꿔줘야 한다. }, { path = \u0026#39;/Users/joonkyu_kang/wiki/private_wiki\u0026#39;, -- private wiki 설정 ext = \u0026#39;.md\u0026#39;, }, } end }) 별거 아닌데, 여기서 은근히 시간을 많이 잡아먹었다, index.md를 사용해야 하는데, 휴고는 index.md를 uri path 설정중 문법으로 사용한다. Vimwiki가 생각보다 설정이 되는걸 빨리 알았다면 시간을 아꼈을 것 같다. 처음에는 심지어 Git commit pre-hook에 스크립트를 둬서 해결하려고 했었다. vim.cmd [[ let g:md_modify_disabled = 0 function! NewTemplate () let l:wiki_directory = v:false for wiki in g:vimwiki_list if expand(\u0026#39;%:p:h\u0026#39;) =~ expand(wiki.path) let l:wiki_directory= v:true break endif endfor if !l:wiki_directory echom \u0026#39;first debugging point \u0026gt;\u0026gt; called this return statement\u0026#39; return endif if line(\u0026#34;$\u0026#34;) \u0026gt; 1 return endif let l:template = [] call add(l:template, \u0026#39;---\u0026#39;) call add(l:template, \u0026#39;title: \u0026#39;) call add(l:template, \u0026#39;summary: \u0026#39;) call add(l:template, \u0026#39;date: \u0026#39; . strftime(\u0026#39;%Y-%m-%d %H:%M:%S +0900\u0026#39;)) call add(l:template, \u0026#39;lastmod: \u0026#39; . strftime(\u0026#39;%Y-%m-%d %H:%M:%S +0900\u0026#39;)) call add(l:template, \u0026#39;tags: \u0026#39;) call add(l:template, \u0026#39;categories: \u0026#39;) call add(l:template, \u0026#39;public: true\u0026#39;) call add(l:template, \u0026#39;parent: \u0026#39;) call add(l:template, \u0026#39;description: \u0026#39;) call add(l:template, \u0026#39;showToc: true\u0026#39;) call add(l:template, \u0026#39;---\u0026#39;) call add(l:template, \u0026#39;\u0026#39;) call add(l:template, \u0026#39;# \u0026#39;) call setline(1, l:template) execute \u0026#39;normal! G\u0026#39; execute \u0026#39;normal! $\u0026#39; echom \u0026#39;new wiki page has created\u0026#39; endfunction function! LastModified() if g:md_modify_disabled return endif if \u0026amp;modified \u0026#34; echo(\u0026#39;markdown updated time modified\u0026#39;) let save_cursor = getpos(\u0026#34;.\u0026#34;) let n = min([10, line(\u0026#34;$\u0026#34;)]) keepjumps exe \u0026#39;1,\u0026#39; . n . \u0026#39;s#^\\(.\\{,10}updated\\s*: \\).*#\\1\u0026#39; . \\ strftime(\u0026#39;%Y-%m-%d %H:%M:%S +0900\u0026#39;) . \u0026#39;#e\u0026#39; call histdel(\u0026#39;search\u0026#39;, -1) call setpos(\u0026#39;.\u0026#39;, save_cursor) endif endfun augroup wimwikiauto autocmd BufWritePre *wiki/*.md call LastModified() autocmd BufRead,BufNewFile *wiki/*.md call NewTemplate() augroup END ]] vimwiki를 위한 설정파일도 vimwiki-command.lua에 수정해뒀다. 사실 기존에 사용하던 스크립트에 frontmatter만 hugo에 맞게 수정했다. 06. 배포하기 - Netlify ✈️ 배포는 역시 Github pages나 Netlify를 고민했다.\n둘 다 일정 사용량까지는 무료이며 확인해봤을때 특정 사이트가 빠르거나 하지는 않은 것 같다.\n그래도 Netlify가 배포관련 설정들이 훨씬 더 상세하고, 에러나 로그도 잘 관리되고 있다.\n나중에 비용이 발생 할 수 있다는 것 때문에 조금 더 고민했는데, 그정도로 블로그를 많이 봐주신다면 기꺼이 낼 만 한 금액이기도 했다.\n연동도 github pages와 비견될 정도로 간단하다.\n일단 Netlify에 접속해서 github로 연동하고 물어보는걸 답하면 바로 배포까지 해준다.\n다만 바로 잘되진 않았는데, 처음 사용해보는 만큼 약간의 트러블슈팅을 했다.\n사실 당연히 체크 했어야 하는데, 요즘 서비스들은 너무 잘 래핑되어있고, 휴고정도라면 알아서 해줄줄 알고 생각을 안했던 것 같다.\n빌드 스크립트를 작성해줘야 한다. 당연한 이야기이긴 하지만, 뭔가 휴고인거 알고 알아서 하려나 싶고 안했다가 빌드가 안됐다. 휴고 레포를 연동하고 Deploy 관련 설정을 하다보면 설정하는곳이 나온다. 거기에 \u0026ldquo;huho\u0026quot;라고 기입하면 된다. 배포 디렉토리를 설정해줘야 한다. 마찬가지의 맥락. pulic 디렉토리를 설정해줘야 한다. 마지막으로 빌드 버전을 설정해줘야 한다. 로컬에서 빌드가 잘되는데, 문법에러가 발생한다면 이부분을 체크해보자 이게 다 싫다면 아래와 같은 설정파일을 프로젝트 루트에 netlify.toml이라는 이름으로 두면 알아서 해준다.\n[build] publish = \u0026#34;public\u0026#34; # Or the directory where your Hugo site generates the static files command = \u0026#34;hugo\u0026#34; # This is the default build command for Hugo [build.environment] HUGO_VERSION = \u0026#34;0.123.8\u0026#34; 07. 결과\u0026amp; Left Todo 🤔 Netlify와 Hugo로 설정을 해두니 Vimwiki private을 사용할때와 차이는 정말 커밋 푸시 한번으로 끝났다. 나도 내 생활에 큰 도구가 되어주기를 바라고 있다. 거의 대부분의 설정이 마무리가 잘 되었지만, 아직 남은 일들이 있다.\n이미지관련 플러그인을 조금 더 알아보고, 가능하면 이미지 호스팅 서비스를 찾아내려고 한다. (로컬로 관리하기는 귀찮고, Netlify는 가격을 깐깐하게 매기는 느낌이다) 아직 검색 노출이 잘 되는지 확인해보지 않았는데, 아마도 헤더쪽 설정을 조금 더 해야할 것 같다. 태그와 카테고리 검색과 같은 설정들은 아직 테마의 기본 상태인데 찾아봐야할 것 같다.(다만 메인 위키의 길게 늘어진 링크들을 만들고 싶어서 바로 보지는 않을 것 같다.) 코드 테마를 바꾸고 싶다 이제까지 나만 보려고 써왔던 나의 마크다운 문서 작성능력에 회의가 왔기 때문에 마크다운 문서 공부.. 08. Link (감사합니다\u0026hellip;.) 🙇 Johngrib 님 어느 휴고를 잘쓰는 중국 친구 ","permalink":"http://localhost:1313/_wiki/%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%95%EC%B0%A9%ED%95%98%EA%B8%B0/","summary":"01. Intro - 블로그를 다시 시작하려고 보니.. 👋🏼 올해 초 이직에 대한 열망이 매우 차오를 때 부터 블로그를 다시 시작해야지 하는 생각이 계속 들어왔다. 누구나 그렇겠지만, 회사와 퇴근 후에 진행하는 멘토링/튜터링이 바빴기 때문에.. 튜터링 혹은 멘토링을 하는 내내 블로그와 TIL을 권해놓고 나는 정작 이력서를 쓰면서 나에 대한소개나 포트 폴리오를 쓰기도 참 애매하구나 싶었다. 그래서 내가 일하면서 해왔던 트러블슈팅들이나, 자라났던 생각들을 잘 기록해 놓고 싶어졌다. 지금까지의 기록은 계획을 가지지 않고 해왔기 때문에살리는건 시작도 전에 포기했다!","title":"Hugo, Vimwiki로 블로그 정착하기"},{"content":" Contact : Email 📧 Github : SmallzooDev 🐦‍⬛ Postings Tag의 글은 조금 더 읽기 쉽게 작성하려고 노력하고 있습니다 : #Postings 🗞️ This wiki inspired by : 기계인간 Johngrib 💭 Main 🏠 [[Daily-Log-2024]] : 저에 대해 궁금하시다면 이 문서를 참고해주세요(데일리 아님 주의 🙉) Archive 📘 [[Dev-Archive]] : 개발관련 유용한 정보, 링크 모음 [[Life-Archive]] : 개발 외적인 유용한 정보, 링크 모음 [[Private-wiki]] : 개인적인 고민과 목표, 약간은 가벼운 이야기들 [[Cheat-Sheet]] : 개발 관련 Cheat Sheet 모음 Rust 🦀 [[Rust-Main]] [[The-Rust-Programming-Language]] [[Effective-Rust]] [[Build-Redis-With-Rust]] Cpp 🐋 [[Cpp-basic]] : C++ 기본 문법 정리 Mathematics 🧮 Backend 💰 DataBase 🗄️ [[데이터-중심-애플리케이션-설계]] : 해당 도서에 대한 스터디 내용정리 문서 Computer Science 🦉 [[OSTEP]] : 운영체제 아주 쉬운 세 가지 이야기 [[Network]] : TCP/IP Illustrated Vim 🦅 [[Neovim-Copilot-Config]] [[Vim이-느리다면-해볼-것들]] [[Vim-Impove-Sheet]] Postings 🌳 [[새로운-블로그-정착하기]] [[Neovim-Migration-하기]] [[Interview-From-Jim-Keller]] [[코딩-테스트-언어-정하기]] [[튜터링-질의-응답-모음]] [[블로그-작성-가이드라인]] ETC 👻 [[Settings]] ","permalink":"http://localhost:1313/_wiki/home/","summary":" Contact : Email 📧 Github : SmallzooDev 🐦‍⬛ Postings Tag의 글은 조금 더 읽기 쉽게 작성하려고 노력하고 있습니다 : #Postings 🗞️ This wiki inspired by : 기계인간 Johngrib 💭 Main 🏠 [[Daily-Log-2024]] : 저에 대해 궁금하시다면 이 문서를 참고해주세요(데일리 아님 주의 🙉) Archive 📘 [[Dev-Archive]] : 개발관련 유용한 정보, 링크 모음 [[Life-Archive]] : 개발 외적인 유용한 정보, 링크 모음 [[Private-wiki]] : 개인적인 고민과 목표, 약간은 가벼운 이야기들 [[Cheat-Sheet]] : 개발 관련 Cheat Sheet 모음 Rust 🦀 [[Rust-Main]] [[The-Rust-Programming-Language]] [[Effective-Rust]] [[Build-Redis-With-Rust]] Cpp 🐋 [[Cpp-basic]] : C++ 기본 문법 정리 Mathematics 🧮 Backend 💰 DataBase 🗄️ [[데이터-중심-애플리케이션-설계]] : 해당 도서에 대한 스터디 내용정리 문서 Computer Science 🦉 [[OSTEP]] : 운영체제 아주 쉬운 세 가지 이야기 [[Network]] : TCP/IP Illustrated Vim 🦅 [[Neovim-Copilot-Config]] [[Vim이-느리다면-해볼-것들]] [[Vim-Impove-Sheet]] Postings 🌳 [[새로운-블로그-정착하기]] [[Neovim-Migration-하기]] [[Interview-From-Jim-Keller]] [[코딩-테스트-언어-정하기]] [[튜터링-질의-응답-모음]] [[블로그-작성-가이드라인]] ETC 👻 [[Settings]] ","title":"Index 🧊️"},{"content":" Contact: Email 📧 안녕하세요! 지금은 웹 백엔드 개발자로 일하고 있는 [SmallzooDev 🐦‍⬛] 입니다! 언젠가는 레거시가 되지 않는 무언가를 개발해보고 싶습니다. 알고 계시겠지만, [Nord Theme 🧊]을 좋아합니다. Vim을 좋아합니다. [Neovim ⌨️]은 더 좋아합니다. 지금은 [이런 설정 🚀]으로 네오빔에 눌러앉았습니다. 지금은 Rust를 가장 열심히 공부하고 있습니다. [기계인간 Johngrib 💭]님의 위키에 영감을 받아 위키 형식으로 운영해보려고 합니다! 좋은 기회에 열려있습니다! ","permalink":"http://localhost:1313/about/","summary":"백엔드 개발자로 일하고 있는 강준규 입니다!","title":"About Me🧊️"}]