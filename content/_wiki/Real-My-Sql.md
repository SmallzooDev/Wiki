---
title: RealMySql 8.0
summary: 
date: 2025-02-27 10:17:43 +0900
lastmod: 2025-02-27 12:46:23 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## 4장아키텍처
---


### MySQL 엔진 관련
#### 기본
- 핸들러, 엔진, 스토리지엔진, 하드웨어로 이루어짐
- 스레딩: 포어그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드
  - MyISAM은 클라이언트스레드가 쓰기 작업까지
- 메모리: 글로벌영역과 클라이언트 로컬
  - 글로벌 : 테이블 캐시, 버퍼풀, 해시인덱스, 리두로그 버퍼
  - 로컬 : 커넥션, 정렬버퍼, 조인 버퍼

> 각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

#### 쿼리 실행 구조

> SQL 요청 -> 
> (MySQL 엔진에서) 쿼리파서 -> 전처리기 -> 옵티마이저(쿼리 변환, 비용 최적화, 실행 계획 수립) -> 쿼리실행기
> (스토리지 엔진에서 실행)

- 쿼리 파서
  - 사용자 요청 쿼리를 토큰으로 분리해 트리구조로 만듦, 문법체크도 여기서
- 전처리기
  - 문장의 구조적인 문제점 파악, 객체 존재여부나 접근권한 체크도 여기서
- 옵티마이저
  - 가장 저렴한 비용의 실행계획 결정
> 이 책에서는 옵티마이저가 선택하는 내용을 설명할 것이며, 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있게
> 유도하는가를 알려줄 것이다.

#### 실행 엔진
> 만들어진 계획대로 각 핸들러에서 받은 요청을 다른 핸들러 요청의 입력으로 연결하는 역할

#### 그 외
각각의 세부 주제로 잡는게 좋은 것 같다. 무튼 아래와 같은 정보들이 엔진에서 지원한다.
- 복제
- 쿼리 캐시
- 스레드 풀
- 트랜잭션 지원 메타데이터


### InnoDB 스토리지 엔진 아키텍처
> 거의 유일하게 레코드 기반의 잠금을 제공한다.

#### 프라이머리 키에 의한 클러스터링
- 프라이머리 키 값의 순서대로 디스크에 저장됨
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용(MyISAM에서는 실제 물리적인 주소)

#### 외래 키 지원
- 실제 엔진레벨에서의 외래키 제약 조건에 대한 지원을 함

#### MVCC
> 일반적으로 레코드 레벨의 트랜잭션을 지원 하는 dbms가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공하는데 목적이 있따.

- 언두로그를 통해 지원
- multi version이란 하나의 레코드에 대해 여러개의 버전이 동시 관리된다는 것
- 구문 실행과 동시에 (커밋 여부와 관련 없이) innodb버퍼 풀에 반영, 디스크에는 반영여부가 확실치 않음
- 이 시점에서의 조회는 격리레벨에 따라 다르다. 크게 살펴보면
- `READ_UNCOMMITED` : 버퍼에서 반환한다.
- `READ_COMMITED` 이상의 격리 레벨 : 커밋 전이면 언두로그에서 반환한다.
- 즉 innodb버퍼풀-디스크, 언두로그까지 멀티버전이 있는 것

#### 잠금 없는 일관된 읽기 (Non-Locking Consitent Read)
- 간단하게 요약하면 읽기에 대한 락을 걸지 않고, 격리레벨설정에 따라서, 읽는 시점에 적절한 데이터를 읽어감

#### 자동 데드락 감지
- 잠금 대기 목록을 그래프 형태로 관리
- 별도의 스레드가 해당 목록을 토대로 데드락을 감지
- 교착상태의 트랜잭션중 하나를 종료
- 트랜잭션 언두 로그를 기준으로(경제적인 관점에서) 강제종료할 트랜잭션을 선택
- 참고로 상위 레이어의 mysql엔진에서 테이블잠금이 된경우 데드락 판단이 불확실 할 수 있는데, 시스템 변수로 방지할수있음 `innodb_table_locks`
- 기본적으로 데드락 감지 스레드 자체의 부하나 리소스가 크지 않지만, 트랜잭션이 많아지면 부담이됨, 그리고 심지어는 위의 `잠금 대기 목록`에도 락을 걸기에, 다른 서비스 쿼리의 트랜잭션에도 지연을 유발함.
- 그래서 `innodb_deadlock_detect`를 끄고, `innodb_lock_wait_timeout`을 통해서 락시간을 통해 트랜잭션을 언두하는 방식으로 운영하기도 함.
  - 책에서 나온 내용은 아니지만, 아마도 교착상태의 트랜잭션을 경제적으로 종료하는것은 아니라, 결과적인 부화는 더 안좋을 수 있을것 같다. (상황에 따라서)


#### 자동화된 장애 복구
- 일반적으로 매우 견고한 장애복구 시스템이 있음
- `innodb_force_recovery` : 장애가 나서 시작이 안되는경우 사용
- 위의 변수 설정으로 시작하면, 가능한 만큼 덤프로 데이터를 백업하고, 그 데이터로 테이블 다시 생성하는것이 좋다.
  - 1=SRV_FORCE_IGNORE_CORRUPT : 인덱스나 테이블의 손상을 무시하고 시작
  - 2=SRV_FORCE_NO_BACKUP : 메인스레드를 시작하지 않고 서버 시작, 메인스레드가 언두데이터 삭제하는과정에서 장애가 반복된다면 이거 사용
  - 3=SRV_FORCE_NO_TRX_UNDO : 커밋되지 않고 종료된 트랜잭션의 롤백을 막음
  - 4=SRV_FORCE_NO_IBUF_MERGE : 인서트 버퍼의 내용 무시하고 시작
  - 5=SRV_FORCE_NO_UNDO_LOG_SCAN : 언두로그를 스캔하지 않고, 장애시점의 트랜잭션을 커밋한것처럼 동작
  - 6=SRV_FORCE_NO_LOG_REDO : 마지막 체크포인트로 시작

> 이래도 안된다면, db백업과 바이너리를 통해서..

### InnoDB 버퍼 풀
> InnoDB 스토리지 엔진에서 가장 핵심적인 부분, 디스크 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.
> 쓰기작업을 지연시켜 일괄 작업으로 처리해주는 버퍼 역할도 같이 한다.

#### 버퍼 풀의 크기 설정
- os의 80퍼센트를 할당하라는 가이드라인은 잘못됨
- 경우에 따라서 레코드 버퍼의 메모리 사용될 수 있음
- 128mb의 청크를 단위로 조정 가능

#### 버퍼 풀의 구조

