---
title: RealMySql 8.0
summary: 
date: 2025-02-27 10:17:43 +0900
lastmod: 2025-02-27 14:51:40 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## 4장아키텍처
---


### MySQL 엔진 관련
#### 기본
- 핸들러, 엔진, 스토리지엔진, 하드웨어로 이루어짐
- 스레딩: 포어그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드
  - MyISAM은 클라이언트스레드가 쓰기 작업까지
- 메모리: 글로벌영역과 클라이언트 로컬
  - 글로벌 : 테이블 캐시, 버퍼풀, 해시인덱스, 리두로그 버퍼
  - 로컬 : 커넥션, 정렬버퍼, 조인 버퍼

> 각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

#### 쿼리 실행 구조

> SQL 요청 -> 
> (MySQL 엔진에서) 쿼리파서 -> 전처리기 -> 옵티마이저(쿼리 변환, 비용 최적화, 실행 계획 수립) -> 쿼리실행기
> (스토리지 엔진에서 실행)

- 쿼리 파서
  - 사용자 요청 쿼리를 토큰으로 분리해 트리구조로 만듦, 문법체크도 여기서
- 전처리기
  - 문장의 구조적인 문제점 파악, 객체 존재여부나 접근권한 체크도 여기서
- 옵티마이저
  - 가장 저렴한 비용의 실행계획 결정
> 이 책에서는 옵티마이저가 선택하는 내용을 설명할 것이며, 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있게
> 유도하는가를 알려줄 것이다.

#### 실행 엔진
> 만들어진 계획대로 각 핸들러에서 받은 요청을 다른 핸들러 요청의 입력으로 연결하는 역할

#### 그 외
각각의 세부 주제로 잡는게 좋은 것 같다. 무튼 아래와 같은 정보들이 엔진에서 지원한다.
- 복제
- 쿼리 캐시
- 스레드 풀
- 트랜잭션 지원 메타데이터


### InnoDB 스토리지 엔진 아키텍처
> 거의 유일하게 레코드 기반의 잠금을 제공한다.

#### 프라이머리 키에 의한 클러스터링
- 프라이머리 키 값의 순서대로 디스크에 저장됨
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용(MyISAM에서는 실제 물리적인 주소)

#### 외래 키 지원
- 실제 엔진레벨에서의 외래키 제약 조건에 대한 지원을 함

#### MVCC
> 일반적으로 레코드 레벨의 트랜잭션을 지원 하는 dbms가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공하는데 목적이 있따.

- 언두로그를 통해 지원
- multi version이란 하나의 레코드에 대해 여러개의 버전이 동시 관리된다는 것
- 구문 실행과 동시에 (커밋 여부와 관련 없이) innodb버퍼 풀에 반영, 디스크에는 반영여부가 확실치 않음
- 이 시점에서의 조회는 격리레벨에 따라 다르다. 크게 살펴보면
- `READ_UNCOMMITED` : 버퍼에서 반환한다.
- `READ_COMMITED` 이상의 격리 레벨 : 커밋 전이면 언두로그에서 반환한다.
- 즉 innodb버퍼풀-디스크, 언두로그까지 멀티버전이 있는 것

#### 잠금 없는 일관된 읽기 (Non-Locking Consitent Read)
- 간단하게 요약하면 읽기에 대한 락을 걸지 않고, 격리레벨설정에 따라서, 읽는 시점에 적절한 데이터를 읽어감

#### 자동 데드락 감지
- 잠금 대기 목록을 그래프 형태로 관리
- 별도의 스레드가 해당 목록을 토대로 데드락을 감지
- 교착상태의 트랜잭션중 하나를 종료
- 트랜잭션 언두 로그를 기준으로(경제적인 관점에서) 강제종료할 트랜잭션을 선택
- 참고로 상위 레이어의 mysql엔진에서 테이블잠금이 된경우 데드락 판단이 불확실 할 수 있는데, 시스템 변수로 방지할수있음 `innodb_table_locks`
- 기본적으로 데드락 감지 스레드 자체의 부하나 리소스가 크지 않지만, 트랜잭션이 많아지면 부담이됨, 그리고 심지어는 위의 `잠금 대기 목록`에도 락을 걸기에, 다른 서비스 쿼리의 트랜잭션에도 지연을 유발함.
- 그래서 `innodb_deadlock_detect`를 끄고, `innodb_lock_wait_timeout`을 통해서 락시간을 통해 트랜잭션을 언두하는 방식으로 운영하기도 함.
  - 책에서 나온 내용은 아니지만, 아마도 교착상태의 트랜잭션을 경제적으로 종료하는것은 아니라, 결과적인 부화는 더 안좋을 수 있을것 같다. (상황에 따라서)


#### 자동화된 장애 복구
- 일반적으로 매우 견고한 장애복구 시스템이 있음
- `innodb_force_recovery` : 장애가 나서 시작이 안되는경우 사용
- 위의 변수 설정으로 시작하면, 가능한 만큼 덤프로 데이터를 백업하고, 그 데이터로 테이블 다시 생성하는것이 좋다.
  - 1=SRV_FORCE_IGNORE_CORRUPT : 인덱스나 테이블의 손상을 무시하고 시작
  - 2=SRV_FORCE_NO_BACKUP : 메인스레드를 시작하지 않고 서버 시작, 메인스레드가 언두데이터 삭제하는과정에서 장애가 반복된다면 이거 사용
  - 3=SRV_FORCE_NO_TRX_UNDO : 커밋되지 않고 종료된 트랜잭션의 롤백을 막음
  - 4=SRV_FORCE_NO_IBUF_MERGE : 인서트 버퍼의 내용 무시하고 시작
  - 5=SRV_FORCE_NO_UNDO_LOG_SCAN : 언두로그를 스캔하지 않고, 장애시점의 트랜잭션을 커밋한것처럼 동작
  - 6=SRV_FORCE_NO_LOG_REDO : 마지막 체크포인트로 시작

> 이래도 안된다면, db백업과 바이너리를 통해서..

### InnoDB 버퍼 풀
> InnoDB 스토리지 엔진에서 가장 핵심적인 부분, 디스크 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.
> 쓰기작업을 지연시켜 일괄 작업으로 처리해주는 버퍼 역할도 같이 한다.

#### 버퍼 풀의 크기 설정
- os의 80퍼센트를 할당하라는 가이드라인은 잘못됨
- 경우에 따라서 레코드 버퍼의 메모리 사용될 수 있음
- 128mb의 청크를 단위로 조정 가능

#### 버퍼 풀의 구조
> 거대한 메모리를 페이지크기로 쪼개서 관리한다. 크게 LRU 리스트, Flush 리스트, Free 리스트를 관리한다.
- `LRU 리스트`
  - 조금 더 정확하게는, LRU와 MRU 리스트가 결합된 형태
  - 각각 New 서브리스트와(MRU), Old 서브리스트(LRU)로 관리한다.
  - 새로운 페이지는 New 리스트의 tail과 Old 리스트의 head의 접점에 삽입된다.
  - 디스크 읽기를 최소화 하기 위해서 사용된다.
- InnoDB의 데이터 찾는 과정
  1. 필요한 레코드가 저장된 페이지가 버퍼 풀에 있는지 검사. (InnoDB 어댑티브 해시 인덱스로 페이지 찾기, 해당 테이블의 인덱스를 이용해 버퍼 풀에서 페이지 검색, 버퍼 풀에서 이미 페이지가 있다면 해당 페이지의 포인터를 New서브리스트 방향으로 승급)
  2. 디스크에서 필요한 데이터페이지를 버퍼 풀에 적재, 적재한 이후에 LRU 헤드 부분에 추가
  3. 버퍼 풀에 상주하는 페이지는 최근 접근 시간을 기준으로 age가 부여됨
  4. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
  5. 즉 자주 사용됐다면 MRU영역에서 오래 살아남고, 반대로는 LRU끝으로 밀려나서 메모리에서 해제됨
- `flush 리스트`
  - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리.
  - 읽은 상태에서 수정이 있다면 플러시 리스트에 오르고, 관리되다가 디스크에 기록됨
  - 변경이 되어 페이지의 데이터가 변경 되면 아까 본 리두 로그에 기록하는 (변경을) 과정이 일어남.
  - 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는것을 항상 보장하지는 않음
- `free 리스트`
  - 실제 데이터로 채워지지 않는 여유공간
  - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야하는 경우 사용됨

#### 버퍼 풀과 리두 로그
- 논리적으로 디스크의 모든 데이터를 메모리에 올릴 수 있는 상황이 아니라면, 버퍼풀을 늘리면 쿼리 성능은 빨라짐
- 근본적으로 따져보면 InnoDB 버퍼 풀은 성능 향상을 위해 두가지 관점으로 접근함 `데이터 캐시`, `버퍼링`
- 버퍼풀 늘리는건 전자에 관여
- 버퍼링을 늘리려면 버퍼풀과 리두 로그의 관계를 알아야 한다고 한다.
  - 버퍼풀은 클린페이지와 더티페이지(디스크에서 읽어온 이후 변경이 발생한 페이지) 모두를 가지고 있다.
  - 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용
  - 데이터 변경이 계속 발생하면 리두 로그파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어씌워짐
  - 그래서 리두 로그파일에서 재사용가능한 공간과 불가능한 공간을 구분해서 관리해야하는데, 불가능한공간을 `활성 리두 로그`라고 한다.
  - 기본적으로 리두 로그 파일은 순환되어 재사용되는데, 매 기록시마다 로그포지션이 증가 이것을 LSN이라고 한다.
  - 그리고 InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼풀의 더티페이지를 디스크로 동기화하는데
  - 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점
  - 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기에 체크포인트와 무관
  - 그래서 가장 최근 체크포인트의 lsn과 마지막 리두 로그 엔트리의 lsn의 차이를 체크포인트에이지라고 함
  - 결론적으로 리두 로그 파일 크기가 적다면 너무 적은 더티 페이지의 제한때문에 쓰기가 자주일어나게 되고, 이러면 버퍼풀의 물리적인 메모리가 높아봐야 쓰기 버퍼링의 효과는 전혀 없다.
  - 반대로 리두 로그 파일 크기가 전체 버퍼풀에 비해 터무니 없이 높다면 단 한 순간에 너무 큰 디스크 쓰기가 일어나게 된다.

#### 버퍼 풀 플러시
- 더티페이지들의 디스크 동기화를 위해 다음과 같은 두가지의 기능을 백그라운드에서 실행하다.
- 플러시 리스트 플러시
  - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다.
  - 그러려면 당연히 더티페이지가 먼저 디스크로 동기화 돼야 한다.
  - 그러기 위해서 flush list flush 함수를 호출해서 이를 수행한다.
  - `innodb_page_cleaners` : 더티페이지를 디스크로 동기화하는 클리너 스레드의 갯수
  - `innodb_buffer_pool_instances` : 여러개의 버퍼풀 인스턴스를 동시에 사용하는데 그 갯수 여기서 언급된 것은 클리너 스레드와 갯수를 자동적으로 맞춰주는게 디폴트로 되어있으며 굳이 변경할 이유가 없다는 언급과 함께
  - `innodb_max_dirty_pages_pct` : 버퍼풀에서 더티페이지가 차지할 수 있는 비율
  - `innodb_max_dirty_pages_lwm` : 쓰기 폭발 (Disk IO Burst)을 대비하여 특정 비율 이상인경우 주기적으로 쓰기를 하도록 설정하는 퍼센테이지
  - 그외에도 capacity와 같은 값들이 있는데, 사실 여기 나머지 세세한 설정들은 hdd를 쓰던 시절 치명적이던 disk io를 줄이려고 한 노력에 더 가까워서 정말 예민하지 않으면 안건들여도 될 것 같다.


