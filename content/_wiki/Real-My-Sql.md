---
title: RealMySql 8.0
summary: 
date: 2025-02-27 10:17:43 +0900
lastmod: 2025-02-27 16:34:31 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## 4장아키텍처
---


### MySQL 엔진 관련
#### 기본
- 핸들러, 엔진, 스토리지엔진, 하드웨어로 이루어짐
- 스레딩: 포어그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드
  - MyISAM은 클라이언트스레드가 쓰기 작업까지
- 메모리: 글로벌영역과 클라이언트 로컬
  - 글로벌 : 테이블 캐시, 버퍼풀, 해시인덱스, 리두로그 버퍼
  - 로컬 : 커넥션, 정렬버퍼, 조인 버퍼

> 각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

#### 쿼리 실행 구조

> SQL 요청 -> 
> (MySQL 엔진에서) 쿼리파서 -> 전처리기 -> 옵티마이저(쿼리 변환, 비용 최적화, 실행 계획 수립) -> 쿼리실행기
> (스토리지 엔진에서 실행)

- 쿼리 파서
  - 사용자 요청 쿼리를 토큰으로 분리해 트리구조로 만듦, 문법체크도 여기서
- 전처리기
  - 문장의 구조적인 문제점 파악, 객체 존재여부나 접근권한 체크도 여기서
- 옵티마이저
  - 가장 저렴한 비용의 실행계획 결정
> 이 책에서는 옵티마이저가 선택하는 내용을 설명할 것이며, 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있게
> 유도하는가를 알려줄 것이다.

#### 실행 엔진
> 만들어진 계획대로 각 핸들러에서 받은 요청을 다른 핸들러 요청의 입력으로 연결하는 역할

#### 그 외
각각의 세부 주제로 잡는게 좋은 것 같다. 무튼 아래와 같은 정보들이 엔진에서 지원한다.
- 복제
- 쿼리 캐시
- 스레드 풀
- 트랜잭션 지원 메타데이터


### InnoDB 스토리지 엔진 아키텍처
> 거의 유일하게 레코드 기반의 잠금을 제공한다.

#### 프라이머리 키에 의한 클러스터링
- 프라이머리 키 값의 순서대로 디스크에 저장됨
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용(MyISAM에서는 실제 물리적인 주소)

#### 외래 키 지원
- 실제 엔진레벨에서의 외래키 제약 조건에 대한 지원을 함

#### MVCC
> 일반적으로 레코드 레벨의 트랜잭션을 지원 하는 dbms가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공하는데 목적이 있따.

- 언두로그를 통해 지원
- multi version이란 하나의 레코드에 대해 여러개의 버전이 동시 관리된다는 것
- 구문 실행과 동시에 (커밋 여부와 관련 없이) innodb버퍼 풀에 반영, 디스크에는 반영여부가 확실치 않음
- 이 시점에서의 조회는 격리레벨에 따라 다르다. 크게 살펴보면
- `READ_UNCOMMITED` : 버퍼에서 반환한다.
- `READ_COMMITED` 이상의 격리 레벨 : 커밋 전이면 언두로그에서 반환한다.
- 즉 innodb버퍼풀-디스크, 언두로그까지 멀티버전이 있는 것

#### 잠금 없는 일관된 읽기 (Non-Locking Consitent Read)
- 간단하게 요약하면 읽기에 대한 락을 걸지 않고, 격리레벨설정에 따라서, 읽는 시점에 적절한 데이터를 읽어감

#### 자동 데드락 감지
- 잠금 대기 목록을 그래프 형태로 관리
- 별도의 스레드가 해당 목록을 토대로 데드락을 감지
- 교착상태의 트랜잭션중 하나를 종료
- 트랜잭션 언두 로그를 기준으로(경제적인 관점에서) 강제종료할 트랜잭션을 선택
- 참고로 상위 레이어의 mysql엔진에서 테이블잠금이 된경우 데드락 판단이 불확실 할 수 있는데, 시스템 변수로 방지할수있음 `innodb_table_locks`
- 기본적으로 데드락 감지 스레드 자체의 부하나 리소스가 크지 않지만, 트랜잭션이 많아지면 부담이됨, 그리고 심지어는 위의 `잠금 대기 목록`에도 락을 걸기에, 다른 서비스 쿼리의 트랜잭션에도 지연을 유발함.
- 그래서 `innodb_deadlock_detect`를 끄고, `innodb_lock_wait_timeout`을 통해서 락시간을 통해 트랜잭션을 언두하는 방식으로 운영하기도 함.
  - 책에서 나온 내용은 아니지만, 아마도 교착상태의 트랜잭션을 경제적으로 종료하는것은 아니라, 결과적인 부화는 더 안좋을 수 있을것 같다. (상황에 따라서)


#### 자동화된 장애 복구
- 일반적으로 매우 견고한 장애복구 시스템이 있음
- `innodb_force_recovery` : 장애가 나서 시작이 안되는경우 사용
- 위의 변수 설정으로 시작하면, 가능한 만큼 덤프로 데이터를 백업하고, 그 데이터로 테이블 다시 생성하는것이 좋다.
  - 1=SRV_FORCE_IGNORE_CORRUPT : 인덱스나 테이블의 손상을 무시하고 시작
  - 2=SRV_FORCE_NO_BACKUP : 메인스레드를 시작하지 않고 서버 시작, 메인스레드가 언두데이터 삭제하는과정에서 장애가 반복된다면 이거 사용
  - 3=SRV_FORCE_NO_TRX_UNDO : 커밋되지 않고 종료된 트랜잭션의 롤백을 막음
  - 4=SRV_FORCE_NO_IBUF_MERGE : 인서트 버퍼의 내용 무시하고 시작
  - 5=SRV_FORCE_NO_UNDO_LOG_SCAN : 언두로그를 스캔하지 않고, 장애시점의 트랜잭션을 커밋한것처럼 동작
  - 6=SRV_FORCE_NO_LOG_REDO : 마지막 체크포인트로 시작

> 이래도 안된다면, db백업과 바이너리를 통해서..

### InnoDB 버퍼 풀
> InnoDB 스토리지 엔진에서 가장 핵심적인 부분, 디스크 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.
> 쓰기작업을 지연시켜 일괄 작업으로 처리해주는 버퍼 역할도 같이 한다.

#### 버퍼 풀의 크기 설정
- os의 80퍼센트를 할당하라는 가이드라인은 잘못됨
- 경우에 따라서 레코드 버퍼의 메모리 사용될 수 있음
- 128mb의 청크를 단위로 조정 가능

#### 버퍼 풀의 구조
> 거대한 메모리를 페이지크기로 쪼개서 관리한다. 크게 LRU 리스트, Flush 리스트, Free 리스트를 관리한다.
- `LRU 리스트`
  - 조금 더 정확하게는, LRU와 MRU 리스트가 결합된 형태
  - 각각 New 서브리스트와(MRU), Old 서브리스트(LRU)로 관리한다.
  - 새로운 페이지는 New 리스트의 tail과 Old 리스트의 head의 접점에 삽입된다.
  - 디스크 읽기를 최소화 하기 위해서 사용된다.
- InnoDB의 데이터 찾는 과정
  1. 필요한 레코드가 저장된 페이지가 버퍼 풀에 있는지 검사. (InnoDB 어댑티브 해시 인덱스로 페이지 찾기, 해당 테이블의 인덱스를 이용해 버퍼 풀에서 페이지 검색, 버퍼 풀에서 이미 페이지가 있다면 해당 페이지의 포인터를 New서브리스트 방향으로 승급)
  2. 디스크에서 필요한 데이터페이지를 버퍼 풀에 적재, 적재한 이후에 LRU 헤드 부분에 추가
  3. 버퍼 풀에 상주하는 페이지는 최근 접근 시간을 기준으로 age가 부여됨
  4. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
  5. 즉 자주 사용됐다면 MRU영역에서 오래 살아남고, 반대로는 LRU끝으로 밀려나서 메모리에서 해제됨
- `flush 리스트`
  - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리.
  - 읽은 상태에서 수정이 있다면 플러시 리스트에 오르고, 관리되다가 디스크에 기록됨
  - 변경이 되어 페이지의 데이터가 변경 되면 아까 본 리두 로그에 기록하는 (변경을) 과정이 일어남.
  - 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는것을 항상 보장하지는 않음
- `free 리스트`
  - 실제 데이터로 채워지지 않는 여유공간
  - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야하는 경우 사용됨

#### 버퍼 풀과 리두 로그
- 논리적으로 디스크의 모든 데이터를 메모리에 올릴 수 있는 상황이 아니라면, 버퍼풀을 늘리면 쿼리 성능은 빨라짐
- 근본적으로 따져보면 InnoDB 버퍼 풀은 성능 향상을 위해 두가지 관점으로 접근함 `데이터 캐시`, `버퍼링`
- 버퍼풀 늘리는건 전자에 관여
- 버퍼링을 늘리려면 버퍼풀과 리두 로그의 관계를 알아야 한다고 한다.
  - 버퍼풀은 클린페이지와 더티페이지(디스크에서 읽어온 이후 변경이 발생한 페이지) 모두를 가지고 있다.
  - 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용
  - 데이터 변경이 계속 발생하면 리두 로그파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어씌워짐
  - 그래서 리두 로그파일에서 재사용가능한 공간과 불가능한 공간을 구분해서 관리해야하는데, 불가능한공간을 `활성 리두 로그`라고 한다.
  - 기본적으로 리두 로그 파일은 순환되어 재사용되는데, 매 기록시마다 로그포지션이 증가 이것을 LSN이라고 한다.
  - 그리고 InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼풀의 더티페이지를 디스크로 동기화하는데
  - 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점
  - 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기에 체크포인트와 무관
  - 그래서 가장 최근 체크포인트의 lsn과 마지막 리두 로그 엔트리의 lsn의 차이를 체크포인트에이지라고 함
  - 결론적으로 리두 로그 파일 크기가 적다면 너무 적은 더티 페이지의 제한때문에 쓰기가 자주일어나게 되고, 이러면 버퍼풀의 물리적인 메모리가 높아봐야 쓰기 버퍼링의 효과는 전혀 없다.
  - 반대로 리두 로그 파일 크기가 전체 버퍼풀에 비해 터무니 없이 높다면 단 한 순간에 너무 큰 디스크 쓰기가 일어나게 된다.

#### 버퍼 풀 플러시
- 더티페이지들의 디스크 동기화를 위해 다음과 같은 두가지의 기능을 백그라운드에서 실행하다.
- 플러시 리스트 플러시
  - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다.
  - 그러려면 당연히 더티페이지가 먼저 디스크로 동기화 돼야 한다.
  - 그러기 위해서 flush list flush 함수를 호출해서 이를 수행한다.
  - `innodb_page_cleaners` : 더티페이지를 디스크로 동기화하는 클리너 스레드의 갯수
  - `innodb_buffer_pool_instances` : 여러개의 버퍼풀 인스턴스를 동시에 사용하는데 그 갯수 여기서 언급된 것은 클리너 스레드와 갯수를 자동적으로 맞춰주는게 디폴트로 되어있으며 굳이 변경할 이유가 없다는 언급과 함께
  - `innodb_max_dirty_pages_pct` : 버퍼풀에서 더티페이지가 차지할 수 있는 비율
  - `innodb_max_dirty_pages_lwm` : 쓰기 폭발 (Disk IO Burst)을 대비하여 특정 비율 이상인경우 주기적으로 쓰기를 하도록 설정하는 퍼센테이지
  - 그외에도 capacity와 같은 값들이 있는데, 사실 여기 나머지 세세한 설정들은 hdd를 쓰던 시절 치명적이던 disk io를 줄이려고 한 노력에 더 가까워서 정말 예민하지 않으면 안 건들어도 될것 같다.
- LRU 리스트 플러시
	- 프리페이지로 옮긴다, 정도 제외하곤 큰 차이 없다.

#### 버퍼 풀 상태 백업 및 복구
- 잘 메모리 즉 버퍼풀에 올라간상태(warmed up)의 쿼리는 그렇지 않은 경우 대비 수십배 빠름
- 예전에는 이부분에 대한 관리가 잘 안되어 서비스전 풀테이블 스캔을 유발시켜서 워밍업을 매뉴얼하게 수행했음
- 지금은 그럴 필요 없이 버퍼 풀 덤프를 통해서 재실행되어도 버퍼가 채워져 있도록 관리

#### 버퍼 풀의 적재 내용 확인
- `information schema` -> `innodb_buffer_page` 테이블에서 버퍼풀 확인가능
```sql
select
	it.name table_name,
	ii.name index_name,
	ici.n_cached_pages n_cached_pages
from information_schema.innodb_tables it
	inner join information_schema.innodb_indexes ii on ii.table_id = it.table_id
	inner join information_schema.innodb_cached_indexes ici on ici.index_id = ii.index_id
where it.name=concat('employees','/','employess')
;
```

#### 언두 로그
- 주 사용처는 위에서 언급한 것처럼 트랜잭션보장과 격리수준 보장
- 쿼리 실행 시점에 작성된다.(트랜잭션을 위해)
#### 언두 로그 레코드 모니터링
- 일단 관리에 비용이 많이 든다. 1억건의 데이터를 날리거나 변경하는 dml이면? 
- 그리고 트랜잭션의 관리가 안된다면, 언두로그가 다른트랜잭션의 영향을 받아 언두로그가 삭제가 안 될 수 있다.
- 트랜잭션 A가 실행되는 동안 B와 C가 dml 트랜잭션을 날린다면, b와 c의 Undo 로그는 삭제되지 않음.
- 이유는 트랜잭션 A가 여전히 해당 데이터를 읽을 가능성이 있기 때문.
- 8.0 이후 언두로그가 개선되어 언두로그를 순차적으로 사용하며 디스크 공간을 줄이는게 가능해졌음
- 참고로 테이블스페이스 인 만큼 이노디비 버퍼풀에 올라가기도 하지만 로그자체는 디스크

#### 체인지 버퍼

- 체인지 버퍼는 인덱스 페이지의 변경 내용을 디스크가 아닌 메모리에 임시 저장하는 공간  
- InnoDB 버퍼 풀(Buffer Pool)의 일부로 관리되며 보조 인덱스(Secondary Index) 변경 사항을 저장  
- 데이터 페이지를 즉시 디스크에 기록하지 않고 변경 사항을 누적하여 성능 최적화  
- 데이터가 조회될 때 디스크와 동기화(merge)되며, 일정 주기마다 백그라운드 스레드가 자동으로 병합  
- 동작 예시
	1. 사용자가 보조 인덱스에 대한 DML(INSERT, DELETE, UPDATE)을 실행  
	2. 변경된 인덱스 페이지가 버퍼 풀에 없다면, 체인지 버퍼에 변경 사항을 기록  
	3. 이후 해당 인덱스 페이지가 조회되면 체인지 버퍼에서 변경 사항을 적용(merge)  
	4. 백그라운드 스레드가 일정 시간마다 디스크에 반영  
- `innodb_change_buffer_max_size` 설정을 통해 크기 조절 가능  
- 트랜잭션이 롤백되면 체인지 버퍼도 롤백됨  
- 기본 키(Primary Key)에는 적용되지 않으며 보조 인덱스에만 사용  
- 자주 변경되는 보조 인덱스가 많은 테이블에서 성능 최적화 효과가 큼


#### 리두 로그
- 리두 로그는 트랜잭션 변경 내용을 디스크에 영구 반영하기 전에 로그로 기록하는 구조  
- 시스템 장애 발생 시 리두 로그를 이용해 미완료된 변경 사항을 복구할 수 있음  
- InnoDB는 변경 사항을 먼저 로그 파일에 기록한 후 데이터 페이지에 반영  
- 리두 로그를 통해 MySQL이 ACID 특성을 보장하며, COMMIT된 데이터의 영속성을 유지  

- 사용자가 DML(INSERT, UPDATE, DELETE)을 실행하면 변경된 데이터가 InnoDB 버퍼 풀에 반영됨  
- 변경된 내용이 리두 로그 버퍼에 기록된 후, 일정 조건이 충족되거나 COMMIT 발생 시 리두 로그 버퍼의 내용을 디스크에 순차적으로 기록  
- 이후 InnoDB의 백그라운드 플러시 스레드가 변경된 데이터를 실제 데이터 파일로 반영  
- 시스템 장애 발생 시 리두 로그를 사용하여 변경 사항을 복구  

- 리두 로그 파일은 ib_logfile0, ib_logfile1 등의 파일로 저장되며 순환 방식으로 동작  
- 특정 크기에 도달하면 덮어쓰기 방식으로 재사용  
- innodb_log_files_in_group 설정을 통해 다중 로그 파일을 구성할 수 있음  

- innodb_log_file_size는 각 리두 로그 파일의 크기를 설정하며, 크기가 너무 작으면 체크포인트가 자주 발생하여 성능이 저하될 수 있음  
- 크기가 너무 크면 복구 시간이 길어질 수 있음  
- innodb_flush_log_at_trx_commit 값에 따라 리두 로그의 디스크 반영 시점이 조정됨  
- 0으로 설정하면 1초마다 리두 로그를 디스크에 기록하여 성능이 향상되지만 장애 발생 시 데이터가 유실될 수 있음  
- 1은 매 트랜잭션 COMMIT 시 리두 로그를 디스크에 기록하여 안정성을 보장함  
- 2는 매 COMMIT 시 OS 버퍼에 기록하고, 1초마다 디스크에 기록하여 성능과 안정성의 균형을 맞춤  

- WAL 기법을 사용하여 데이터를 변경하기 전에 먼저 로그를 기록하여 장애 발생 시 복구가 가능함  
- 로그 버퍼는 리두 로그가 먼저 저장되는 메모리 공간으로 이후 디스크로 플러시됨  
- 체크포인트는 리두 로그 크기 초과를 방지하기 위해 특정 시점의 변경 사항을 데이터 파일에 반영하는 과정  
- 리두 로그 파일은 순환 구조이므로 사용된 로그는 체크포인트 이후 덮어쓰기됨  

- 트랜잭션 안전성을 보장하며 장애 발생 시 빠른 복구가 가능함  
- 데이터 페이지 변경이 비동기적으로 디스크에 기록되므로 성능이 향상됨  
- 순차적인 로그 쓰기로 인해 디스크 I/O 부하가 감소함  
- 리두 로그가 가득 차면 새로운 트랜잭션 처리가 지연될 수 있으므로 적절한 크기 설정이 필요함  

#### 어댑티브 해시 인덱스
- 자주 사용되는 페이지에 nnodb엔진이 직접 생성하는 인덱스
- b+ 트리는 종단노드까지 가야 레코드가 있으니까 이걸 그냥 해쉬로 최적화시킴
- 해쉬값의 키로는 인덱스 고유값 + 인덱스 실제 키값 을 씀
- 예전 버전까지는 어댑티브 해쉬 인덱스는 하나의 메모리 객체인 이유로 어댑티브 해시 인덱스의 경합이 심했다 그래서 8.0부터는 내부 잠금 경합을 줄이기위해 어댑티브 해쉬 인덱스의 파티션기능을제공한다 (대충 이것도 하나라 경합이 심했는데 파티션을 해준다는 이야기)
- 도움 잘되는 경우
	- 디스크데이터가 버퍼풀이랑 비슷한경우
	- 동등조건 검색동등비교와 in연산 많은경우
	- 쿼리가 데이터중에서 일부데이터에 집중되는경우
- 도움 안되는 경우
	- 디스크읽기가 많은 경우
	- 특정패턴의 쿼리가 많은경우 (join like)
	- 매우 큰 데이터를 가진 테이블레ㅔ코드를 폭넓게 읽는 경우
	- 

## 트랜잭션과 잠금
