---
title: Week-01 📚
summary: 
date: 2024-04-21 14:26:30 +0900
lastmod: 2024-04-21 14:26:30 +0900
tags: 
categories: 
description: 
showToc: true
---

## 01 장 - 이 책에 대한 대화

- 아주 간단한 이 책에 대한 소개를 하는 챕터이다.
 
- 두 장으로 이루어져 있고, 이 책에서 자주 나오게 되는 교수와 학생의 대화 형식으로 이루어져 있다.

- 핵심적인 아이디어를 요약하면 다음과 같다. 
  - 리처드 파인만의 물리학 아주 쉬운 6가지 이야기라는 강의 노트가 있다.
  - 물리학이 6만큼 어려우면, 운영체제는 3만큼 어렵기 때문에, 이 책의 제목이 "운영체제 아주 쉬운 세 가지 이야기"이다.
  - 이 책은 운영체제에 대한 이야기를 3가지로 나누어서 설명한다. `가상화`, `병행성`, `영속성`

## 02 장 - 운영체제 개요

> 이 책에서 다루게 될 내용이지만 아주 간단하게 약식으로 설명하는 글이 있어 가져왔다.
> c/cpp를 공부할 때 이분의 블로그와 강의자료를 들었는데 상대적으로 최근에 업로드된 문서이다.
> [내가 c언어를 배우기 전에 알았다면 좋았을 것들](https://modoocode.com/315)

- 프로그램은 명령어를 실행하는 아주 단순한 일을 한다.

- 프로세서는 명렁어를 반입(fetch)하고, 디코딩(decoding)하고, 실행(execute)하는 일을 한다.

- 그리고 프로그램을 쉽게 실행하고, 프로그램간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할 수 있는 `소프트웨어`가 `운영체제`이다.

- 운영체제는 앞에서 언급한 일을 하기 위해서 `Virtualization`이라는 기법을 사용한다.

- 실제 프로세서, 메모리, 디스크 같은 물리적인 자원을 이용해서 일반적이고, 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.

- 그래서 운영체제를 가상머신이라고 하기도 한다.

- 가상화를 이용해서 실제 사용자들이 해당 자원을 접근 할 수 있는 API를 제공하며, Application이 사용 할 수 있는 시스템콜을 제공한다.


### 02.1 CPU 가상화

> **핵심 질문 : 자원을 어떻게 가상화 시키는가?**

- 운영체제가 자원을 가상화 시켜서 사용하면 편리한건 너무 당연하기 때문에, 이러한 문제는 질문이 될 수 없다.

- 이것을 어떻게, 어떠한 기법과 정책으로, 어떻게 효율적으로, 어떠한 하드웨어 지원이 필요한지 와 같은 질문이 중요하다.

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

void Spin(int howlong) {
  double t = GetTime();
  while ((GetTime() - t) < (double)howlong)
    ; // do nothing in loop
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    printf("Usage: CPU <string>\n");
    exit(-1);
  }
  char *str = argv[1];
  while (1) {
    Spin(1);
    printf("%s\n", str);
  }
  return 0;
}
```

- 위 코드는 CPU를 사용하는 프로그램이다. 이 프로그램은 인자로 받은 문자열을 1초에 한 번 영원히 출력한다.

```shell
$ gcc -o CPU CPU.c
$ ./CPU A & ; ./CPU B & ; ./CPU C & ;
```

- 이렇게 실행시키면 마치 CPU가 세 개인 것 처럼 ABC가 번갈아가며 출력된다.

- 이렇게 CPU를 가상화 시키는 것은 유용하지만, 새로운 문제가 발생한다. 예를 들어 동일한 시점에 실행되어야 하는 프로그램이 많아지면, 어떠한 프로그램이 실행되어야 하는가 와 같은 이슈가 생긴다.

- 이러한 문제를 해결하기 위해서 필요한 정책 같은 것들이 있는데, 이번 장에서는 이러한 정책들을 다루게 된다.(즉 자원 관리자로서의 운영체제 역할에 대해 다룬다.)

### 02.2 메모리 가상화

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>

double GetTime() {
  struct timeval t;
  int rc = gettimeofday(&t, NULL);
  assert(rc == 0);
  return (double)t.tv_sec + (double)t.tv_usec / 1e6;
}



void Spin(int howlong) {
  double t = GetTime();
  while ((GetTime() - t) < (double)howlong)
    ; // do nothing in loop
}

int main(int argc, char *argv[]) {
  int *p = malloc(sizeof(int)); // 메모리를 한당 받는다. 
  assert(p != NULL);
  printf("(%d) address pointed to by p: %p\n", getpid(), p); // process의 id를 출력한다.
  *p = 0;                                                    // 할당받은 메모리에 0을 넣는다. 
  while (1) {
    Spin(1);
    *p = *p + 1;
    printf("(%d) p: %d\n", getpid(), *p); // process의 id와 p의 값을 출력한다.
  }
}

```

- 위 코드는 메모리를 사용하는 프로그램이다. 이 프로그램은 메모리를 할당 받고, 1초에 한 번씩 메모리에 있는 값을 1씩 증가시킨다.

- 그러면서 주석에 있는 내용처럼 process의 id와 메모리 주소를 출력한다.

다수의 프로그램을 동시에 실행시킨 결과는 다음과 같다.

```shell
$ gcc -o MEM MEM.c
$ ./MEM & ; ./MEM & ; ./MEM & ;

[1] 7890
[2] 7891
[3] 7892

(7890) memory address of p: 0x200000000
(7891) memory address of p: 0x200000000
(7892) memory address of p: 0x200000000
(7890) p: 0
(7891) p: 0
(7892) p: 0
(7890) p: 1
(7891) p: 1
(7892) p: 1
(7890) p: 2
(7891) p: 2
(7892) p: 2
(7890) p: 3
(7891) p: 3
(7892) p: 3
...
```
- 주목해야 할 결과값은 메모리 주소이다. 프로그램이 실행되는 메모리 주소는 모두 같다.

- 이 역시 메모리 가상화의 결과이다. 프로그램은 자신만의 메모리를 가지고 있다고 생각하지만, 실제로는 운영체제가 제공하는 가상 메모리를 사용하고 있다.

- 이와 같은 메모리의 가상화 역시 이 책에서 다루게 된다.


### 02.3 병행성 (Concurrency)

- 프로그램이 한 번에 많은 일을 하려 할 때 (동시에) 발생하는 문제를 다룬다.

- 사실 운영체제는 한 프로세스 실행, 다음 프로세스 실행, 다음 프로세스 실행, ... 이런식으로 프로세스를 번갈아가며 실행하는데 이 때 발생하는 문제들이 생긴다.

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

volatile int counter = 0;
int loops;

// loop 횟수만큼 counter를 증가시키는 함수
void *worker(void *arg) {
  int i;
  for (i = 0; i < loops; i++) {
    counter++;
  }
  return NULL;
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "usage: threads <value>\n");
    exit(1);
  }
  loops = atoi(argv[1]); // 인자로 받은 값을 loops에 저장한다.

  pthread_t p1, p2;
  printf("Initial value : %d\n", counter);
  
  double t1 = GetTime();
  pthread_create(&p1, NULL, worker, NULL); // thread p1 worker 함수 실행
  pthread_create(&p2, NULL, worker, NULL); // thread p2 worker 함수 실행
  pthread_join(p1, NULL);
  pthread_join(p2, NULL);
  double t2 = GetTime();
  printf("Final value : %d\n", counter);
  printf("Time : %f\n", t2 - t1);
  return 0;
}
```

- 이 코드는 복잡해보이지만 전혀 그렇지 않다. thread 2개를 생성하고, 각각의 thread에서 worker 함수를 실행한다.

- worker 함수는 인자로 받은 loop 횟수만큼 counter를 증가시킨다.

- 실제 실행 결과는 다음과 같다.

```shell
$ gcc -o THREAD THREAD.c -lpthread
$ ./THREAD 1000

Initial value : 0
Final value : 2000
Time : 0.000000
```

- 일단 값이 2000이 나왔다. 이는 2개의 thread가 각각 1000번씩 counter를 증가시켰기 때문이다.

- 더 많은 횟수로 실행한 결과는 다음과 같다.

```shell
$ ./THREAD 100000

Initial value : 0
Final value : 143012
Time : 0.000000
```

- 이번에는 143012가 나왔다. 인자 * 스레드의 개수 만큼 counter가 증가해야 하는데 그렇지 않은 이유는 아래와 같다.

- 실제 카운터를 증가시키는 코드의 로직은 다음과 같다.
  - counter를 메모리에서 레지스터로 불러온다.
  - 레지스터에 1을 더한다.
  - 레지스터의 값을 메모리에 저장한다.

- 이 세가지 작업이 원자성을 가지지 않는다. 즉, 다른 스레드가 counter를 읽어가는 동안 다른 스레드가 counter를 증가시킬 수 있다.

- 이러한 문제가 Concurrency 문제이며, 이러한 문제를 해결하기 위한 방법들을 이 책에서 다룬다.

> **병행성의 핵심 질문 : 올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가**
> 같은 메모리 공간에 다수의 쓰레드가 동시에 실행단다고 할 때, 올바르게 동작하는 프로그램을 어떻게 잘성 할 수 있는가? 운영체제는 어떠한 기본 기법을 제공하는가, 하드웨어는 어떠한 지원을 제공하는가?
> 병행성 문제를 해결하기 위해 기본 기법들과 하드웨어 기능을을 어떻게 사용할 수 있는가?

### 02.4 영속성 (Persistence)

- RAM은 읽고 쓰기가 레지스터, 캐시에 비해서는 느리지만, 그래도 충분히 빠르다.

| 작업          | 시간 (현실 시간으로 환산) |
|---------------|------------------------|
| CPU 사이클    | 1초                    |
| L1 캐시 접근 | 2초                    |
| L2 캐시 접근 | 7초                    |
| L3 캐시 접근 | 1분                    |
| RAM 접근      | 4분                    |
| NVMe SSD 접근 | 17시간                 |
| 일반 SSD 접근 | 1.5일 ~ 4일            |
| 일반 하드디스크 접근 | 1 ~ 9달         |
| 서울 - 샌프란시스코 패킷 전송 시간 | 14년 |
출처 : [내가 c언어를 배우기 전에 알았다면 좋았을 것들](https://modoocode.com/315)

- 그러나 RAM은 전원이 꺼지면 모든 데이터가 사라진다. 

- 그래서 우리는 데이터를 영구적으로 저장할 수 있는 영속성을 구현하기 위해 하드웨어와 소프트웨어가 필요하다.

- 많이들 알고 있겠지만, 하드웨어는 I/O 장치 형태로 제공되며, 요즘은 주로 SSD를 사용한다.

- 디스크를 관리하는 운영체제 소프트웨어는 파일 시스템이라고 한다. (파일시스템은 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적으로 저장할 `책임`이 있다.)

- 영속성과 관련한 핵심 질문은 다음과 같다.

> **영속성의 핵심 질문 : 데이터를 영속적으로 저장하는 방법은 무엇인가**
> 파일 시스템은 데이터를 여속적으로 관리하는 운영체제의 일부분인다. 올바르게 동작하기 위해서는 어떤 기법이 필요할까? 이러한 작업 성능을 높이기 위해서 어떤 기법과 정책이 필요할까?
> 하드웨어와 소프트웨어가 실패하더라도 올바르게 동작하려면 어떻게 해야 할까?
 
```c
#include <unistd.h>
#include <assert.h>
#include <fcnt1.h>
#include <sys/file.h>

int main(int argc, char *argv[])
{
  int fd = open("tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); // 프로그램의 운영체제 첫 번째 호출(call)
  assert(fd > -1);
  int rc = write(fd, "hello world\n", 13); // 프로그램의 운영체제 두 번째 호출(call)
  close(fd); // 프로그램의 운영체제 세 번째 호출(call)
  assert(rc == 13);

  /**
    * 이 처럼 파일 시스템의 시스템 콜을 사용한다.
  */
  return 0;
}
```

- 이 코드는 파일 시스템을 사용하는 프로그램이다. 파일을 열고, 쓰고, 닫는 작업을 한다.

- 디스크를 접근해서 파일시스템으로 관리하고 시스템콜을 통해 파일을 생성하고, 쓰고, 닫아왔었다.

- 이러한 시스템콜은 표준화 되어있어서 마치 언어의 STL로 제공받는 것처럼 편리하지만,

- 실제로 내부에서 일어나는 일은 매우 복잡하다.

- 에를 들어 쓰기 지연시간동안 정전이 되었거나 고장이 났을 때, 기록 순서가 뒤바뀔 수 있고, 쓰려고 모였던 데이터는 이미 쓰였을 수도 있다.

- 이런 것들을 해결하기 위해 운영체제는 `journaling`, `copy-on-write`, `checksums` 등의 기법을 사용하는데, 이러한 것들도 같이 다루게 된다.


### 02.5 설계 목표

> 설계 목표라고 되어 있어서 흐름상 애매하지만,
> 위의 소주제에서 세가지를 보면서(가상화, 병행성, 영속성) 운영체제가 해야하는, 하고있는, 해야할 일을 알게 되었으니,
> 그것들을 어떻게 잘 수행할 수 있을지에 대한 설계 목표를 다룬다고 생각하면 될 것 같다.

- 첫 번째로, 가장 기본적인 목표는 `시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념들을 정의하는 것 즉 추상화`이다.
  - 이 추상화는 컴퓨터 과학에 있어서 모든 일에 대한 근간이다.
  - 추상화로 개념을 정의해가며 큰 프로그램을 이해하기 쉬운 작은 여러가지로 나눌 수 있다.
  - 예를 들어 논리 게이트를 몰라도 어셈블리어로 프로그램을 작성 할 수 잇고, 어셈블리어를 몰라도 C와 같은 high level 언어로 프로그램을 작성할 수 있다.

- 두 번째로, 운영체제의 가장 중요한 목표는 `성능`이다. (minimize the overhead)
  - `overhead`는 시스템의 성능을 떨어뜨리는 요소이며, 시간(더 많은 명령어)과 공간(더 많은 메모리)적인 요소로 나뉜다.
  - 이 시간과 공간의 낭비를 최소화 하면서도, 절충할 부분은 절충하면서, 성능을 최대화 하는 것이 운영체제의 목표이다.

- 세 번째로, `보호`이다.
  - 운영체제와 프로그램, 프로그램간의 보호를 제공하는 것이다.
  - 한 프로그램의 악의적인 또는 의도치 않은 행동이 다른 프로그램이나 운영체제에 영향을 미치지 않도록 하는 것이 필요하다.
  - 보호는 운영체제의 원칙 중 하나인 isolation 원칙의 핵심이다.

- 마지막으로 `신뢰성`이다.
  - 운영체제는 항상, 지속적으로 실행되고 있어야 한다.
  - 운영체제가 실패하면, 그 위에서 돌아가는 프로그램들도 실패하게 된다.
  - 이러한 종속성 때문에 운영체제는 매우 높은 신뢰성을 요구받는다.

- 이러한 목표들은 운영체제의 설계와 구현에 있어서 중요한 요소이며, 이 책에서는 이러한 목표들을 달성하기 위한 기법과 정책들을 다룬다.

> 추가적으로 에너지 효율성과 보안, 이식성등을 언급하지만, 이 책에에서 직접적으로 다루진 않고, 실제로도 위의 네가지가 조금 더 운영체제의 핵심 목표이다.


### 02.6 배경 소개 (라고 되어있지만 사실 그냥 운영체제의 역사)


#### 초창기 운영체제: 단순 라이브러리

- 초창기에는 운영체제가 많은 일을 하지 않았다, 자주 사용되는 저수준의 입출력 처리 코드를 함수화 하여 모아놓은 라이브러리 정도였다.

- 작업을 모아놓고 일괄적으로 처리하는 것은 `batch processing`이라고 하는데, 이러한 작업은 컴퓨터 관리자가 수동으로 처리했다.

#### 라이브러리를 넘어 : 보호

- 운영체제는 단순한 라이브러리를 넘어 컴퓨터 '관리' 측면에서 중요한 역할을 하기 시작했다.

- 운영체제가 실행하는 코드는 일반적인 응용 프로그램의 코드와는 다르게, 실제 하드웨어 장치의 제어를 담당하고 있기에, 다르게 취급되어야 한다는 필요성이 대두되었다.

- 예를들어 모든 응용 프로그램이 하드디스크에 접근하면, 응용 프로그램끼리 서로의 데이터를 읽고 쓸 수 있게 되어 보안상 문제가 발생한다.

- 결론적으로 예를들 `file system`과 같은 것들을 일반 라이브러리처럼 제공하고 운영하면, 자료의 기록과 보호라는 원래 의도한 역할을 수행할 수 없게 된다.

여기서 Atlas Computing System에 의해 `System Call`이라는 아이디어가 발명되었다.

- 기본적으로 Atlas Computing System의 아이디어는  OS routine을 라이브러리 형식으로 제공하는 대신, 
- OS를 더 공식적이고 제어된 프로세스로 전환하기위해 하드웨어 명령어와 하드웨어 상태라는 특별한 페어를 추가하는 아이디어이다.

- `System Call`과 `Procedure Call`의 차이점은 `System Call`에서는 OS로 제어권이 넘어가는 시점에 하드웨어 제어 권한(정확히 번역은 하드웨어 특권 수준 : Hardware Privilege level 으로 되어있다)을 격상시키는 것이다.

- 일단 일반적인 응용프로그램은 `user mode`에서 실행되는데, 이때는 하드웨어에 대한 접근이 제한된다.

- 하지만 `System Call`을 호출하면, OS로 제어권이 넘어가고, OS는 `kernel mode`에서 실행되며, 이때는 하드웨어에 대한 접근이 허용된다.

- 구체적으로는 `trap`이라는 명령어를 사용하여 `System Call`을 호출하고, 이때 `trap`은 `kernel mode`로 전환하는 역할을 한다.

- 또한 하드웨어는 `trap`으로 인해 `System Call`이 호출되었을 때, 미리 지정된 `trap handler` 함수에게 제어권을 넘긴다.

- 이 상태에서는 모든 하드웨어에 대한 접근이 허용되며, 이를 통해 OS는 필요한 요청을 처리하고, 제어권을 다시 user에게 넘겨준다.

- 이러한 `System Call`을 통해 OS는 하드웨어에 대한 접근을 제어하고, 이를 통해 보호와 다른 기능들을 수행할 수 있게 되었다.

참고: System call과 Procedure call의 차이점

1. **권한 수준 (Privilege Level):**
   - 프로시저 호출: 프로시저 호출은 일반적으로 동일한 권한 수준(예: 사용자 모드)에서 발생합니다. 호출된 프로시저는 호출한 프로그램과 동일한 권한 수준에서 실행됩니다.
   - 시스템 호출: 시스템 호출은 권한 수준을 변경하여 실행됩니다. 시스템 호출은 일반적으로 사용자 모드에서 이루어지며, 호출된 OS 코드는 권한이 더 높은 커널 모드에서 실행됩니다. 이로써 OS는 보다 높은 권한 수준에서 하드웨어와 상호 작용하여 특권 명령을 실행할 수 있습니다.

2. **하드웨어 접근 및 보안:**
   - 프로시저 호출: 프로시저 호출은 호출된 프로시저가 호출한 프로그램의 메모리 공간과 동일한 접근 권한을 가집니다. 이는 호출된 프로시저가 호출한 프로그램의 데이터에 자유롭게 접근할 수 있다는 것을 의미할 수 있습니다.
   - 시스템 호출: 시스템 호출은 권한 수준을 변경하므로, 호출된 OS 코드는 호출한 프로그램의 메모리 공간에 직접 액세스할 수 없습니다. 이는 시스템 호출을 통해 호출된 OS가 사용자 프로그램의 데이터에 무단으로 접근하는 것을 방지합니다.

3. **운영 체제와의 상호 작용:**
   - 프로시저 호출: 프로시저 호출은 일반적으로 동일한 응용 프로그램 내에서 다른 함수 또는 프로시저를 호출하는 데 사용됩니다.
   - 시스템 호출: 시스템 호출은 주로 운영 체제와 상호 작용하기 위해 사용됩니다. 예를 들어, 파일 시스템 접근, 네트워크 통신, 시스템 자원 할당 등과 같은 운영 체제 서비스에 접근하기 위해 사용됩니다.


#### 멀티 프로그래밍 시대

- 미니 컴퓨터 시대에 이루어 졌다고 한다.

- 회사마다 하나의 컴퓨터를 사용하는 정도로 보급되었다고 한다.

- 이때부터 운영체제는 `multiprogramming`이라는 개념을 도입하게 된다.

- 왜냐하면 한대의 컴퓨터에서 여러개의 프로그램을 실행하면서, CPU가 놀지 않도록 일을 시킬 수 있기 때문이다.

- 그래서 인터럽트를 통한 `context switch`라는 아이디어가 등장했는데, 운영체제 역사에서 혁신이라 부를 만 한 아이디어이다.

- 물론 이러한 상황에서 `메모리 보호`, `병행성`에 대한 처리도 필요해졌다.

- 그 외에 역사적으로는 UNIX 운영체제가 등장했고, 이 역시 가장 중요한 사건 중 하나로 꼽힌다.


#### 현대 (개인용 컴퓨터 시대)

- 이제는 개인용 컴퓨터가 보급되었고, 이에 따라 운영체제도 변화하게 된다.

- 놀랍게도 저자는 퇴보를 언급한다, 미니 컴퓨터 시대가 운영체제의 전성기였으며 초창기 pc들의 os들은 그 시대의 아이디어나 기술을 사용하지 않거나 심지어는 잘 몰랐다고 한다.

- 예시로 DOS는 메모리 보호를 전혀 생각하지 않고 디자인 되었고, MacOS는 잘못된 스케줄링을 채택하여, 쓰레드 하나가 무한루프에 빠지면, 전체 시스템이 멈추는 버그가 있었다.

- 이 당시가 암흑기라고 하며 1980년대가 지나가면서 다시 운영체제는 1970년대 미니컴퓨터 시대의 아이디어와 기술을 찾아가기 시작했다고 한다.

## 03장 - 가상화에 대한 대화

- 가상화에 대한 대화를 통해 가상화에 대한 기본적인 개념을 이해한다.

- 가상화를 복숭아에 비유하여 설명한다.



- 복숭아를 먹고 싶은 사람이 여럿 있고 복숭아는 단 하나라고 이야기한다.

- 먼저 가상 복숭아를 먹고싶은 모두에게 나눠준다.

- 사실 그 사람들은 매 시간 복숭아를 먹고 있는게 아니라, 대부분의 시간을 낮잠을 자거나 휴식을 취하고 있다.

- 그래서 실제로 복숭아를 사용하고 있지 않을 때, 다른 사람에게 실제 복숭아를 가져다 준다는 것이다.

- 이 비유에서 복숭아는 `자원`이고, 사람들은 `프로세스`이다.

- 그리고 그 복숭아를 옮기는 사람은 `운영체제`이다.

- 복숭아를 CPU로 바꾸면 CPU 가상화가 되고, 복숭아를 메모리로 바꾸면 메모리 가상화가 된다.

## 04장 - 프로세스

- 프로세스는 일반적으로 실행중인 프로그램이라고 정의한다.

- 프로그램은 디스크 상에 존재하는 실행을 위한 명령어와 정적 데이터의 묶음이다.

> **핵심 질문 : CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가?**

- 운영체제는 CPU를 가상화하여 여러 개의 프로세스가 동시에 실행되는 것처럼 보이게 한다.

- 하나의 프로세스를 실행하고, 다른 프로세스를 실행하고, 다시 다른 프로세스를 실행하는 것을 반복한다.

- 이러한 기법은 `time sharing` 이라고 불리는데, 원하는 수 만큼의 프로세스를 동시에 실행 할 수 있다.(물론 CPU를 공유하기 때문에 각 프로세스의 성능은 떨어진다.)

- CPU 가상화를 효율적으로 구현하기 위해서는 도구(mechanism)와 지능(policy)이 필요하다.

- 여기서의 도구는 `context switch`와 `interrupt`이며, 지능은 `scheduler`인데 지금부터 이것들을 다룬다.


### 04.1 프로세스의 개념(프로세스 추상화)

- 프로세스를 실행중인 프로그램으로 언급했다.

- 프로세스 인스턴스를 요약하려면, 프로세스가 실행간에 접근했거나 영향을 미친 것들에 대한 목록을 통해 알아볼 수 있다.

- 이러한 관점으로 프로세스를 알아보기 위해서 일단 하드웨어 상태(machine state)에 대해서 이해를 해야 한다.
  > machine state는 프로그램이 실행되는 동안 읽거나 쓸 수 있는 모든 것을 의미한다.

- machine state의 가장 중요한 컴포넌트는 memory이다. 명령어와 읽고 쓰는 데이터 모두 메모리에 저장되어 있고, 프로세스가 접근 할 수 있는 메모리(주소공간)는 프로세스의 machine state의 일부이다.

- 두 번 째 컴포넌트로 레지스터가 있는데, 레지스터는 CPU에 있는 작은 메모리 공간이다. 레지스터는 CPU가 명령어를 실행하는 동안 사용되며, 프로세스의 machine state의 일부이다.

- 레지스터중 하나로 `program counter`가 있는데, 프로그램의 어느 명령어가 실행 중 인지를 알려주는 컴포넌트이다.(명령어 포인터 : Intruction Pointer 로도 불린다.)

- 또한 `stack pointer`와 `frame pointer`가 있는데, 이것들은 프로세스의 실행 중에 사용되는 메모리 공간을 가리키는 포인터이다.

- 그리고 영구 저장장소에 접근하기 위한 것들도 있다.

> 요약하자면, 프로세스는 실행중인 프로그램이며, 프로세스를 이해하기 위해서는 프로세스의 machine state를 이해해야 하는데, machine state는 메모리, 레지스터, 프로그램 카운터, 스택 포인터, 프레임 포인터 등이 있다.


### 04.2 프로세스 API

- 실제 프로세스 API는 다음장에서 나오지만, 운영체제가 반드시 API로 제공해야하는 기능들은 다음과 같다.

- 생성(Create) : 운영체제는 프로세스를 생성 할 수 있는 방법을 제공해야 한다.

- 제거(Destory) : 운영체제는 프로세스를 강제로 제거 할 수 있는 방법을 제공해야 한다.

- 대기(Wait) : 운영체제는 프로세스가 다른 프로세스의 종료를 기다릴 수 있는 방법을 제공해야 한다.

- 각종 제어(Miscellaneous Control) : 프로세스의 우선순위를 변경하거나, 프로세스의 상태를 변경하는 등의 제어를 제공해야 한다.

- 상태 (Status) : 프로세스의 상태를 확인할 수 있는 방법을 제공해야 한다.


### 04.3 프로세스 생성: 조금 더 자세히


- 프로세스의 생성의 첫 단계는 디스크에 있는 프로그램을 메모리에 로드하는 것이다.
  - 현대의 운영체제는 이 과정에서 paging과 swapping같은 기능을 활용하여 실제 지금 필요한 부분만 메모리에 로드하는데 지금 주제와 관련이 없으므로 언급만 한다.
  - 탑재 이후 프로세스를 실행시키기 전에 운영체제가 해야할 일이 있다. 바로 특정한 만큼의 메모리를 `Stack`, `Heap` 용도로 나눠서 할당하는 것이다.
  - 또한 입출력과 관련된 것들도 초기화 해야 한다.
  - 그 다음에 main() 함수를 실행시키는 것이다.

### 04.4 프로세스 상태

- 프로세스 상태를 단순화 하면 다음 세가지로 구분 할 수 있다.

1. 실행중(Running) : 프로세스가 CPU를 사용하고 있는 상태이다.(명령어를 실행하고 있는 상태)
2. 대기중(Ready) : 프로세스가 CPU를 사용하고 있지 않지만, 언제든지 사용할 수 있는 상태이다.
3. 대기중(Waiting) : 프로세스가 CPU를 사용하고 있지 않고, 어떤 이벤트를 기다리고 있는 상태이다.

- 프로세스는 운영체제의 스케쥴링 정책에 따라 스케줄이 되면, 준비상태에서 실행상태로 바뀌게 된다.

- 프로세스가 입출력등의 완료 이벤트가 필요한 경우, 대기상태로 바뀌게 된다.

- 그리고 이렇게 입출력을 포함한 두 프로세스가 CPU를 사용하는 것은 아래의 표와 같이 나타낼 수 있다.

| 시간 | 프로세스0 | 프로세스1 | 비고                       |
|------|-----------|-----------|----------------------------|
| 1    | 준비      | 실행      |                            |
| 2    | 실행      | 준비      |                            |
| 3    | 실행      | 준비      | Process0이 입출력을 시작 |
| 4    | 대기      | 실행      | Process0 대기 상태         |
| 5    | 대기      | 실행      | Process1 실행              |
| 6    | 대기      | 실행      |                            |
| 7    | 준비      | 실행      | Process0 입출력 종료      |
| 8    | 준비      | 실행      | Process1 종료              |
| 9    | 실행      |           |                            |
| 10   | 실행      |           | Process0 종료             |


- 이러한 방식 (1 프로세스가 실행중이고, 0 프로세스가 대기상태일 때 1을 마무리한게 효율적이었나?) 등을 고민하는건 운영체제의 스케줄러가 담당하고 이부분은 다음장에서 다룬다.

### 04.5 자료 구조

> 운영체제도 프로그램이고 프로세스는 운영체제가 관리해야 하는 정보다.
> 그래서 프로세스를 관리하기 위한 자료구조가 필요하다.

- 예를 들어 프로세스의 상태를 저장하는 자료구조가 필요고, 프로세스 리스트와 같은 자료구조를 사용한다.

- 또한 현제 실행중인 프로세스를 저장하는 자료구조도 필요하다.

- 이러한 예시로 책에서는 register context를 보여준다.

```c
// 프로세스를 중단하고 이후에 다시 시작할 수 있는 정보를 저장하는 구조체
struct context {
  int eax;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int eip;
  int esp;
  int ebp;
};


enum proc_state {
  UNUSED,
  USED,
  ZOMBIE,
  SLEEPING,
  RUNNABLE,
  RUNNING
};


struct proc {
  char *mem; // 프로세스의 메모리 주소
  struct context context; // 프로세스의 레지스터 상태
  enum proc_state state; // 프로세스의 상태
  char *kstack; // 커널 스택바닥주소
  int pid; // 프로세스의 고유 식별자
  struct proc *parent; // 부모 프로세스
  struct proc *children; // 자식 프로세스
  void *chan // 0이 아닌 경우, 프로세스가 대기중인 이벤트
  int killed; // 0이 아닌 경우, 프로세스가 종료되었음을 나타냄
  struct file *ofile[NOFILE]; // 열린 파일
  struct inode *cwd; // 현재 디렉토리
  
};
```
