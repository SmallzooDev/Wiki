---
title: Week-01 📚
summary: 
date: 2024-04-21 14:26:30 +0900
lastmod: 2024-04-21 14:26:30 +0900
tags: 
categories: 
description: 
showToc: true
---

## 01 장 - 이 책에 대한 대화

- 아주 간단한 이 책에 대한 소개를 하는 챕터이다.
 
- 두 장으로 이루어져 있고, 이 책에서 자주 나오게 되는 교수와 학생의 대화 형식으로 이루어져 있다.

- 핵심적인 아이디어를 요약하면 다음과 같다. 
  - 리처드 파인만의 물리학 아주 쉬운 6가지 이야기라는 강의 노트가 있다.
  - 물리학이 6만큼 어려우면, 운영체제는 3만큼 어렵기 때문에, 이 책의 제목이 "운영체제 아주 쉬운 세 가지 이야기"이다.
  - 이 책은 운영체제에 대한 이야기를 3가지로 나누어서 설명한다. `가상화`, `병행성`, `영속성`

## 02 장 - 운영체제 개요

> 이 책에서 다루게 될 내용이지만 아주 간단하게 약식으로 설명하는 글이 있어 가져왔다.
> c/cpp를 공부할 때 이분의 블로그와 강의자료를 들었는데 상대적으로 최근에 업로드된 문서이다.
> [내가 c언어를 배우기 전에 알았다면 좋았을 것들](https://modoocode.com/315)

- 프로그램은 명령어를 실행하는 아주 단순한 일을 한다.

- 프로세서는 명렁어를 반입(fetch)하고, 디코딩(decoding)하고, 실행(execute)하는 일을 한다.

- 그리고 프로그램을 쉽게 실행하고, 프로그램간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할 수 있는 `소프트웨어`가 `운영체제`이다.

- 운영체제는 앞에서 언급한 일을 하기 위해서 `Virtualization`이라는 기법을 사용한다.

- 실제 프로세서, 메모리, 디스크 같은 물리적인 자원을 이용해서 일반적이고, 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.

- 그래서 운영체제를 가상머신이라고 하기도 한다.

- 가상화를 이용해서 실제 사용자들이 해당 자원을 접근 할 수 있는 API를 제공하며, Application이 사용 할 수 있는 시스템콜을 제공한다.


### 02.1 CPU 가상화

> **핵심 질문 : 자원을 어떻게 가상화 시키는가?**

- 운영체제가 자원을 가상화 시켜서 사용하면 편리한건 너무 당연하기 때문에, 이러한 문제는 질문이 될 수 없다.

- 이것을 어떻게, 어떠한 기법과 정책으로, 어떻게 효율적으로, 어떠한 하드웨어 지원이 필요한지 와 같은 질문이 중요하다.

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

void Spin(int howlong) {
  double t = GetTime();
  while ((GetTime() - t) < (double)howlong)
    ; // do nothing in loop
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    printf("Usage: CPU <string>\n");
    exit(-1);
  }
  char *str = argv[1];
  while (1) {
    Spin(1);
    printf("%s\n", str);
  }
  return 0;
}
```

- 위 코드는 CPU를 사용하는 프로그램이다. 이 프로그램은 인자로 받은 문자열을 1초에 한 번 영원히 출력한다.

```shell
$ gcc -o CPU CPU.c
$ ./CPU A & ; ./CPU B & ; ./CPU C & ;
```

- 이렇게 실행시키면 마치 CPU가 세 개인 것 처럼 ABC가 번갈아가며 출력된다.

- 이렇게 CPU를 가상화 시키는 것은 유용하지만, 새로운 문제가 발생한다. 예를 들어 동일한 시점에 실행되어야 하는 프로그램이 많아지면, 어떠한 프로그램이 실행되어야 하는가 와 같은 이슈가 생긴다.

- 이러한 문제를 해결하기 위해서 필요한 정책 같은 것들이 있는데, 이번 장에서는 이러한 정책들을 다루게 된다.(즉 자원 관리자로서의 운영체제 역할에 대해 다룬다.)

### 02.2 메모리 가상화

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>

double GetTime() {
  struct timeval t;
  int rc = gettimeofday(&t, NULL);
  assert(rc == 0);
  return (double)t.tv_sec + (double)t.tv_usec / 1e6;
}



void Spin(int howlong) {
  double t = GetTime();
  while ((GetTime() - t) < (double)howlong)
    ; // do nothing in loop
}

int main(int argc, char *argv[]) {
  int *p = malloc(sizeof(int)); // 메모리를 한당 받는다. 
  assert(p != NULL);
  printf("(%d) address pointed to by p: %p\n", getpid(), p); // process의 id를 출력한다.
  *p = 0;                                                    // 할당받은 메모리에 0을 넣는다. 
  while (1) {
    Spin(1);
    *p = *p + 1;
    printf("(%d) p: %d\n", getpid(), *p); // process의 id와 p의 값을 출력한다.
  }
}

```

- 위 코드는 메모리를 사용하는 프로그램이다. 이 프로그램은 메모리를 할당 받고, 1초에 한 번씩 메모리에 있는 값을 1씩 증가시킨다.

- 그러면서 주석에 있는 내용처럼 process의 id와 메모리 주소를 출력한다.

다수의 프로그램을 동시에 실행시킨 결과는 다음과 같다.

```shell
$ gcc -o MEM MEM.c
$ ./MEM & ; ./MEM & ; ./MEM & ;

[1] 7890
[2] 7891
[3] 7892

(7890) memory address of p: 0x200000000
(7891) memory address of p: 0x200000000
(7892) memory address of p: 0x200000000
(7890) p: 0
(7891) p: 0
(7892) p: 0
(7890) p: 1
(7891) p: 1
(7892) p: 1
(7890) p: 2
(7891) p: 2
(7892) p: 2
(7890) p: 3
(7891) p: 3
(7892) p: 3
...
```
- 주목해야 할 결과값은 메모리 주소이다. 프로그램이 실행되는 메모리 주소는 모두 같다.

- 이 역시 메모리 가상화의 결과이다. 프로그램은 자신만의 메모리를 가지고 있다고 생각하지만, 실제로는 운영체제가 제공하는 가상 메모리를 사용하고 있다.

- 이와 같은 메모리의 가상화 역시 이 책에서 다루게 된다.


### 02.3 병행성 (Concurrency)

- 프로그램이 한 번에 많은 일을 하려 할 때 (동시에) 발생하는 문제를 다룬다.

- 사실 운영체제는 한 프로세스 실행, 다음 프로세스 실행, 다음 프로세스 실행, ... 이런식으로 프로세스를 번갈아가며 실행하는데 이 때 발생하는 문제들이 생긴다.

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

volatile int counter = 0;
int loops;

// loop 횟수만큼 counter를 증가시키는 함수
void *worker(void *arg) {
  int i;
  for (i = 0; i < loops; i++) {
    counter++;
  }
  return NULL;
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "usage: threads <value>\n");
    exit(1);
  }
  loops = atoi(argv[1]); // 인자로 받은 값을 loops에 저장한다.

  pthread_t p1, p2;
  printf("Initial value : %d\n", counter);
  
  double t1 = GetTime();
  pthread_create(&p1, NULL, worker, NULL); // thread p1 worker 함수 실행
  pthread_create(&p2, NULL, worker, NULL); // thread p2 worker 함수 실행
  pthread_join(p1, NULL);
  pthread_join(p2, NULL);
  double t2 = GetTime();
  printf("Final value : %d\n", counter);
  printf("Time : %f\n", t2 - t1);
  return 0;
}
```

- 이 코드는 복잡해보이지만 전혀 그렇지 않다. thread 2개를 생성하고, 각각의 thread에서 worker 함수를 실행한다.

- worker 함수는 인자로 받은 loop 횟수만큼 counter를 증가시킨다.

- 실제 실행 결과는 다음과 같다.

```shell
$ gcc -o THREAD THREAD.c -lpthread
$ ./THREAD 1000

Initial value : 0
Final value : 2000
Time : 0.000000
```

- 일단 값이 2000이 나왔다. 이는 2개의 thread가 각각 1000번씩 counter를 증가시켰기 때문이다.

- 더 많은 횟수로 실행한 결과는 다음과 같다.

```shell
$ ./THREAD 100000

Initial value : 0
Final value : 143012
Time : 0.000000
```

- 이번에는 143012가 나왔다. 인자 * 스레드의 개수 만큼 counter가 증가해야 하는데 그렇지 않은 이유는 아래와 같다.

- 실제 카운터를 증가시키는 코드의 로직은 다음과 같다.
  - counter를 메모리에서 레지스터로 불러온다.
  - 레지스터에 1을 더한다.
  - 레지스터의 값을 메모리에 저장한다.

- 이 세가지 작업이 원자성을 가지지 않는다. 즉, 다른 스레드가 counter를 읽어가는 동안 다른 스레드가 counter를 증가시킬 수 있다.

- 이러한 문제가 Concurrency 문제이며, 이러한 문제를 해결하기 위한 방법들을 이 책에서 다룬다.

> **병행성의 핵심 질문 : 올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가**
> 같은 메모리 공간에 다수의 쓰레드가 동시에 실행단다고 할 때, 올바르게 동작하는 프로그램을 어떻게 잘성 할 수 있는가? 운영체제는 어떠한 기본 기법을 제공하는가, 하드웨어는 어떠한 지원을 제공하는가?
> 병행성 문제를 해결하기 위해 기본 기법들과 하드웨어 기능을을 어떻게 사용할 수 있는가?

### 02.4 영속성 (Persistence)

- RAM은 읽고 쓰기가 레지스터, 캐시에 비해서는 느리지만, 그래도 충분히 빠르다.

| 작업          | 시간 (현실 시간으로 환산) |
|---------------|------------------------|
| CPU 사이클    | 1초                    |
| L1 캐시 접근 | 2초                    |
| L2 캐시 접근 | 7초                    |
| L3 캐시 접근 | 1분                    |
| RAM 접근      | 4분                    |
| NVMe SSD 접근 | 17시간                 |
| 일반 SSD 접근 | 1.5일 ~ 4일            |
| 일반 하드디스크 접근 | 1 ~ 9달         |
| 서울 - 샌프란시스코 패킷 전송 시간 | 14년 |
출처 : [내가 c언어를 배우기 전에 알았다면 좋았을 것들](https://modoocode.com/315)

- 그러나 RAM은 전원이 꺼지면 모든 데이터가 사라진다. 

- 그래서 우리는 데이터를 영구적으로 저장할 수 있는 영속성을 구현하기 위해 하드웨어와 소프트웨어가 필요하다.

- 많이들 알고 있겠지만, 하드웨어는 I/O 장치 형태로 제공되며, 요즘은 주로 SSD를 사용한다.

- 디스크를 관리하는 운영체제 소프트웨어는 파일 시스템이라고 한다. (파일시스템은 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적으로 저장할 `책임`이 있다.)

- 영속성과 관련한 핵심 질문은 다음과 같다.

> **영속성의 핵심 질문 : 데이터를 영속적으로 저장하는 방법은 무엇인가**
> 파일 시스템은 데이터를 여속적으로 관리하는 운영체제의 일부분인다. 올바르게 동작하기 위해서는 어떤 기법이 필요할까? 이러한 작업 성능을 높이기 위해서 어떤 기법과 정책이 필요할까?
> 하드웨어와 소프트웨어가 실패하더라도 올바르게 동작하려면 어떻게 해야 할까?
 
```c
#include <unistd.h>
#include <assert.h>
#include <fcnt1.h>
#include <sys/file.h>

int main(int argc, char *argv[])
{
  int fd = open("tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); // 프로그램의 운영체제 첫 번째 호출(call)
  assert(fd > -1);
  int rc = write(fd, "hello world\n", 13); // 프로그램의 운영체제 두 번째 호출(call)
  close(fd); // 프로그램의 운영체제 세 번째 호출(call)
  assert(rc == 13);

  /**
    * 이 처럼 파일 시스템의 시스템 콜을 사용한다.
  */
  return 0;
}
```

- 이 코드는 파일 시스템을 사용하는 프로그램이다. 파일을 열고, 쓰고, 닫는 작업을 한다.

- 디스크를 접근해서 파일시스템으로 관리하고 시스템콜을 통해 파일을 생성하고, 쓰고, 닫아왔었다.

- 이러한 시스템콜은 표준화 되어있어서 마치 언어의 STL로 제공받는 것처럼 편리하지만,

- 실제로 내부에서 일어나는 일은 매우 복잡하다.

- 에를 들어 쓰기 지연시간동안 정전이 되었거나 고장이 났을 때, 기록 순서가 뒤바뀔 수 있고, 쓰려고 모였던 데이터는 이미 쓰였을 수도 있다.

- 이런 것들을 해결하기 위해 운영체제는 `journaling`, `copy-on-write`, `checksums` 등의 기법을 사용하는데, 이러한 것들도 같이 다루게 된다.


### 02.5 설계 목표

> 설계 목표라고 되어 있어서 흐름상 애매하지만,
> 위의 소주제에서 세가지를 보면서(가상화, 병행성, 영속성) 운영체제가 해야하는, 하고있는, 해야할 일을 알게 되었으니,
> 그것들을 어떻게 잘 수행할 수 있을지에 대한 설계 목표를 다룬다고 생각하면 될 것 같다.

- 첫 번째로, 가장 기본적인 목표는 `시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념들을 정의하는 것 즉 추상화`이다.
  - 이 추상화는 컴퓨터 과학에 있어서 모든 일에 대한 근간이다.
  - 추상화로 개념을 정의해가며 큰 프로그램을 이해하기 쉬운 작은 여러가지로 나눌 수 있다.
  - 예를 들어 논리 게이트를 몰라도 어셈블리어로 프로그램을 작성 할 수 잇고, 어셈블리어를 몰라도 C와 같은 high level 언어로 프로그램을 작성할 수 있다.

- 두 번째로, 운영체제의 가장 중요한 목표는 `성능`이다. (minimize the overhead)
  - `overhead`는 시스템의 성능을 떨어뜨리는 요소이며, 시간(더 많은 명령어)과 공간(더 많은 메모리)적인 요소로 나뉜다.
  - 이 시간과 공간의 낭비를 최소화 하면서도, 절충할 부분은 절충하면서, 성능을 최대화 하는 것이 운영체제의 목표이다.

- 세 번째로, `보호`이다.
  - 운영체제와 프로그램, 프로그램간의 보호를 제공하는 것이다.
  - 한 프로그램의 악의적인 또는 의도치 않은 행동이 다른 프로그램이나 운영체제에 영향을 미치지 않도록 하는 것이 필요하다.
  - 보호는 운영체제의 원칙 중 하나인 isolation 원칙의 핵심이다.

- 마지막으로 `신뢰성`이다.
  - 운영체제는 항상, 지속적으로 실행되고 있어야 한다.
  - 운영체제가 실패하면, 그 위에서 돌아가는 프로그램들도 실패하게 된다.
  - 이러한 종속성 때문에 운영체제는 매우 높은 신뢰성을 요구받는다.

- 이러한 목표들은 운영체제의 설계와 구현에 있어서 중요한 요소이며, 이 책에서는 이러한 목표들을 달성하기 위한 기법과 정책들을 다룬다.

> 추가적으로 에너지 효율성과 보안, 이식성등을 언급하지만, 이 책에에서 직접적으로 다루진 않고, 실제로도 위의 네가지가 조금 더 운영체제의 핵심 목표이다.


### 02.6 배경 소개 (라고 되어있지만 사실 그냥 운영체제의 역사)


#### 초창기 운영체제: 단순 라이브러리

- 초창기에는 운영체제가 많은 일을 하지 않았다, 자주 사용되는 저수준의 입출력 처리 코드를 함수화 하여 모아놓은 라이브러리 정도였다.

- 작업을 모아놓고 일괄적으로 처리하는 것은 `batch processing`이라고 하는데, 이러한 작업은 컴퓨터 관리자가 수동으로 처리했다.

#### 라이브러리를 넘어 : 보호

- 운영체제는 단순한 라이브러리를 넘어 컴퓨터 '관리' 측면에서 중요한 역할을 하기 시작했다.

- 운영체제가 실행하는 코드는 일반적인 응용 프로그램의 코드와는 다르게, 실제 하드웨어 장치의 제어를 담당하고 있기에, 다르게 취급되어야 한다는 필요성이 대두되었다.

- 예를들어 모든 응용 프로그램이 하드디스크에 접근하면, 응용 프로그램끼리 서로의 데이터를 읽고 쓸 수 있게 되어 보안상 문제가 발생한다.

- 결론적으로 예를들 `file system`과 같은 것들을 일반 라이브러리처럼 제공하고 운영하면, 자료의 기록과 보호라는 원래 의도한 역할을 수행할 수 없게 된다.

여기서 Atlas Computing System에 의해 `System Call`이라는 아이디어가 발명되었다.

- 기본적으로 Atlas Computing System의 아이디어는  OS routine을 라이브러리 형식으로 제공하는 대신, 
- OS를 더 공식적이고 제어된 프로세스로 전환하기위해 하드웨어 명령어와 하드웨어 상태라는 특별한 페어를 추가하는 아이디어이다.

- `System Call`과 `Procedure Call`의 차이점은 `System Call`에서는 OS로 제어권이 넘어가는 시점에 하드웨어 제어 권한(정확히 번역은 하드웨어 특권 수준 : Hardware Privilege level 으로 되어있다)을 격상시키는 것이다.

- 일단 일반적인 응용프로그램은 `user mode`에서 실행되는데, 이때는 하드웨어에 대한 접근이 제한된다.

- 하지만 `System Call`을 호출하면, OS로 제어권이 넘어가고, OS는 `kernel mode`에서 실행되며, 이때는 하드웨어에 대한 접근이 허용된다.

- 구체적으로는 `trap`이라는 명령어를 사용하여 `System Call`을 호출하고, 이때 `trap`은 `kernel mode`로 전환하는 역할을 한다.

- 또한 하드웨어는 `trap`으로 인해 `System Call`이 호출되었을 때, 미리 지정된 `trap handler` 함수에게 제어권을 넘긴다.

- 이 상태에서는 모든 하드웨어에 대한 접근이 허용되며, 이를 통해 OS는 필요한 요청을 처리하고, 제어권을 다시 user에게 넘겨준다.

- 이러한 `System Call`을 통해 OS는 하드웨어에 대한 접근을 제어하고, 이를 통해 보호와 다른 기능들을 수행할 수 있게 되었다.

참고: System call과 Procedure call의 차이점

1. **권한 수준 (Privilege Level):**
   - 프로시저 호출: 프로시저 호출은 일반적으로 동일한 권한 수준(예: 사용자 모드)에서 발생합니다. 호출된 프로시저는 호출한 프로그램과 동일한 권한 수준에서 실행됩니다.
   - 시스템 호출: 시스템 호출은 권한 수준을 변경하여 실행됩니다. 시스템 호출은 일반적으로 사용자 모드에서 이루어지며, 호출된 OS 코드는 권한이 더 높은 커널 모드에서 실행됩니다. 이로써 OS는 보다 높은 권한 수준에서 하드웨어와 상호 작용하여 특권 명령을 실행할 수 있습니다.

2. **하드웨어 접근 및 보안:**
   - 프로시저 호출: 프로시저 호출은 호출된 프로시저가 호출한 프로그램의 메모리 공간과 동일한 접근 권한을 가집니다. 이는 호출된 프로시저가 호출한 프로그램의 데이터에 자유롭게 접근할 수 있다는 것을 의미할 수 있습니다.
   - 시스템 호출: 시스템 호출은 권한 수준을 변경하므로, 호출된 OS 코드는 호출한 프로그램의 메모리 공간에 직접 액세스할 수 없습니다. 이는 시스템 호출을 통해 호출된 OS가 사용자 프로그램의 데이터에 무단으로 접근하는 것을 방지합니다.

3. **운영 체제와의 상호 작용:**
   - 프로시저 호출: 프로시저 호출은 일반적으로 동일한 응용 프로그램 내에서 다른 함수 또는 프로시저를 호출하는 데 사용됩니다.
   - 시스템 호출: 시스템 호출은 주로 운영 체제와 상호 작용하기 위해 사용됩니다. 예를 들어, 파일 시스템 접근, 네트워크 통신, 시스템 자원 할당 등과 같은 운영 체제 서비스에 접근하기 위해 사용됩니다.


#### 멀티 프로그래밍 시대

- 미니 컴퓨터 시대에 이루어 졌다고 한다.

- 회사마다 하나의 컴퓨터를 사용하는 정도로 보급되었다고 한다.

- 이때부터 운영체제는 `multiprogramming`이라는 개념을 도입하게 된다.

- 왜냐하면 한대의 컴퓨터에서 여러개의 프로그램을 실행하면서, CPU가 놀지 않도록 일을 시킬 수 있기 때문이다.

- 그래서 인터럽트를 통한 `context switch`라는 아이디어가 등장했는데, 운영체제 역사에서 혁신이라 부를 만 한 아이디어이다.

- 물론 이러한 상황에서 `메모리 보호`, `병행성`에 대한 처리도 필요해졌다.

- 그 외에 역사적으로는 UNIX 운영체제가 등장했고, 이 역시 가장 중요한 사건 중 하나로 꼽힌다.


#### 현대 (개인용 컴퓨터 시대)

- 이제는 개인용 컴퓨터가 보급되었고, 이에 따라 운영체제도 변화하게 된다.

- 놀랍게도 저자는 퇴보를 언급한다, 미니 컴퓨터 시대가 운영체제의 전성기였으며 초창기 pc들의 os들은 그 시대의 아이디어나 기술을 사용하지 않거나 심지어는 잘 몰랐다고 한다.

- 예시로 DOS는 메모리 보호를 전혀 생각하지 않고 디자인 되었고, MacOS는 잘못된 스케줄링을 채택하여, 쓰레드 하나가 무한루프에 빠지면, 전체 시스템이 멈추는 버그가 있었다.

- 이 당시가 암흑기라고 하며 1980년대가 지나가면서 다시 운영체제는 1970년대 미니컴퓨터 시대의 아이디어와 기술을 찾아가기 시작했다고 한다.

## 03장 - 가상화에 대한 대화

- 가상화에 대한 대화를 통해 가상화에 대한 기본적인 개념을 이해한다.

- 가상화를 복숭아에 비유하여 설명한다.



- 복숭아를 먹고 싶은 사람이 여럿 있고 복숭아는 단 하나라고 이야기한다.

- 먼저 가상 복숭아를 먹고싶은 모두에게 나눠준다.

- 사실 그 사람들은 매 시간 복숭아를 먹고 있는게 아니라, 대부분의 시간을 낮잠을 자거나 휴식을 취하고 있다.

- 그래서 실제로 복숭아를 사용하고 있지 않을 때, 다른 사람에게 실제 복숭아를 가져다 준다는 것이다.

- 이 비유에서 복숭아는 `자원`이고, 사람들은 `프로세스`이다.

- 그리고 그 복숭아를 옮기는 사람은 `운영체제`이다.

- 복숭아를 CPU로 바꾸면 CPU 가상화가 되고, 복숭아를 메모리로 바꾸면 메모리 가상화가 된다.

## 04장 - 프로세스

- 프로세스는 일반적으로 실행중인 프로그램이라고 정의한다.
