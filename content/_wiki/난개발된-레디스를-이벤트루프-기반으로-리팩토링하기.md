---
title: ë‚œê°œë°œëœ ë ˆë””ìŠ¤ë¥¼ ì´ë²¤íŠ¸ ë£¨í”„ ê¸°ë°˜ìœ¼ë¡œ ë¦¬íŒ©í† ë§í•˜ê¸° ğŸ¥¶
summary: 
date: 2024-11-26 14:10:39 +0900
lastmod: 2024-11-26 14:10:39 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## Prerequisite
---
ë‚´ê°€ ì§ë©´í•œ ë¬¸ì œëŠ” ì•„ë˜ì˜ ë¬¸ì„œì— ìˆë‹¤.

ğŸ‘‰ [[Redis-Stream-Issue]]
- ì•„ì£¼ ê°„ë‹¨í•˜ê²Œ ìš”ì•½í•˜ìë©´, ê° ìŠ¤ë ˆë“œê°€ ìŠ¤íŠ¸ë¦¼ì„ ë¬¼ê³ ë‹¤ë‹ˆë©´ì„œ íƒœìŠ¤í¬ê°€ ì²˜ë¦¬ë˜ê³ , ë¦¬ì†ŒìŠ¤ë“¤ì„ lockìœ¼ë¡œ ê´€ë¦¬í•œë‹¤.

- ì§€ê¸ˆê¹Œì§€ëŠ” ê·¸ë‚˜ë§ˆ ê´œì°®ì•˜ëŠ”ë°, ë ˆí”Œë¦¬ì¼€ì´ì…˜ì˜ ì“°ê¸° ì „íŒŒë¥¼ ìƒê°í•´ë´¤ì„ ë•Œ, ë‹¤ìˆ˜ì˜ ìŠ¬ë ˆì´ë¸Œ ìŠ¤íŠ¸ë¦¼ì„ ë½ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” êµ¬ì¡°ì—ì„œëŠ” ê°„ë‹¨í•œ ì“°ê¸° ìš”ì²­ì—ì„œë„ ìŠ¬ë ˆì´ë¸Œë“¤ì˜ ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ëŠ” ì“°ê¸° ë½ ë•Œë¬¸ì— ì§€ë‚˜ì¹œ ë³‘ëª©ì´ ë°œìƒí•œ êµ¬ì¡°ë¼ëŠ” ê²ƒì´ë‹¤.
 
- ì›ì¡° ë ˆë””ìŠ¤ëŠ” ì‹±ê¸€ìŠ¤ë ˆë“œì™€ ì´ë²¤íŠ¸ë£¨í”„ë¡œ êµ¬í˜„ëœë‹¤.
 
- ê³¼ì •ì—ì„œ ì¢‹ì€ ë°©ë²•ì´ ì—†ì„ê¹Œ í•˜ë‹¤ê°€ ì°¾ê²Œëœê±´ mpscì´ê³  mpscì— ëŒ€í•œ ê°„ë‹¨í•œ ì¡°ì‚¬ë¥¼ ì•„ë˜ì˜ ë¬¸ì„œì— ì •ë¦¬í–ˆë‹¤.
 
ğŸ‘‰ [[rust-mpsc]]
- ì•„ì£¼ ì¢‹ì€ êµ¬ì¡°ì´ì í•´ê²°ì±…ì´ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆì§€ë§Œ, ë™ì‹œì— ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì°¨ì˜¤ë¥¸ë‹¤.

## mpscëŠ” ì¢‹ì§€ë§Œ ë„ì…ì„ ìœ„í•´ í•´ê²°í•´ì•¼ í•  ë¬¸ì œë“¤
---
ì§€ê¸ˆê¹Œì§€ëŠ” ìƒì¾Œí•˜ê²Œ, ì•„ë¬´ëŸ° ì„¤ê³„ì— ëŒ€í•œ ê³ ë¯¼ì„ í•˜ì§€ ì•Šê³  ì§„í–‰ì„ í–ˆê³ , ê·¸ê²Œ ë‚´ê°€ ì½”ë“œí¬ë˜í”„í„°ìŠ¤ì— ëˆì„ ì§€ë¶ˆí•˜ëŠ” ì´ìœ ë¼ê³  ìƒê°í–ˆë‹¤.
ìŠ¤í…Œì´ì§€ë³„ ì²˜ë¦¬í•´ì•¼í•  ìš”êµ¬ì‚¬í•­ë§Œì„ ê¸°ì¤€ìœ¼ë¡œ ìƒê°í•˜ê³  êµ¬í˜„í–ˆê³ , ê·¸ ê²°ê³¼ëŠ” ìœ„ì™€ ê°™ì•˜ë˜ ê²ƒì´ë‹¤.

ì§€ê¸ˆê¹Œì§€ì˜ ë‚˜ì˜ ì½”ë“œì˜ êµ¬ì¡°ëŠ” ì´ë ‡ë‹¤.

`main.rs`
```rust
#[tokio::main]
async fn main() {
    // 1. í•„ìš”í•œ ì„¤ì •, ë°ì´í„° ë“±ì„ ì„¸íŒ…í•¨.
    let state = StateManager::new();
    let config_handler = ConfigHandler::new(state.get_db(), state.get_config(), state.get_replication_config());

    config_handler.load_config().await;
    config_handler.configure_db().await;
    config_handler.configure_replication().await;

    let port = config_handler.get_port().await;
    let listener = TcpListener::bind(format!("127.0.0.1:{}", port)).await.unwrap();

    println!("Listening on port {}", port);

    loop {
        match listener.accept().await {
            // 2. ìŠ¤íŠ¸ë¦¼ì„ ë”°ì„œ, ìŠ¤íŠ¸ë¦¼ì„ handle_clientë¡œ ì „ë‹¬
            Ok((stream, _)) => {
                let db = state.get_db();
                let config = state.get_config();
                let replication_config = state.get_replication_config();
                task::spawn(async move {
                    // 3. ë”± ë´ë„ ì•Œ ìˆ˜ ìˆê² ì§€ë§Œ, ì¼ë‹¨ ê²½í•©ìì›ì´ê³  ë­ê³  ë‹¤ ë„˜ê²¨ë²„ë¦°ë‹¤.
                    handle_client(stream, db, config, replication_config).await;
                });
            }
            Err(e) => {
                println!("Error accepting connection: {}", e);
            }
        }
    }
}

```
- `main.rs`ì—ì„œ í•˜ëŠ” ì¼ì€ 1,2,3ìœ¼ë¡œ ì •ë¦¬ ë  ìˆ˜ ìˆë‹¤.
- lockìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ìì›ë“¤ì„ ë„˜ê¸°ëŠ”ê²Œ ì¼ë‹¨ ì˜ëª»ë˜ì–´ìˆë‹¤.

`handle_client.rs`
```rust
pub async fn handle_client(mut stream: TcpStream, db: Db, config: Config, replication_config: ReplicationConfig) {
    let mut buffer = [0; 512];
    loop {
        buffer.fill(0);
        // 1. (ì§ì ‘ ë°›ì•„ì˜¨ ìŠ¤íŠ¸ë¦¼ì—ì„œ) ë²„í¼ë¡œ ìš”ì²­ ë©”ì„¸ì§€ë¥¼ ì½ëŠ”ë‹¤.
        match stream.read(&mut buffer).await {
            Ok(0) => break,
            Ok(n) => {
                let message = match std::str::from_utf8(&buffer[..n]) {
                    Ok(msg) => msg,
                    Err(_) => {
                        println!("Failed to parse message as UTF-8");
                        continue;
                    }
                };

                println!("Received message: {:?}", message);
                // 2. ë©”ì„¸ì§€ë¥¼ íŒŒì‹±í•´ì„œ, Command ê°ì²´ë¥¼ (ì •í™•íˆëŠ” enum)ì„ ë§Œë“¤ì–´ì¤€ë‹¤.
                match CommandParser::parse_message(message) {
                    Ok(command) => {
                        // 3. ì»¤ë§¨ë“œë¥¼ ì‹¤í–‰í•˜ëŠ”, ë©”ì„œë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê²½í•©ìì›ë“¤ì„ ë¬¼ê³  ë“¤ì–´ê°„ë‹¤(stream, db, ë“±ë“±...)
                        if let Err(e) = command.handle_command(&mut stream, Arc::clone(&db), Arc::clone(&config), replication_config.clone()).await {
                            println!("Failed to send response: {}", e);
                        }
                    }
                    Err(e) => {
                        println!("Failed to parse command: {}", e);
                    }
                }
            }
            Err(e) => {
                println!("Error reading from stream: {}", e);
                break;
            }
        }
    }
}

```
- ì—¬ê¸°ë„ ë§ˆì°¬ê°€ì§€ë¡œ 1,2,3 ìˆœì„œë¡œ ì£¼ì„ì„ ì‘ì„±í–ˆë‹¤.

`command.rs`
```rust
    pub async fn handle_command(
        &self,
        stream: &mut TcpStream,
        db: Db,
        config: Config,
        replication_config: ReplicationConfig,
    ) -> std::io::Result<()> {
        let peer_addr = match stream.peer_addr() {
            Ok(addr) => addr,
            Err(_) => {
                let err_response = "-ERR Failed to retrieve client address\r\n".to_string();
                stream.write_all(err_response.as_bytes()).await?;
                return Ok(());
            }
        };

        // 1. ì»¤ë§¨ë“œì—ì„œ ë°›ì•„ì˜¨ ì²˜ë¦¬ ì‘ë‹µ ê²°ê³¼ë¥¼ ê²½í•©ìì›ì¸ streamì— ì§ì ‘ ì“°ëŠ” ë¬¸ì œ.
        match self.execute(db, config, replication_config, peer_addr).await {
            Ok(responses) => {
                for response in responses {
                    match response {
                        CommandResponse::Simple(response) => {
                            stream.write_all(response.as_bytes()).await?;
                        }
                        CommandResponse::Bulk(data) => {
                            let header = format!("${}{}", data.len(), CRLF);
                            stream.write_all(header.as_bytes()).await?;
                            stream.write_all(&data).await?;
                        }
                        CommandResponse::EndStream => break,
                    }
                }
            }
            Err(e) => {
                let err_response = format!("-ERR {}\r\n", e);
                stream.write_all(err_response.as_bytes()).await?;
            }
        }

        Ok(())
    }
    pub async fn execute(
        &self,
        db: Db,
        config: Config,
        replication_config: ReplicationConfig,
        peer_addr: SocketAddr,
    ) -> Result<Vec<CommandResponse>, String> {
        match self {
          // ê° ì»¤ë§¨ë“œì— í•´ë‹¹í•˜ëŠ” ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
          Command::SET { key, value, ex, px } => Ok(vec![CommandResponse::Simple(
             Self::execute_set(key, value, *ex, *px, db).await,
           )]),
          // (ì¤‘ëµ ... )
        }
    }

    async fn execute_set(key: &String, value: &String, ex: Option<u64>, px: Option<u64>, db: Db) -> String {
        let expiration_ms = match (px, ex) {
            (Some(ms), _) => Some(ms),
            (None, Some(s)) => Some(s * 1000),
            _ => None,
        };

        // 2. ì‹¤ì œ ìŠ¤ë ˆë“œì—ì„œ ê²½í•©ìì›ì„ ì§ì ‘ì ìœ¼ë¡œ ì´ìš©í•œë‹¤.
        db.write().await.insert(key.clone(), ValueEntry::new_relative(value.clone(), expiration_ms));
        // 3. ì‹¬ì§€ì–´ ë ˆí”Œë¦¬ì¼€ì´ì…˜ ì „íŒŒì™€ ê°™ì€ ë¡œì§ì´ ëŠ˜ì–´ë‚œë‹¤ë©´ ë˜í•˜ë‚˜ì˜ ê²½í•©ìì›ì„ ìƒì„±í•œë‹¤.
        format!("{}OK{}", SIMPLE_STRING_PREFIX, CRLF)
    }
    
```

- ë§ˆì°¬ê°€ì§€ë¡œ ì‘ì„±ëœ, ë‚˜ì˜ ì½”ë“œì˜ ë¬¸ì œë¥¼ ì£¼ì„ìœ¼ë¡œ ì‘ì„±í–ˆë‹¤.

- ì¦‰ ì´ëŸ° êµ¬ì¡°ë¡œëŠ” ìŠ¤ë ˆë“œê°€ ì§ì ‘ì ìœ¼ë¡œ ê²½í•© ìì›ì„ ê°€ì ¸ë‹¤ ì“´ë‹¤ëŠ” ì´ìŠˆì´ë‹¤.

- ë” ì–´ë ¤ìš´ê±´ ì´ ìƒíƒœë¥¼ ë³€ê²½í•˜ë ¤ë©´ êµ¬ì¡°ë¥¼ ì‹¬ê°í•˜ê²Œ ë³€ê²½í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤.

## ë‹¤ì‹œ ì„¤ê³„ë¥¼ ì§„í–‰í•´ì•¼ í•œë‹¤.
---

### ë¨¼ì € ìƒê°í•´ë³¸ ê°œí¸ ì´í›„ì˜ íë¦„.

ë¨¼ì € ìƒˆë¡œ ì´ë²¤íŠ¸ë¥¼ ì •ì˜í•œë‹¤. ì•„ë˜ëŠ” ì•„ì§ ê°„ë‹¨í•˜ê²Œ ìƒê°í•˜ëŠ” `redis_event.rs`

```rust
#[derive(Debug)]
pub enum RedisEvent {
    ClientRequest {
        client: Client,
        command: Command,
    },
    Replication {
        slave: Slave,
        data: Vec<u8>,
    },
    PubSub {
        channel: String,
        message: String,
    },
    ClientConnect {
        client: Client,
    },
    ClientDisconnect {
        client: Client,
    },
}
```

ì°¸ê³ , ì›ì¡° ë ˆë””ìŠ¤ëŠ” í´ë¼ì´ì–¸íŠ¸ë¥¼ ë³„ë„ì˜ ì£¼ì†Œê°’ë§Œìœ¼ë¡œ ì‹ë³„í•œë‹¤.
```rust
use std::net::SocketAddr;

#[derive(Debug)]
pub struct Client {
    pub addr: SocketAddr,
}

```

ë§ˆì°¬ê°€ì§€ë¡œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬. `event_handler.rs`

```rust
pub struct EventHandler {
    // ì•„ë§ˆë„ ì—¬ê¸°ì— ê²½í•© ìì›ë“¤ì„ ì „ë¶€ ë³´ê´€.
    // State ê°ì²´ë¥¼ ì—¬ê¸°ì„œ ë“¤ê³ ìˆì–´ë„ ì¢‹ì„ ê²ƒ ê°™ë‹¤.
    // ê±°ê¸°ì— ì¶”ê°€ì ìœ¼ë¡œ Senderë„ í•˜ë‚˜ ë“¤ê³  ìˆì–´ì•¼ í•œë‹¤(ì•„ë§ˆë„ replication_rx). 
    // (ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë„ì¤‘, ìƒˆë¡œìš´ ì´ë²¤íŠ¸ë¥¼ ë°œí–‰í• ìˆ˜ ìˆìŒ. ì˜ˆë¥¼ë“¤ì–´ setì„ ì²˜ë¦¬í•˜ë©´ì„œ dbì— ì“°ê³ , ìƒˆë¡œìš´ replication ì „íŒŒ ì´ë²¤íŠ¸ ë°œí–‰)
}

impl EventHandler {
    pub async fn handle_event(event: RedisEvent) {
        match event {
            RedisEvent::ClientRequest { client, command, params } => {
                // ëª…ë ¹ ì‹¤í–‰ ë¡œì§
            }
            RedisEvent::Replication { slave_id, data } => {
                // ë ˆí”Œë¦¬ì¼€ì´ì…˜ ë¡œì§
            }
            RedisEvent::PubSub { channel, message } => {
                // Pub/Sub ë©”ì‹œì§€ ì²˜ë¦¬
            }
            RedisEvent::ClientConnect { client } => {
                // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬
            }
            RedisEvent::ClientDisconnect { client } => {
                // í´ë¼ì´ì–¸íŠ¸ í•´ì œ ì²˜ë¦¬
            }
        }
    }
}

```

