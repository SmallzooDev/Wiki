---
title: 스프링 부트 관련 🌿
summary: 
date: 2025-02-04 18:30:49 +0900
lastmod: 2025-03-27 23:53:16 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---
## 토비의 스프링
### 관심사
> "모든 변경과 발전은 한가지 관심에 집중해서 일어난다. 문제는 다만 그에 따른 변경이 한가지 관심에 집중해 있지 않다는 것이다. 그래서 우리가 해야 할 일은, 한가지 관심이 한군데 집중되게 하는 것이다."


### 관계
> 모델링 시점의 오브젝트 간 관계를 기반으로, 런타임 오브젝트 관계를 갖는 구조를 만들어주는것은 "클라이언트의 책임"이다. 클라이언트는 자기가 UserDao를 사용해야 할 입장이기에, UserDao의 세부 전략이라고도 볼 수 있는 구현클래스를 선택하고 선택한 클래스의 오브젝트를 생성해서 연결해줄 수 있다.

### OCP
> 클래스나 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
- 구현체를 추가하는 방식의 확장을, 기존 로직의 수정 없이 가능한 구조
- 조금 더 추상적인 것에 의존하며 책임을 분리함으로 달성

### 높은 응집도, 낮은 결합도
- 관심사가 같은 것들이 응집해 있는것,
- 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합ㄴ도.
> 결합도랑 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 '변화를 요구하는 정도'

### Strategy Pattern
> 자신의 기능 context에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.


### 오브젝트 팩토리
- 스프링이 제어권을 가지고 직접 만들고 관리하는 오브젝트 : bean
- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC오브젝트를 : beanFactory
- 이를 확장한 application context (ioc 방식의 bean factory)


### 헷갈리는 IOC 용어 정리
- `bean` : ioc방식으로 관리하는 오브젝트
- `bean factory` : ioc를 담당하는 핵심 컨테이너, 빈 등록, 생성 조회, 반환 그 외 부가적인 빈 관리 기능, 보통 이걸 확장한 애플리케이션 컨텍스트 이용
- `application context` : 빈 팩토리를 확장한 ioc 컨테이너, 스프링이 제공하는 각종 부가서비스 추가
- `configuration metadata` : ioc를 적용하기 위해 사용하는 메타데이터
- `container`, `ioc container` : 빈팩토리나 애플리케이션을 지칭

### DL(Dependency Lookup)이 필요한 경우

1. **프로토타입 스코프 빈 사용 시**
    - 프로토타입 빈은 매번 새로운 인스턴스가 필요할 때 사용됩니다.
    - DI로는 한 번만 주입되므로, 여러 번 새 인스턴스가 필요하면 ObjectProvider나 Provider를 통한 DL이 필요합니다.
    
2. **선택적 의존성(Optional Dependencies) 처리**
    - 특정 빈이 있을 수도, 없을 수도 있는 상황에서 유연하게 대응해야 할 때
    
3. **순환 의존성 문제 해결**
    - 두 빈이 서로를 참조하는 순환 의존성이 있을 때, DL을 사용하여 지연 로딩으로 해결할 수 있습니다.
    
4. **스프링 컨테이너 외부에서 빈을 사용해야 할 때**
    - 스프링 관리 객체가 아닌 일반 객체에서 스프링 빈을 사용해야 하는 경우
    
5. **런타임에 빈 선택이 필요한 경우**
    - 사용자 입력이나 설정에 따라 다른 빈을 사용해야 할 때
    
6. **지연 초기화(Lazy Initialization)가 필요할 때**
    - 특정 빈의 초기화 비용이 높고, 실제 사용 시점까지 초기화를 미루고 싶을 때


### 메소드를 이용한 의존관계 주입
- `setter` 주입
- 일반 메소드 이용한 주입

```java
@Bean
public UserDao userDao() {
	UserDao userDao = new UserDao();
	userDao.setConnectionMaker(connectionMaker());
	return userDao;
}
```

### 템플릿
> 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

> 결국 DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.

> 스프링 DI는 넓게 보자면 객체의 생성과 관계 설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임한다.

```java
// 1. 콜백 인터페이스 정의
interface Callback {
    void execute();
}

// 2. 템플릿 클래스 정의
class Template {
    public void execute(Callback callback) {
        startOperation();        // 공통 시작 작업
        
        try {
            callback.execute();  // 콜백 실행 (변하는 부분)
        } catch (Exception e) {
            handleException(e);  // 예외 처리
        } finally {
            endOperation();      // 공통 종료 작업
        }
    }
    
    private void startOperation() {
        System.out.println("작업을 시작합니다.");
        // 리소스 초기화, 연결 설정 등
    }
    
    private void handleException(Exception e) {
        System.out.println("예외가 발생했습니다: " + e.getMessage());
        // 로깅, 롤백 등
    }
    
    private void endOperation() {
        System.out.println("작업을 종료합니다.");
        // 리소스 정리, 연결 종료 등
    }
}

// 3. 템플릿 콜백 패턴 사용 예시 (파일 작업)
class FileProcessor {
    private final Template template;
    
    public FileProcessor() {
        this.template = new Template();
    }
    
    public void processFile(final String filePath) {
        template.execute(new Callback() {
            @Override
            public void execute() {
                System.out.println("파일 " + filePath + "을 처리합니다.");
                // 실제 파일 처리 로직
            }
        });
    }
}

// 4. 템플릿 콜백 패턴 사용 예시 (데이터베이스 작업)
class DatabaseProcessor {
    private final Template template;
    
    public DatabaseProcessor() {
        this.template = new Template();
    }
    
    public void executeQuery(final String query) {
        template.execute(new Callback() {
            @Override
            public void execute() {
                System.out.println("쿼리를 실행합니다: " + query);
                // 실제 쿼리 실행 로직
            }
        });
    }
}

// 5. 제네릭을 활용한 확장 예시
interface CallbackWithResult<T> {
    T execute();
}

class GenericTemplate {
    public <T> T executeWithResult(CallbackWithResult<T> callback) {
        startOperation();
        
        try {
            T result = callback.execute();  // 결과를 반환하는 콜백 실행
            return result;
        } catch (Exception e) {
            handleException(e);
            return null;
        } finally {
            endOperation();
        }
    }
    
    private void startOperation() {
        System.out.println("작업을 시작합니다.");
    }
    
    private void handleException(Exception e) {
        System.out.println("예외가 발생했습니다: " + e.getMessage());
    }
    
    private void endOperation() {
        System.out.println("작업을 종료합니다.");
    }
}

// 결과를 반환하는 제네릭 템플릿 사용 예시
class ResultExample {
    public static void main(String[] args) {
        GenericTemplate template = new GenericTemplate();
        
        // 문자열 결과를 반환하는 템플릿 콜백
        String result = template.executeWithResult(() -> {
            return "작업 결과입니다.";
        });
        
        System.out.println("반환된 결과: " + result);
    }
}

public class TemplateCallbackPatternExample {
    public static void main(String[] args) {
        FileProcessor fileProcessor = new FileProcessor();
        fileProcessor.processFile("example.txt");
        
        DatabaseProcessor dbProcessor = new DatabaseProcessor();
        dbProcessor.executeQuery("SELECT * FROM users");
        
        ModernUsage.main(args);
        
        ResultExample.main(args);
    }
}
```


### 예외
> 이전에는 복구할 가능성이 조금이라도 있다면 체크 예외로 만든다고 생각했는데, 지금은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다.

`Checked Exception` : 
- 안잡을수 없음
`Unchecked Exception` :
- 예외가 호출 스택을 따라 상위로 전파된다.
- 어떤 메서드에서도 처리되지 않으면 JVM까지 전달된다.
- JVM이 예외 정보를 표준 오류 스트림에 출력한다.
- 해당 스레드가 종료된다.
- 메인 스레드였다면 애플리케이션 전체가 종료된다.


### 비표준 SQL
> 다양한 db를 쓸 수 있도록 유연하게 하기위한 jdbc의 노력
- 두가지 이슈가 있음
	- 비표준 sql -> db 고유의 문법과 방언
	- 각각 다른 에러코드
- 에러코드 관련해서는 일단 구현체는 만들기 쉽고 거의  있음
	- 기본 -> 약간의 상태값을 가진 `SQLException` 
		- `SQLException`은 사실상 복구 불능
		- checked로 던질 이유가 없어서 jdbc가 바꿔서 던져줌
	- `DataAccessException` : 엄청 상세한 서브클래스를 제공
		- `BadSqlGrammarException`, `DataIntegrityViolationException`,`DuplicatedException`
		- 근데 문제는 db마다 에러코드 자체가 다름
