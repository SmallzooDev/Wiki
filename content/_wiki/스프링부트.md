---
title: 스프링 부트 관련 🌿
summary: 
date: 2025-02-04 18:30:49 +0900
lastmod: 2025-03-27 20:53:03 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---
## 토비의 스프링
### 관심사
> "모든 변경과 발전은 한가지 관심에 집중해서 일어난다. 문제는 다만 그에 따른 변경이 한가지 관심에 집중해 있지 않다는 것이다. 그래서 우리가 해야 할 일은, 한가지 관심이 한군데 집중되게 하는 것이다."


### 관계
> 모델링 시점의 오브젝트 간 관계를 기반으로, 런타임 오브젝트 관계를 갖는 구조를 만들어주는것은 "클라이언트의 책임"이다. 클라이언트는 자기가 UserDao를 사용해야 할 입장이기에, UserDao의 세부 전략이라고도 볼 수 있는 구현클래스를 선택하고 선택한 클래스의 오브젝트를 생성해서 연결해줄 수 있다.

### OCP
> 클래스나 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
- 구현체를 추가하는 방식의 확장을, 기존 로직의 수정 없이 가능한 구조
- 조금 더 추상적인 것에 의존하며 책임을 분리함으로 달성

### 높은 응집도, 낮은 결합도
- 관심사가 같은 것들이 응집해 있는것,
- 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합ㄴ도.
> 결합도랑 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 '변화를 요구하는 정도'

### Strategy Pattern
> 자신의 기능 context에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.


### 오브젝트 팩토리
- 스프링이 제어권을 가지고 직접 만들고 관리하는 오브젝트 : bean
- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC오브젝트를 : beanFactory
- 이를 확장한 application context (ioc 방식의 bean factory)


### 헷갈리는 IOC 용어 정리
- `bean` : ioc방식으로 관리하는 오브젝트
- `bean factory` : ioc를 담당하는 핵심 컨테이너, 빈 등록, 생성 조회, 반환 그 외 부가적인 빈 관리 기능, 보통 이걸 확장한 애플리케이션 컨텍스트 이용
- `application context` : 빈 팩토리를 확장한 ioc 컨테이너, 스프링이 제공하는 각종 부가서비스 추가
- `configuration metadata` : ioc를 적용하기 위해 사용하는 메타데이터
- `container`, `ioc container` : 빈팩토리나 애플리케이션을 지칭

### DL(Dependency Lookup)이 필요한 경우

1. **프로토타입 스코프 빈 사용 시**
    - 프로토타입 빈은 매번 새로운 인스턴스가 필요할 때 사용됩니다.
    - DI로는 한 번만 주입되므로, 여러 번 새 인스턴스가 필요하면 ObjectProvider나 Provider를 통한 DL이 필요합니다.
    
2. **선택적 의존성(Optional Dependencies) 처리**
    - 특정 빈이 있을 수도, 없을 수도 있는 상황에서 유연하게 대응해야 할 때
    
3. **순환 의존성 문제 해결**
    - 두 빈이 서로를 참조하는 순환 의존성이 있을 때, DL을 사용하여 지연 로딩으로 해결할 수 있습니다.
    
4. **스프링 컨테이너 외부에서 빈을 사용해야 할 때**
    - 스프링 관리 객체가 아닌 일반 객체에서 스프링 빈을 사용해야 하는 경우
    
5. **런타임에 빈 선택이 필요한 경우**
    - 사용자 입력이나 설정에 따라 다른 빈을 사용해야 할 때
    
6. **지연 초기화(Lazy Initialization)가 필요할 때**
    - 특정 빈의 초기화 비용이 높고, 실제 사용 시점까지 초기화를 미루고 싶을 때


### 메소드를 이용한 의존관계 주입
- `setter` 주입
- 일반 메소드 이용한 주입

```java
@Bean
public UserDao userDao() {
	UserDao userDao = new UserDao();
	userDao.setConnectionMaker(connectionMaker());
	return userDao;
}
```

### 템플릿
> 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

> 결국 DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.

