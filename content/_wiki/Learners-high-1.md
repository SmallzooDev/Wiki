---
title: 러너스 하이 1~2주차 회고
summary: 프론트엔드 잔여작업 마치기, 테스트코드 도입하기
date: 2024-12-22 14:12:48 +0900
lastmod: 2025-01-20 20:41:23 +0900
tags: 
categories: 
description: 
showToc: false
tocOpen: false
---

## Week 1,2 Summary!
---
1. 2주남은 프론트엔드 태스크들을 완료했다.
2. 테스트코드가 사실상 없던 프로젝트에 테스트코드를 도입하고 커버리지를 10% 까지 끌어올렸다.

## Week 1,2 Intro
---

인트로에 작성은 해뒀지만, 내가 이해했던 러너스 하이의 취지는
토스에서 일하는 방식대로 일해보기 이고, 토스에서 말하는 방법으로 일한다면

1. 문제를 직접 발견하거나, 더 좋은 구조에 대한 제안을 할 수 있고
2. 그부분에 대한 임팩트를 정확하게 측정 할 수 있고
3. 그 측정한 값을 기반으로 커뮤니케이션 한다면 머지와 배포가 가능하다.

라는 것을 가장 주요한 골자로 생각했다.

아마도 해당 자리에 모인 모든 이들이 지금 직장에서 저마다의 사정은 있겠지만, 저 말대로 한다면 그래도 결과를 낼 수 있었을 것이라고 생각한다.

그리고 나도 나만의 사정과 한계점을 정리하고 시작하려고 했다.

> 물론 이부분이 '이래서 안된다' 와 같은 핑계로 삼기 위해서가 아니라, 정확하게 내가 만들어 낼 수 있는 범위를
> 측정하기 위해서 였다. 
 
> 당연하게도 지금 나의 상황이 다른 참여자들보다 낫거나 나쁘다고 생각하지는 않는다.
> 일을 성공하는 이유는 비슷할거고, 실패하는 이유는 저마다 다를게 분명하니까!

1. 회사의 태스크를 처리하는 과정은 좋은의미로도 나쁜의미로도 경직되어 있다. 고객센터로 라이징된 이슈나 긴급건이 아니라면, 기술협의를 거쳐야 태스크가 생성, 배정된다. 관례적으로 운영팀을 제외하고는 고도화나 개선관련 이슈를 올리기 어렵다.
2. 특히 qa팀에 qa를 요청하는것도, 태스크의 과정중에 정해진 절차에 의거해서 진행해야 한다.
3. 특히나 지금은 코드리뷰를 해줄 팀원들과 머지, 태스크 승인을 해줄 팀원들이 모두 연말까지 휴가중이다.
4. 나에게 1월 초까지 할당된 태스크의 대부분은 프론트엔드 작업이다.

사실 4번이 가장 절망적이었고, 해당 부분에서 조치를 취할 방법이 전혀 없다고 생각해서 생각보다 고민의 시간이 길었다.
그렇지만 고민 이후로 할 수 있는 일들을 고민하니 아래와 같이 결론이 났다.

> 1. 프론트엔드 업무를 빠르게 털어버리자.
> 2. 해당 작업과 관련된 백엔드 코드를 개선해보자.
> 3. 해당 작업의 qa테스트 요청에서 해당 변경을 같이 qa받고 별도 리뷰를 진행하자.


## 프론트엔드 작업 빨리 끝내기(머지, 운영 배포 완료)
---

기존 커머스 플랫폼에 커뮤니티 기능을 도입하는 태스크였고,
내가 맡은 부분은 레거시 cms의 뷰 작업과 관련한 api작업, 그리고 프론트엔드 커뮤니티 인가 분리하는 태스크였다.

1월 1일 배포예정으로 되어있었던 태스크의 코드작업을 야근해서 목요일에 마무리 지었다.
작업과 관련해서 초점은 맞춘 부분은 프론트엔드 업무가 내가 보여주고 싶은 부분이 아니기도 하고, 
앞으로도 프론트엔드 작업은 큰 흥미가 없어서 최대한 빨리 끝내는데 집중했다.

물론 과정에서 책임감을 버리고 싶지는 않았기에, 몇몇 구조개선을 진행했다.

레거시 cms라 사용성에서 일부 잘못된 부분이 있었다.
예를 들어 router에 검색 조건을 push하고 lazyQuery로 라우터의 변경이 감지되면 쿼리를 실행하는 로직이 있었는데,
이러한 부분들을 리팩토링 하면서 진행했다. 

상태값으로 관리해야 할 데이터들을 분리해서 상태값으로 관리하고,
appoloClient의 refetch, invalidate query key를 이용해서 특정 상태값(주로 검색 조건)이 
변경됨에 따라 다시 호출을 해야 하는 부분들을 정리했다.

그리고 기존 인가 관련 로직이 커뮤니티 기능 안에서 파편화 작업되어 있어서, 별도의 인가를 관리하는 훅을 분리해서 처리했다.

결론적으로 불필요한 깜빡임이나, 불필요한 다수의 쿼리파라미터로 지저분해지는 일을 개선했으며, 커뮤니티 기능 안에서의 인가분리를 한곳에서 처리 할 수 있도록 개선했다.


## 전시영역을 담당하는 백엔드 프로젝트에 테스트코드 도입하기
---

### "Hasura 라고 있어요 ..." (전시영역 관련 독특한 구조)

![hasura-img-1](https://github.com/user-attachments/assets/5e526efe-6234-41a9-918b-df415b2d52c3)

- 우리회사는 커머스의 전시영역과 전시영역 관련한 데이터(이벤트, 기획전, 배너, 프론트엔드 컴포넌트 등)를 별도의 프로젝트와 DB로 분리해서 관리하고 있다.

- 그리고 해당 프로젝트는 `Hasura`라는 오픈소스를 사용하는데, 짧게 요약하면 DB스키마를 보고 자동으로 gql api를 만들어준다.(gql특유의 이슈들도 잘 관리되어 최적화를 해준다)

- 물론 전시영역 관련된 데이터이지만, 디비 전부를 인터페이스화 할 수 는 없기에 그 앞단에 게이트웨이성 nodejs서버를 두고 하수라 엔진에 질의하며 응답을 포워드 해주는 구조이다.

![hasura-img-2](https://github.com/user-attachments/assets/3975d0fa-7c82-499e-a547-33ce0b3afc08)

- 초창기에는 위에서 언급한 정도의 역할만 하며 해당 프로젝트가 잘 지켜졌다. 전시영역 관련된 뷰테이블에 간단한 질의 하는 정도 위주로 코드가 작성되어있었다.

- 다만 해당 프로젝트 특성상 여러 데이터소스 컴포넌트들이 붙게 되거나 다른 서버랑 통신하는 경우들이 늘어났다.

- 과정중에 결코 가볍지 않은 비즈니스 로직들도 늘어가기 시작했다.

![hasura-img-3](https://github.com/user-attachments/assets/f0c3722e-0f6f-4979-bc79-e873c6798918)

- 결국 도메인 하나를 무리없이 도입하게 될 정도로 프로젝트에 비즈니스 로직이 추가됐고, 위의 그림처럼 이번에는 커뮤니티 관련 기능들이 해당 프로젝트에 추가되는 수준의 지경에 이르렀다.

- 그리고 특히 테스트코드에 엄청 자율적인 회사 특성상, 테스트 코드는 없는 상태로 프로젝트가 유지보수 되고 있다.

### AS-IS

**테스트코드-ASIS**

언급한 것처럼 테스트코드에 매우 자율적인 기조를 유지해왔기 때문에, 이 프로젝트에 테스트코드는 `jest`기준 0%대 였다.

그나마 설정되어있는 것들과 작성되어 있는 테스트코드 역시 입사 완전 초기에 나와 같이 실험적으로 도입하면서 설정해 둔 것 이며, 유일한 테스트코드도 기존에 내가 작성해둔 것 이 전부였다.

해당 테스트코드는 특정 인증관련 해쉬값을 디코드해서 나온 정보대로 잘 캐시를 타는지 정도를 테스트해둔 코드였고, 이게 전부였다.

**소스코드-ASIS**

디렉토리 구조의 예시는 다음과 같았다.
```
src/
└── (인가 분리)/
    └── (인가에 따른 client 객체들 설정)/
        ├── client_settings.ts
        └── schemas/
            ├── common.ts
            ├── hasura-banner.ts
            ├── hasura-community.ts  # 신규 프로젝트로 작성/수정 중
            └── (...)
```

그리고 `schemas/some-domain.ts`에 외부에 노출되는 gql api들이 정의 되어 있는데, 해당 파일의 구조들은 다음과 같다.

```typescript
// 타입 정의들
interface IBannerDetailArgs {
  ...
}
interface IBannerSchedule {
  ...
}
interface IBanner {
  ...
}

// gql type defs
const typeDefs = `
  ${defaultTypeDefs}

  type Query {
    ...
  }
  
  type BannerSchedule {
    ...
  }
  type Banner {
    ...
  }
`;

// resolver(핸들러)
const bannerSchedule = async () => {
  ...
};

// resolver 등록
export const resolvers = {
  Query: {
  }
};

export const schema = makeExecutableSchema({
  typeDefs,
  resolvers
});
```

### TroubleShootings

**1 - 하나의 리졸버 핸들러가 여러번 외부 컴포넌트를 호출하는 이슈.**
> 처음에는 어찌됐던 client객체가 종단지점이라고 생각했고, client객체들만 잘 모킹하면 간단하게 해결 될 줄 알았다.
> 언급한것처럼, 비즈니스 로직이 늘어나면서 하나의 핸들러가, 다른 모듈과 외부 통신을 하거나, 하수라 엔진에 여러번 질의를 진행하는 경우가 많이 있었다.

- 이부분 때문에 도메인 하나를 전부를 리팩토링했다.

- 여러번 질의하거나 내부적으로 외부 컴포넌트를 호출하는 경우 무조건적으로 함수를 분리했다.

- 분리한 함수들 (즉 리졸버에 등록되지 않으면서, 리졸버를 처리하기 위해 질의하는 로직들)을 모듈화 했고, 그 덕분에 쉽게 모킹 할 수 있었다.

```typescript
const some_resolver = async () => {
  bool isOk = await client.query({ ... }); // 이런 부분을 모듈화해서 분리, 이후 모킹
  if (isOk) {
    const res = await client.query({ ... });
    return res;
  }
}
```

**2 - 나는 테스트코드를 작성 할 때 외부 컴포넌트를 호출하는 부분을 잘 모킹하지만 다른 동료들은?**
> 실제로 내가 모든 영역의 테스트코드를 작성 한 것 도 아니고, 다른 동료들이 테스트코드를 작성할 때 위와 같이 모듈화를 하지 않으면 실제 운영env에서는 운영데이터에 영향을 줄 수 있다.
> 그리고 실제로 gitlab 파이프라인을 뜯어보니 최근에 파이프라인을 고도화 하면서 테스트코드가 파이프라인에 포함되어있었다.

- 파이프라인을 직접 수정하는 것 보다는 jest의 설정을 만지는게 맞다고 생각했다.

- 결론적으로 dev와 테스트서버의 env로 파이프라인을 탈 때 만, 동작하도록 방어로직을 작성했다.

**3 - 테스트 코드를 작성하면서 확인된 트랜잭션 처리**
> 여러번 외부 컴포넌트를 호출하는 함수들을 리팩토링하면서 느낀건데, 정말 많이 트랜잭션 처리가 안되어 있었다.

- 일단 `Hasura` 공식문서를 뒤져보니 실제로 트랜잭션을 직접 지원하지 않는다.

- 아예 내용이 없는건 아니고, db레벨에서 stored procedure를 사용하고, 해당 함수를 호출 할 수 있도록 generate해준다는걸 보니 정말 지원을 안하는 것 같다.

- 관련해서 논의해봤을 때, 기본적으로 stored procedure를 레거시로 여기는 경향이 있어 해당 stored procedure 도입은 반려되었다.

- 결국 위에서 진행하며 분리한 데이터 소스를 호출하는 함수들에 대해서, 멱등하게 관리 할 수 있는 부분에 대해서는 보상 트랙잭션성 함수들을 추가해서 보완했다.

**4 - typedefs와 같은 gql문법을 조금 더 안전하게 보장 할 수 있지 않을까?**
> 기존에는 엄청난 길이의 typedefs를 거의 로우하게 텍스트로 관리하고 있다.
> 오타에 정말정말정말 많이 취약한 구조였고, 더 좋게 관리할 방법이 있지 않을까 고민됐다.

```typescript
const typeDefs = `
  ${defaultTypeDefs}

  type Query {
    (진짜 엄청 많은 쿼리를 text로 정리한 내용 ..)
  }
  
  // 타입도 진짜 개많다.
  type BannerSchedule {}
  type Banner {}
`;


export const schema = makeExecutableSchema({
  typeDefs,
  resolvers
});
```

gql 관련해서 여기저기 찾아보니, `makeExecutableSchema()`함수에 정말 많은 기능이 있었다.

`requireResolversForNonScalar`, `requireResolversForArgs`와 같은 것들이 있는데, 이런 옵션은 기본값이 false로 되어있다. (관련된 사용 예시 레퍼런스들을 찾아 봤을 때, 실용적인 면에서 너무 보수적인 옵션값들이다.)

각각 스칼라객체의 타입이 잘 구현되어있는지, 리졸버의 아규먼트가 전부 있는게 맞는건지 등을 검증하는데, true로 수정해도 커뮤니티쪽에서는 에러가 안잡혔다.

마찬가지로 너무 가혹한 기준 같아서 내가 진행하는 테스트코드에만 적용을 했다.(before에서 한번 검증하고 시작)


### TO-BE

- 가장 큰 도메인이기는 하다고 짐작했지만, 정말로 5년 된 레거시코드의 커버리지를 `10%` 내외로 끌어올렸다.

- 같이 진행한 리팩토링 덕분에 코드를 보기 훨씬 편해진 것 같다.

- 트랜잭션과 관련해서 조금 더 안전한 코드가 된 것 같다.


