---
title: "\bLearning Go 📚"
summary: 러닝 고 목차
date: 2025-05-02 18:41:31 +0900
lastmod: 2025-08-06 14:28:11 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---
  - [x] 1.2 GO 작업 공간
  - [x] 1.3 GO 명령어
  - [x] 1.4 린팅 그리고 베팅
  - [x] 1.5 개발 도구 소개
  - [x] 1.6 Makefiles
  - [x] 1.7 항상 최신으로 유지
  - [x] 1.8 마무리

- [x] CHAPTER 2 기본 데이터 타입과 선언
  - [x] 2.1 내장 타입
  - [x] 2.2 var Versus :=
	  - 제로값 초기화 할때는 var x int가 낫다
	  - 마찬가지로 타입 지정안된 상수나 리터럴 할당시에도 x := byte(20) 보다는 var x byte = 20 이 낫다.
  - [x] 2.3 CONST 사용
  - [x] 2.4 타입 지정 상수와 타입 미지정 상수
  - [x] 2.5 사용하지 않는 변수
  - [x] 2.6 변수와 상수 이름 짓기
  - [x] 2.7 마무리

- [x] CHAPTER 3 복합 타입
  - [x] 3.1 배열
	  - 제한이 많음
	  - 길이마다 다른 타입이고, 배열 크기를 지정하기위한 변수도 사용못함 (타입이라 컴파일 과정에서 반드시 해석되어야함)
	  - 그리고 동일한 타입을 가진 다른 크기의 배열간에 타입변환을 할 수 없다 (함수 파라미터 사용불가)
	  - 다만 이런 타입을 제공하는건 슬라이스가 배열을 기반으로 구성되어있기 때문
  - [x] 3.2 슬라이스
	  - append와 같은 함수의 반환값을 할당하지 않으면 컴파일에러다.
	  - call by value로 값을 넘기고 추가된 복사본을 반환하기에 다시 할당해줘야한다.
	  - 참고: go runtime은 바이너리에 포함하며, 런타임을 위해 vm등을 설치해야하는 언어가 아님, 그리고 런타임에는 gc나 메모리 할당, 동시성/네트워킹 지원, 내장타입과 함수등이 있다.
	  - 슬라이스는 capacity가 있는데 len보다 길 수 있고, go runtime에 의해 관리된다.
	  - 어떤 경우에 어떻게 선언하는것이 좋을까?
		  - 슬라이스가 전혀 커질 일이 없다면 (함수가 반환안하는 분기) `var` : var data int[]
		  - 시작값이 있는 경우 `리터럴` : data := []int{2, 4, 6, 8}
		  - 슬라이스가 얼마나 커질지 잘 알지만, 뭐가 들어갈지 모르면 `make` (다만 make를 이용해서 만들어놓고 append를 하는 경우라면 그게 필요한지 재검토) 
	  - 슬라이스 슬라이싱은 참조기반
	  - 슬라이스를 취할 때 마다 하위슬라이스의 수용력은 원본 슬라이스의 수용력에서 하위슬라이스의 시작 오프셋만큼을 뺀 값이 설정됨
```go
package main

import "fmt"

func PrintHello() {
	x := make([]int, 0, 5)
	x = append(x, 1, 2, 3, 4)
	y := x[:2]
	z := x[2:]
	fmt.Println(cap(x), cap(y), cap(z))
	x = append(x, 30, 40, 50)
	x = append(x, 60)
	z = append(z, 70)
	fmt.Println("x: ", x)
	fmt.Println("y: ", y)
	fmt.Println("z: ", z)
}

/**
  1. 5 5 3 출력:
    - cap(x) = 5: 초기 용량 5로 생성
    - cap(y) = 5: y는 x[:2]로 같은 배열을 참조하므로 용량 5
    - cap(z) = 3: z는 x[2:]로 인덱스 2부터 시작하므로 남은 용량 3
  2. 슬라이스 공유와 재할당:
    - x에 30, 40, 50, 60을 추가하면 용량 초과로 새 배열 할당
    - y와 z는 여전히 원래 배열 참조
    - z에 70 추가 시 원래 배열의 인덱스 4 위치에 저장
  3. 최종 결과:
    - x: [1 2 3 4 30 40 50 60] - 새 배열
    - y: [1 2] - 원래 배열의 처음 2개 요소
    - z: [3 4 70] - 원래 배열의 인덱스 2부터, 70이 추가됨
*/

func main() {
	PrintHello()
}

```
  - [x] 3.3 문자열과 룬 그리고 바이트
  - [x] 3.4 맵
  - [x] 3.5 구조체
  - [x] 3.6 마무리

- [x] CHAPTER 4 블록, 섀도, 제어 구조
  - [x] 4.1 블록
  - [x] 4.2 if 문
  - [x] 4.3 for 문
  - [x] 4.4 switch 문
  - [x] 4.5 공백 switch 문
  - [x] 4.6 if 문과 switch 문 중 선택
  - [x] 4.7 goto 문
  - [x] 4.8 마무리

- [x] CHAPTER 5 함수
  - [ ] 5.1 함수 선언과 호출
  - [ ] 5.2 함수는 값이다
  - [ ] 5.3 클로저
  - [ ] 5.4 defer
  - [ ] 5.5 값에 의한 호출을 사용하는 Go
  - [ ] 5.6 마무리

- [ ] CHAPTER 6 포인터
  - [ ] 6.1 빠른 포인터 입문
  - [ ] 6.2 포인터를 두려워 말라
  - [ ] 6.3 포인터는 변경 가능한 파라미터를 가리킨다
  - [ ] 6.4 포인터는 최후의 수단
  - [ ] 6.5 포인터로 성능 개선
  - [ ] 6.6 제로 값과 값없음의 차이
  - [ ] 6.7 맵과 슬라이스의 차이
  - [ ] 6.8 버퍼 슬라이스
  - [ ] 6.9 가비지 컬렉션 작업량 줄이기
  - [ ] 6.10 마무리

- [ ] CHAPTER 7 타입, 메서드, 인터페이스
  - [ ] 7.1 Go의 타입
  - [ ] 7.2 메서드
  - [ ] 7.3 구성을 위한 임베딩 사용
  - [ ] 7.4 임베딩은 상속이 아니다
  - [ ] 7.5 인터페이스에 대한 간단한 지도
  - [ ] 7.6 인터페이스는 타입에 안정적인 덕 타이핑이다
  - [ ] 7.7 임베딩과 인터페이스
  - [ ] 7.8 인터페이스를 받고 구조체 반환하기
  - [ ] 7.9 인터페이스와 nil
  - [ ] 7.10 빈 인터페이스는 어떤 것도 표현하지 않는다
  - [ ] 7.11 타입 단언 및 타입 스위치
  - [ ] 7.12 타입 단언과 타입 스위치를 아껴 사용하기
  - [ ] 7.13 함수 타입은 인터페이스로의 연결
  - [ ] 7.14 의존성 주입을 쉽게 만드는 암묵적 인터페이스
  - [ ] 7.15 Wire
  - [ ] 7.16 GoO는 특히 객체지향이 아니다
  - [ ] 7.17 마무리

- [ ] CHAPTER 8 오류
  - [ ] 8.1 오류 처리 방법: 기초
  - [ ] 8.2 단순 오류에 문자열 사용
  - [ ] 8.3 센티넬 오류
  - [ ] 8.4 오류는 값이다
  - [ ] 8.5 오류 래핑
  - [ ] 8.6 Is와 As
  - [ ] 8.7 defer로 오류 래핑
  - [ ] 8.8 패닉과 복구
  - [ ] 8.9 오류에서 스택 트레이스 얻기
  - [ ] 8.10 마무리

- [ ] CHAPTER 9 모듈, 패키지 그리고 임포트
  - [ ] 9.1 저장소, 모듈 그리고 패키지
  - [ ] 9.2 go.mod
  - [ ] 9.3 패키지 빌드
  - [ ] 9.4 모듈 관련 작업
  - [ ] 9.5 모듈 게시
  - [ ] 9.6 모듈 버전 관리
  - [ ] 9.7 모듈을 위한 프록시 서버
  - [ ] 9.8 마무리

- [ ] CHAPTER 10 GO의 동시성
  - [ ] 10.1 동시성 사용 시점
  - [ ] 10.2 고루틴
  - [ ] 10.3 채널
  - [ ] 10.4 select 문
  - [ ] 10.5 동시성 사례와 패턴
  - [ ] 10.6 채널 대신에 뮤텍스를 사용해야 하는 경우
  - [ ] 10.7 원자적 연산
  - [ ] 10.8 마무리

- [ ] CHAPTER 11 표준 라이브러리
  - [ ] 11.1 입출력 관련 기능
  - [ ] 11.2 시간
  - [ ] 11.3 encoding/json
  - [ ] 11.4 net/http
  - [ ] 11.5 마무리

- [ ] CHAPTER 12 컨텍스트
  - [ ] 12.1 컨텍스트 소개
  - [ ] 12.2 취소
  - [ ] 12.3 타이머
  - [ ] 12.4 코드에서 컨텍스트 취소 처리
  - [ ] 12.5 값
  - [ ] 12.6 마무리

- [ ] CHAPTER 13 테스트 작성
  - [ ] 13.1 테스팅의 기초
  - [ ] 13.2 테이블 테스트
  - [ ] 13.3 코드 커버리지 확인
  - [ ] 13.4 벤치마크
  - [ ] 13.5 Go의 스텁
  - [ ] 13.6 httptest
  - [ ] 13.7 통합 테스트 및 빌드 태그
  - [ ] 13.8 레이스 검출기로 동시성 문제 찾기
  - [ ] 13.9 마무리

- [ ] CHAPTER 14 Reflect, Unsafe, Cgo
  - [ ] 14.1 리플렉션은 런타임에 동적으로 타입 제어
  - [ ] 14.2 불안전한 Unsafe
  - [ ] 14.3 성능이 아닌 통합을 위한 Cgo
  - [ ] 14.4 마무리

- [ ] CHAPTER 15 Go의 제네릭
  - [ ] 15.1 반복 코드를 줄이고 타입 안전 증가
  - [ ] 15.2 Go의 제네릭
  - [ ] 15.3 타입 목록을 사용하여 연산자 지정
  - [ ] 15.4 제네릭 함수는 알고리즘을 추상화한다
  - [ ] 15.5 타입 목록은 상수와 구현을 제한한다
  - [ ] 15.6 소외된 것
  - [ ] 15.7 관용적 Go와 제네릭
  - [ ] 15.8 이후 해제될 것들
  - [ ] 15.9 마무리
