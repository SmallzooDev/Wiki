---
title: Lock과 Stream을 어떻게 접근 할 것인가..
summary: 산넘어 산..
date: 2024-11-24 00:23:54 +0900
lastmod: 2024-11-24 00:23:54 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## Issue : 레디스 스트림과 락을 관리하는 이슈 ...😇
---

마스터와 슬레이브를 잘 등록했다고 생각했는데, 실제 쓰기 요청을 전파하다가 바로 이슈가 생겨버렸다.

```rust
#[derive(Clone, Debug)]
pub struct SlaveInfo {
    pub addr: SocketAddr,
    pub offset: i64,
}
```
직전 포스팅에서 이야기 한 것 처럼, SlaveInfo는 위와 같이 관리하고 있었다.

IP주소로 클라이언트를 식별해서, 잘Slave를 등록을 했고, 명령만 전파하면 될 일이었다.

머리가 꽃밭이었던 나는 큰 고민 없이 작업에 착수했는데..


```rust
    async fn execute_set(key: &String, value: &String, ex: Option<u64>, px: Option<u64>, db: Db) -> String {
        let expiration_ms = match (px, ex) {
            (Some(ms), _) => Some(ms),
            (None, Some(s)) => Some(s * 1000),
            _ => None,
        };

        db.write().await.insert(key.clone(), ValueEntry::new_relative(value.clone(), expiration_ms));
        // 1. replconfig에서 슬레이브 목록을 받는다.
        // 2. 해당 슬레이브들에게 set과 커맨드를 전송한다.
        // 3. tcpstream::new()...? 응....?
        format!("{}OK{}", SIMPLE_STRING_PREFIX, CRLF)
    }

```

사실 위의 주석 내용도 멍청하게도 해보고 나서야 깨닫은 내용이다

바로 실행한 결과는 내 쓰기 요청을 레플리카들이 못받았다고 test fail이 발생했다.

## 나는 stateless 한 서버-클라이언트에만 절어있는사람.. 🤐
---

사실 이슈는 너무 당연했다. 

클라이언트(레플리카)가 syc-ack을 하러 스트림을 개설하면, 해당 스트림 내에서 이후 처리가 이뤄져야 하는데

너무 요청을 단위로 로직을 끊어놓아서 그리고 그런 방식으로만 생각해서, 자연스럽게 생각을 하지 못한 것 같다

레디스 자체가 서버처럼 응답을 하고, 아마도 대부분의 어플리케이션의 라이브러리에 스트림을 관리하게 되어있을거고,

단건의 간단한 요청은 바로 스트림을 끊어버리도록 되어있을 것이다. (클라언트 사이드에서 명시적인 스트림 닫기) 

그게 아닌 상황에서는 오히려 디폴트는 개설한 스트림을 끊지 않는다는 것이다.

그리고 특히나 레플리카와 마스터의 관계에서는 당연히 스트림을 끊을 이유가 없었다.

> 너무 망상일 수 있겠지만, 제작자들이 지금 시점에서 해당 문제에 직면하도록 설계를 해 둔 것 같기도 하다. 
> 여기가 아는 다른 부분에서는 스트림 개설이 자유로웠다.

## 그러면 스트림을 보관하면 되잖아?
---

```rust
#[derive(Clone, Debug)]
pub struct SlaveInfo {
    pub addr: SocketAddr,
    pub offset: i64,
    pub 아까_열린_스트림: Arc<Lock<TcpStream>>
}
```

일단 근데, 바로 시작하고 수정하려고 했더니 당연히 `Lock`을 걸어야 했다.

`Lock` 생각을 하자 마자 마음이 불안해지고 심사가 뒤틀렸다.

아 맞다 

멀티스레드지.. 

스트림이 락이네..  

그리고 난 쓰기요청을 전파해야 하네.. 

당장 10건의 쓰기가 있을 때 레플리카가 두세개만 있는 상황만 생각해도..

> 즉시  결합! 앞으로 모든 쓰기는 레플리카 스트림 락을 반환받기 전까지 응 못해~


## 그러면 찐레디스는 어떻게 해?
---

> 응~ 레디스 형들은 이벤트루프 다 만들어 놨어~ '이벤트 루프 기반의 싱글 스레드 프로그램' 이라고 광고했는데, 그게 느껴져?

여기서 솔직히 그냥 멘붕이 너무 심했다.

지금까지 한 스테이지들을 다 갈아 엎..어도 토키오나 이런부분을 잘 모르는 내가 지금부터 이벤트 루프로직을 잘 찾아서 이용할 수 있는지도 모르겠고,

사실 이미 어떠한 부분은 그렇게 되고 있나 싶기도 하고..


## 결론?
---

을 고민하다가 아직 해결을 못했다.

일단 스트림은 보관하되 명확하게 전파하는 부분을 잘 분리해서 비동기이면서 이벤트루프스럽게 구현 할 건덕지를 찾기는 했다. 바로 `mpsc`

이걸 제대로 이용하려면 일단 더 찾아보기도 해야할 것 같고, 특히 토키오쪽도 더 뒤적여야 제대로 사용 할 수 있을 것 같다.

아마도 내일  진행 할 듯 하다.
