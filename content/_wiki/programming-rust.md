---
title: 프로그래밍 러스트 💭
summary: 
date: 2025-06-07 12:45:57 +0900
lastmod: 2025-06-07 22:13:48 +0900
tags: 
categories: 
description: 
showToc: true
tocOpen: true
---

## 끄적

- 길이는 타입의 일부, 슬라이스는 길이 제한이 없으므로 변수에 직접 저장하거나 함수 인수로 전달할 수 없다.
- 슬라이스 레퍼런스는 팻 포인터로 슬라이스의 첫 번째 요소를 가리키는 포인터와 그 안에 있는 요소의 개수로 구성되는 2워드 크기의 값이다.


## 이동 관련
- 러스트에서는 모든 이동이 원본을 미초기화 상태로 두는 바이트 단위의 얕은 복사다.
- 복사는 원본의 초기화 상태를 유지한다는 점만 제외하면 이도오가 똑같다.
- 이동과 레퍼런스 카운트 기반의 포인터는 소유 관계 트리의 경직성을 완화하는 두가지 방법이다.


## 참조 관련
- cpp의 역참조는 암시적으로 이루어지고, 러스트의 역참조는 명시적으로 이루어진다. 하지만 `.`연산은 암시적 역참조를 해준다.
- 특히나 `.`연산자는 피연산자의 암묵적으로 피연산자의 레퍼런스를 차용할 수 있다.

## 라이프타임 관련
- 변수의 수명은 자신에게서 차용된 레퍼런스의 수명을 포함(contain)하거나, 에워싸야(enclose)한다.
- 또 다른 제약 조건은, 변수에 레퍼런스를 저장할 때, 레퍼런스의 타입이 변수의 전체 수명, 즉 변수가 초기화되는 지점부터 마지막으로 사용되는 지점까지 내내 유효해야한다는 것이다.
![rustlifetime](https://github.com/user-attachments/assets/d319448b-dfe6-4e12-844a-ca5c2ad77afe)
- `f(p: &'static i32)` : 레퍼런스를 전역변수에 담아두려는 의도를 시그니처에 드러내지 않고서는 원하는 행동을 할 수 없다.
- 반대로 `f<'a>(p: &a' i32)` : 인수 p가 함수의 호출 구간보더 더 긴 수명을 가진 어딘가에 보관되는 일이 없다는 걸 알 수 있다.

![lifetimerust](https://github.com/user-attachments/assets/f8cd7d24-0a80-4af7-b667-bf277889c032)